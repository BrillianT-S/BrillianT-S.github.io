{"meta":{"title":"马小跳的秘密基地","subtitle":"能受天磨真好汉 不遭人嫉是庸才","description":"博客,移动开发,blog","author":"马小跳","url":"https://brillianttt.gitee.io","root":"/"},"pages":[{"title":"about","date":"2020-01-22T05:07:11.000Z","updated":"2020-01-22T05:08:27.240Z","comments":true,"path":"about/index.html","permalink":"https://brillianttt.gitee.io/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-01-22T05:10:19.000Z","updated":"2020-01-22T05:11:00.789Z","comments":true,"path":"contact/index.html","permalink":"https://brillianttt.gitee.io/contact/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-04-04T02:42:50.000Z","updated":"2020-04-04T02:42:26.313Z","comments":true,"path":"categories/index.html","permalink":"https://brillianttt.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-20T06:06:52.000Z","updated":"2020-01-20T06:10:10.726Z","comments":true,"path":"tags/index.html","permalink":"https://brillianttt.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"实习笔记","slug":"实习笔记","date":"2022-07-11T14:10:20.000Z","updated":"2022-07-11T14:14:27.235Z","comments":true,"path":"2022/07/11/实习笔记/","link":"","permalink":"https://brillianttt.gitee.io/2022/07/11/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"项目开发中常用的数据类型的简称包含POJO、PO、DTO、DAO、BO、VO，各自含义如下： POJO：全称为：Plain Ordinary Java Object，即简单普通的java对象。一般用在数据层映射到数据库表的类，类的属性与表字段一一对应。 PO：全称为：Persistant Object，即持久化对象。可以理解为数据库中的一条数据即一个BO对象，也可以理解为POJO经过持久化后的对象。 DTO：全称为：Data Transfer Object，即数据传输对象。一般用于向数据层外围提供仅需的数据，如查询一个表有50个字段，界面或服务只需要用到其中的某些字段，DTO就包装出去的对象。可用于隐藏数据层字段定义，也可以提高系统性能，减少不必要字段的传输损耗。 DAO：全称为：Data Access Object，即数据访问对象。就是一般所说的DAO层，用于连接数据库与外层之间的桥梁，并且持久化数据层对象。 BO：全称为：Business Object，即业务对象。一般用在业务层，当业务比较复杂，用到比较多的业务对象时，可用BO类组合封装所有的对象一并传递。 VO：全称为：Value Object，有的也称为View Object，即值对象或页面对象。一般用于web层向view层封装并提供需要展现的数据。","categories":[{"name":"实习笔记","slug":"实习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"实习","slug":"实习","permalink":"https://brillianttt.gitee.io/tags/%E5%AE%9E%E4%B9%A0/"}]},{"title":"MyBatisPlus学习","slug":"MyBatisPlus学习","date":"2022-07-07T13:57:37.000Z","updated":"2022-07-19T14:57:54.247Z","comments":true,"path":"2022/07/07/MyBatisPlus学习/","link":"","permalink":"https://brillianttt.gitee.io/2022/07/07/MyBatisPlus%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"入门简介 | MyBatis-Plus，也是官方文档 快速构建一个工程SpringBoot+MyBatisPlus 添加依赖：引入 Spring Boot Starter 父工程： 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;spring-latest-version&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; 引入 spring-boot-starter、spring-boot-starter-test、mybatis-plus-boot-starter、h2 依赖： 123456789101112131415161718192021222324252627282930313233343536373839&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.3.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件application.yml: 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/test?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver 启动类添加注解@MapperScan，用于扫描包： 1234567891011121314package com.ma;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@MapperScan(\"com.ma.mapper\")@SpringBootApplicationpublic class MybatisplusTestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MybatisplusTestApplication.class, args); &#125;&#125; 编码实体类User.java： 1234567@Datapublic class User &#123; private Long id; private String name; private Integer age; private String email;&#125; Mapper类 UserMapper.java: 123public interface UserMapper extends BaseMapper&lt;User&gt; &#123;//此时所有的CRUD操作都已经被MyBatis自动编写好了&#125; 测试添加测试类testSelect.java，此处UserMapper 中的 selectList() 方法的参数为 MP 内置的条件封装器 Wrapper，所以不填写就是无任何条件 123456789101112131415@SpringBootTestpublic class SampleTest &#123; @Autowired private UserMapper userMapper; @Test public void testSelect() &#123; System.out.println((\"----- selectAll method test ------\")); List&lt;User&gt; userList = userMapper.selectList(null); Assert.assertEquals(5, userList.size()); userList.forEach(System.out::println); &#125;&#125; 主键生成策略可使用@TableId注解设置主键生成策略，注意使用ASSIGN_ID和ASSIGN_UUID时主键类型的要求 12345678910@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; @TableId(type = IdType.AUTO) private Long id; private String name; private Integer age; private String email;&#125; 查看源码可以知道，type的类型包含以下几种： 123456789101112131415161718192021222324252627282930313233343536public enum IdType &#123; &#x2F;** * 数据库ID自增 * &lt;p&gt;该类型请确保数据库设置了 ID自增 否则无效&lt;&#x2F;p&gt; *&#x2F; AUTO(0), &#x2F;** * 该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 INPUT) *&#x2F; NONE(1), &#x2F;** * 用户输入ID * &lt;p&gt;该类型可以通过自己注册自动填充插件进行填充&lt;&#x2F;p&gt; *&#x2F; INPUT(2), &#x2F;* 以下2种类型、只有当插入对象ID 为空，才自动填充。 *&#x2F; &#x2F;** * 分配ID (主键类型为number或string）, * 默认实现类 &#123;@link com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator&#125;(雪花算法) * * @since 3.3.0 *&#x2F; ASSIGN_ID(3), &#x2F;** * 分配UUID (主键类型为 string) * 默认实现类 &#123;@link com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator&#125;(UUID.replace(&quot;-&quot;,&quot;&quot;)) *&#x2F; ASSIGN_UUID(4); private final int key; IdType(int key) &#123; this.key &#x3D; key; &#125;&#125; 增删查改操作123456789101112131415161718192021222324252627282930313233343536373839404142@SpringBootTestclass MybatisPlusApplicationTests &#123; //继承了BaseMapper，所有的方法都来自父类 //我们也可以编写自己的扩展方法 @Autowired(required = false) private UserMapper userMapper; //以下为增删查改操作，具体可看源码学习 @Test void testInsert()&#123; userMapper.insert(new User(6L,\"mby\",21,\"12345@qq.com\")); List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println); &#125; @Test void testDelete()&#123; userMapper.deleteById(5L); List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println); &#125; @Test void contextLoads() &#123; //参数是一个Wrapper，条件构造器，这里我们先不用 null //查询全部用户 List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println); &#125; @Test void testUpdate()&#123; User temp = new User(6L,\"mby\",21,\"12345@qq.com\"); userMapper.insert(temp); User user = new User(6L,\"mbyyyy\",21,\"12345@qq.com\"); userMapper.updateById(user); List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println); &#125;&#125; 自动填充功能数据库标表先添加创建时间和修改时间两个字段，实体类也进行添加，然后使用@TableField注解 1234567891011121314@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; @TableId(type = IdType.ASSIGN_ID) private String id; private String name; private Integer age; private String email; @TableField(fill = FieldFill.INSERT) public LocalDateTime createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private LocalDateTime updateTime;&#125; 时间参数如下： LocalDate ： 只含年月日的日期对象 LocalTime ：只含时分秒的时间对象 LocalDateTime ： 同时含有年月日时分秒的日期对象 @TableField注解原型如下： 123456789101112131415161718public enum FieldFill &#123; /** * 默认不处理 */ DEFAULT, /** * 插入时填充字段 */ INSERT, /** * 更新时填充字段 */ UPDATE, /** * 插入和更新时填充字段 */ INSERT_UPDATE&#125; 更多参数查看LocalDateTime用法 - 简书 (jianshu.com) 由于mybatisplus自带驼峰映射，故createTime可映射数据库表中的create_time,updateTime也是一样。 完成实体类和数据库表的改进后设置实现类，其中@Slf4j为设置日志，包含log方法。 123456789101112131415161718192021222324@Slf4j@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; log.info(\"start insert fill ....\"); this.strictInsertFill(metaObject, \"createTime\", LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0(推荐使用) // 或者 this.strictInsertFill(metaObject, \"createTime\", () -&gt; LocalDateTime.now(), LocalDateTime.class); // 起始版本 3.3.3(推荐) // 或者 this.fillStrategy(metaObject, \"createTime\", LocalDateTime.now()); // 也可以使用(3.3.0 该方法有bug) &#125; @Override public void updateFill(MetaObject metaObject) &#123; log.info(\"start update fill ....\"); this.strictUpdateFill(metaObject, \"updateTime\", LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0(推荐) // 或者 this.strictUpdateFill(metaObject, \"updateTime\", () -&gt; LocalDateTime.now(), LocalDateTime.class); // 起始版本 3.3.3(推荐) // 或者 this.fillStrategy(metaObject, \"updateTime\", LocalDateTime.now()); // 也可以使用(3.3.0 该方法有bug) &#125;&#125; 乐观锁乐观锁：顾名思义十分乐观，他总是认为不会出现问题，无论干什么不去上锁！如果出现了问题，再次更新值测试！ 悲观锁：顾名思义十分悲观，他总是任务总是出现问题，无论干什么都会上锁！再去操作！ 乐观锁实现方式： 取出记录，获取当前version 更新时，带上这个version 执行更新时，set version = new version where version = oldversion 如果version不对，就更新失败 12345678乐观锁：1、先查询，获得版本号 version = 1-- Aupdate user set name = \"ChanV\", version = version + 1where id = 2 and version = 1-- B 线程抢先完成，这个时候 version = 2，会导致 A 修改失败！update user set name = \"ChanV\", version = version + 1where id = 2 and version = 1 使用乐观锁： 数据库表中添加version字段 实体类添加对应字段和注解 12@Version //乐观锁version注解private Integer version; 注册组件 1234567891011//扫描我们的mapper文件夹@MapperScan(\"com.chanv.mapper\")@EnableTransactionManagement@Configuration //配置类public class MyBatisPlusConfig &#123; //注册乐观锁插件 @Bean public OptimisticLockerInnerInterceptor optimisticLockerInnerInterceptor()&#123; return new OptimisticLockerInnerInterceptor(); &#125;&#125; 测试 1234567891011121314151617181920212223242526272829 //测试乐观锁成功！ @Test public void testOptimisticLocker()&#123; //1、查询用户信息 User user = userMapper.selectById(1330080433207046145L); //2、修改用户信息 user.setName(\"ChanV\"); user.setEmail(\"1277077741@qq.com\"); //3、执行更新操作 userMapper.updateById(user); &#125; //测试乐观锁失败！多线程下 @Test public void testOptimisticLocker2()&#123; //线程1 User user = userMapper.selectById(5L); user.setName(\"ChanV111\"); user.setEmail(\"1277077741@qq.com\"); //模拟另一个线程执行了插队操作 User user2 = userMapper.selectById(5L); user2.setName(\"ChanV222\"); user2.setEmail(\"1277077741@qq.com\"); userMapper.updateById(user2); //自旋锁多次尝试提交 userMapper.updateById(user); //如果没有乐观锁就会覆盖队线程的值 &#125;&#125; 分页首先配置拦截器组件： 12345678910111213@MapperScan(\"com.ma.mapper\")@EnableTransactionManagement@Configurationpublic class MyBatisPlusConfig &#123; //分页插件 @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 然后直接使用Page对象 1234567891011//测试分页查询@Testpublic void testPage()&#123; //参数一：当前页 //参数二：页面大小 //使用了分页插件之后，所有的分页操作也变得简单了！ Page&lt;User&gt; page = new Page&lt;&gt;(2, 5); userMapper.selectPage(page, null); page.getRecords().forEach(System.out::println); System.out.println(page.getTotal());&#125;","categories":[],"tags":[{"name":"MyBatisPlus","slug":"MyBatisPlus","permalink":"https://brillianttt.gitee.io/tags/MyBatisPlus/"}]},{"title":"SpringBoot学习","slug":"SpringBoot学习","date":"2022-07-01T14:11:02.000Z","updated":"2022-07-04T14:45:55.809Z","comments":true,"path":"2022/07/01/SpringBoot学习/","link":"","permalink":"https://brillianttt.gitee.io/2022/07/01/SpringBoot%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"入门什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。 所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。 是的这就是Java企业级应用-&gt;J2EE-&gt;spring-&gt;springboot的过程。 随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件； Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。 简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。 Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。 Spring Boot的主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 Spring官方提供了非常方便的工具让我们快速构建应用 Spring Initializr：https://start.spring.io/ 项目创建方式一：使用Spring Initializr 的 Web页面创建项目 1、打开 https://start.spring.io/ 2、填写项目信息 3、点击”Generate Project“按钮生成项目；下载此项目 4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。 5、如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。 项目创建方式二：使用 IDEA 直接创建项目 1、创建一个新项目 2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现 3、填写项目信息 4、选择初始化的组件（初学勾选 Web 即可） 5、填写项目路径 6、等待项目构建成功 查看一下pom.xml文件导入的依赖 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.1&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;helloworld&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;helloworld&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt;&lt;!-- web依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!--单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;!--打包插件--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 编写一个http接口1、在主程序的同级目录下，新建一个controller包，一定要在同级目录下，否则识别不到 2、在包中新建一个HelloController类 12345678910111213package com.example.helloworld.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String hello()&#123; return \"helloworld\"; &#125;&#125; 直接运行，打开浏览器查看localhost:8080/hello,发现已经有了输出helloworld。 另外，在resources路径下的application.properties中可以设置各种参数，如设置端口的语句为：server.port=1234,resources路径下还可新建banner.txt文件，项目运行时默认的spring字符就会变为banner文件中的字符，具体可以从这里查找Spring Boot banner在线生成工具 原理初探pom.xml在pom.xml中有各种配置文件，其中父路径中的spring-boot-starter-parent的父路径spring-boot-dependencies保存了各种项目中用到的源码。以后我们导入依赖默认是不需要写版本的；但是如果导入的包没有在依赖中管理着就需要手动配置版本了。 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.1&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 启动器 spring-boot-starter1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; springboot-boot-starter-xxx：就是spring-boot的场景启动器 spring-boot-starter-web：帮我们导入了web模块正常运行所依赖的组件； SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter； 主启动类默认的主启动类： 123456789101112import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication &#x2F;&#x2F;用来标注一个主程序类，说明这是一个Spring Boot应用public class Sprintboot01Application &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;启动一个服务 SpringApplication.run(Sprintboot01Application.class, args); &#125;&#125; 从主启动类引入，下面依次分析常见的注解。 SpringBootApplication作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；进入这个注解：可以看到上面还有很多其他注解！ 12345678910111213141516171819202122232425262728293031323334353637383940414243//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package org.springframework.boot.autoconfigure;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.beans.factory.support.BeanNameGenerator;import org.springframework.boot.SpringBootConfiguration;import org.springframework.boot.context.TypeExcludeFilter;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.FilterType;import org.springframework.context.annotation.ComponentScan.Filter;import org.springframework.core.annotation.AliasFor;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; @AliasFor( annotation = EnableAutoConfiguration.class ) ... ... @ComponentScan: 这个注解在Spring中很重要 ,它对应XML配置中的元素。 作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中 @SpringBootConfiguration 作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类。 1234567891011121314151617181920import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.context.annotation.Configuration;import org.springframework.core.annotation.AliasFor;import org.springframework.stereotype.Indexed;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configuration@Indexedpublic @interface SpringBootConfiguration &#123; @AliasFor( annotation = Configuration.class ) boolean proxyBeanMethods() default true;&#125; ​ 这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件； ​ 里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！ ​ 我们回到 SpringBootApplication 注解中继续看。 @EnableAutoConfiguration： @EnableAutoConfiguration ：开启自动配置功能 以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效；点进注解接续查看： AutoConfigurationPackage ：自动配置包 @Import({Registrar.class}) public @interface AutoConfigurationPackage {} &lt;!--￼7--&gt; 这个类主要做了以下四件事情： 1、推断应用的类型是普通的项目还是Web项目 2、查找并加载所有可用初始化器 ， 设置到initializers属性中 3、找出所有的应用程序监听器，设置到listeners属性中 4、推断并设置main方法的定义类，找到运行的主类 查看一下它的构造器： 算了先别看了，框架用熟了再填坑🖐 yaml配置注入SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的 application.properties 语法结构 ：key=value application.yml 语法结构 ：key：空格 value 配置文件的作用 ：修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了； yaml概述YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言） 这种语言以数据作为中心，而不是以标记语言为重点！ 以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml 传统xml配置： 123&lt;server&gt; &lt;port&gt;8081&lt;port&gt;&lt;/server&gt; yaml配置： 12server： prot: 8080 yaml基础语法说明：语法要求严格！ 1、空格不能省略 2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。 3、属性和值的大小写都是十分敏感的。 字面量：普通的值 [ 数字，布尔值，字符串 ] 字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号； 1k: v 注意： “ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；比如 ：name: “kuang \\n shen” 输出 ：kuang 换行 shen ‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出;比如 ：name: ‘kuang \\n shen’ 输出 ：kuang \\n shen 对象、Map（键值对） 1234#对象、Map格式k: v1: v2: 在下一行来写对象的属性和值关系，注意缩进；比如： 123student: name: mby age: 3 行内写法： 1student: &#123;name: mby,age: 20&#125; 数组（ List、set ） 用 - 值表示数组中的一个元素,比如： 1234pets: - cat - dog - pig 行内写法： 1student: [cat,dog,pig] 修改SpringBoot的默认端口号 配置文件中添加，端口号的参数，就可以切换端口； 12server: port: 8082 yaml注入配置文件yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！ 首先看以往的装配： 实体类： 1234567891011121314151617181920212223242526272829303132333435363738package com.ma.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component //注册bean到容器中public class Dog &#123; @Value(\"阿黄\") private String name; @Value(\"18\") private Integer age; public String getName() &#123; return name; &#125; @Override public String toString() &#123; return \"Dog&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;//有参无参构造、get、set方法、toString()方法&#125; 测试文件： 123456789101112@SpringBootTestclass DemoApplicationTests &#123; @Autowired //将狗狗自动注入进来 Dog dog; @Test public void contextLoads() &#123; System.out.println(dog); //打印看下狗狗对象 &#125;&#125; 成功输出Dog{name=’阿黄’, age=18}，下面来看使用yaml注入参数信息的方法。 我们在编写一个复杂一点的实体类：Person 类 123456789101112@Component //注册bean到容器中@Data@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; 配置文件application.yaml： 12345678910111213person: name: qinjiang age: 3 happy: false birth: 2000/01/01 maps: &#123;k1: v1,k2: v2&#125; lists: - code - girl - music dog: name: 旺财 age: 1 测试类： 1234567891011@SpringBootTestclass DemoApplicationTests &#123; @Autowired Person person; @Test public void contextLoads() &#123; System.out.println(person); &#125;&#125; 加载指定的配置文件@PropertySource ：加载指定的配置文件； @configurationProperties：默认从全局配置文件中获取值；如 1@PropertySource(value &#x3D; &quot;classpath:person.properties&quot;) JSR303校验Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式； 1234567@Component //注册bean@ConfigurationProperties(prefix = \"person\")@Validated //数据校验public class Person &#123; @Email(message=\"邮箱格式错误\") //name必须是邮箱格式 private String name;&#125; 运行结果 ：default message [不是一个合法的电子邮件地址];JSR校验可以用于数据校验，保证数据的完整性。 12345678910111213141516171819202122232425262728@NotNull(message=\"名字不能为空\")private String userName;@Max(value=120,message=\"年龄最大不能查过120\")private int age;@Email(message=\"邮箱格式错误\")private String email;空检查@Null 验证对象是否为null@NotNull 验证对象是否不为null, 无法查检长度为0的字符串@NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.@NotEmpty 检查约束元素是否为NULL或者是EMPTY.Booelan检查@AssertTrue 验证 Boolean 对象是否为 true@AssertFalse 验证 Boolean 对象是否为 false长度检查@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内@Length(min=, max=) string is between min and max included.日期检查@Past 验证 Date 和 Calendar 对象是否在当前时间之前@Future 验证 Date 和 Calendar 对象是否在当前时间之后@Pattern 验证 String 对象是否符合正则表达式的规则.......等等除此以外，我们还可以自定义一些数据校验规则","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://brillianttt.gitee.io/tags/SpringBoot/"}]},{"title":"《Java8实战》学习笔记","slug":"《Java8实战》学习笔记","date":"2022-06-30T00:47:31.000Z","updated":"2022-06-30T08:13:04.271Z","comments":true,"path":"2022/06/30/《Java8实战》学习笔记/","link":"","permalink":"https://brillianttt.gitee.io/2022/06/30/%E3%80%8AJava8%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"通过行为参数化传递代码初探 目的：应对不断变化的需求，如《Java8实战》中给出的第一个例子：筛选绿苹果，客户不断提出筛选条件：选绿色的、超过150g的、光滑的、甜的。 不利因素：这些条件如果一个一个加入到筛选方法的传入参数中会显得很冗余，且不利于代码的阅读。 解决方法：通过参数化的方法来传递代码，这是Java8的新特性，具体例子如下： 首先新建一个实体类（省略了get和set方法以及tostring方法）： 1234public class Apple &#123; private int weight; private String color; private boolean flag; 接着添加一个接口Applepredicate： （predicate的意思是谓语、断言） 123public interface ApplePredicate&#123; boolean test (Apple apple);&#125; 然后添加接口的实现类AppleGreenColorPredicate： 12345public class AppleGreenColorPredicate implements ApplePredicate&#123; public boolean test(Apple apple)&#123; return \"green\".equals(apple.getColor()); &#125;&#125; 再添加一个实现类AppleHeavyWeightPredicate： 12345public class AppleHeavyWeightPredicate implements ApplePredicate&#123; public boolean test(Apple apple)&#123; return apple.getWeight() &gt; 150; &#125;&#125; 最后添加一个测试类test： 12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;import java.util.List;public class test &#123; //定义苹果的容器 private static List&lt;Apple&gt; apples = new ArrayList&lt;&gt;(); //初始化装苹果的容器 private static List&lt;Apple&gt; initApples()&#123; Apple apple01 = new Apple(1150,\"red\",true); Apple apple02 = new Apple(230,\"red\",false); Apple apple03 = new Apple(100,\"green\",true); Apple apple04 = new Apple(180,\"red\",false); Apple apple05 = new Apple(20,\"green\",true); apples.add(apple01); apples.add(apple02); apples.add(apple03); apples.add(apple04); apples.add(apple05); return apples; &#125; public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory, ApplePredicate p)&#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple: inventory)&#123; if(p.test(apple))&#123; result.add(apple); &#125; &#125; return result; &#125; public static void main(String[] args) &#123; List&lt;Apple&gt; apples = initApples(); List&lt;Apple&gt; redAndHeavyApples = filterApples(apples, new AppleGreenColorPredicate() &#123; &#125;); System.out.println(redAndHeavyApples); &#125;&#125; 从上面这个例子我们可以看到，测试类test中的filterApples静态方法传入了两个参数，一个是苹果信息，另一个就是传递的代码片段，而这部分代码的具体实现是在ApplePredicate接口的实现类中。如果现在遇到产品经理想改需求，那么我们就可以直接在实现类中进行修改或添加，而不需要用原来的方法，通过传入多个参数来控制筛选的条件。代码的耦合度降低，层次更加清晰了，但工作量还是没有减少，因为还需要声明很多只要实例化一次的类，下面提出改进方法。 使用匿名类匿名类和你熟悉的Java局部类（块中定义的类）差不多，但匿名类没有名字。它允许你同时声明并实例化一个类。换句话说，它允许你随用随建。下面的代码展示了如何通过创建一个用匿名类实现ApplePredicate的对象，重写筛选的例子： 12345678910public static void main(String[] args) &#123; List&lt;Apple&gt; apples = initApples(); List&lt;Apple&gt; redApples = filterApples(apples, new ApplePredicate() &#123; public boolean test(Apple apple)&#123; return \"red\".equals(apple.getColor()); &#125; &#125;); System.out.println(redApples); &#125; 对比这部分和上面的test类中的mian函数，发现使用匿名类可以省去编写ApplePredicate接口的实现类，直接内联参数化filterapples方法的行为。下面来看更灵活的方法。 使用Lambda表达式上述的代码可以写成如下的样子： 123456 public static void main(String[] args) &#123; List&lt;Apple&gt; apples = initApples(); List&lt;Apple&gt; result = filterApples(inventory, (Apple apple) -&gt; \"red\".equals(apple.getColor())); System.out.println(redApples); &#125; 将 List 类型抽象化在通往抽象的路上，我们还可以更进一步。目前，filterApples方法还只适用于Apple。还可以将List类型抽象化，从而超越眼前要处理的问题： 123456789101112public interface Predicate&lt;T&gt;&#123; boolean test(T t); &#125; public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p)&#123; List&lt;T&gt; result = new ArrayList&lt;&gt;(); for(T e: list)&#123; if(p.test(e))&#123; result.add(e); &#125; &#125; return result; &#125; 现在可以把filter方法用在香蕉、桔子、Integer或是String的列表上了。这里有一个使用Lambda表达式的例子： 1234List&lt;Apple&gt; redApples = filter(inventory, (Apple apple) -&gt; \"red\".equals(apple.getColor())); List&lt;Integer&gt; evenNumbers = filter(numbers, (Integer i) -&gt; i % 2 == 0);","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://brillianttt.gitee.io/tags/Java/"}]},{"title":"面试","slug":"记录面试过程","date":"2022-06-22T13:36:17.000Z","updated":"2022-06-22T13:36:21.058Z","comments":true,"path":"2022/06/22/记录面试过程/","link":"","permalink":"https://brillianttt.gitee.io/2022/06/22/%E8%AE%B0%E5%BD%95%E9%9D%A2%E8%AF%95%E8%BF%87%E7%A8%8B/","excerpt":"","text":"记录我的第一次面试​ 2022.6.22，大学以来第一次面试正式工作岗位（实习生），面试单位是成都数之联科技有限公司，后端开发实习生岗位（Java）。下面简单做一个记录，为之后可能的面试积累经验。首先做自我介绍，面试官简单了解下我的情况，完毕后面试官从我的专业信息安全方向引入，开始提问： 信息安全岗位整体的开发流程是什么，如果想做一个整体的安全方案应该怎么实施？ 比如当前有一个银行系统的登陆界面，第三方可以攻破吗，如果可以可能会通过什么方式？ 从零开始设计一个登陆界面，你会怎么设计？（我回答偏了，可从数据库开始，逐层调用数据（具体哪几层），返回到前端） 怎么设置多对一和多对多的表（没达到点上，基础不牢） hashmap的底层结构是什么，如何实现？（没答上来） 数据热点问题，一万个数据，其中七千个经常被访问，其他三千个很少被访问，在数据结构和算法的角度看，怎么存储更好？ 深搜和广搜的区别，怎么实现，各侧重于解决什么问题？ 使用多线程时有哪几种方式实现加锁？（只答上来了synchronized） 是否知道可重用锁的概念？（源自上一题，基础知识，没答上来） 多线程和锁在之前项目中的应用 ​ 技术上的提问到这里基本结束了，对我的大致评价是了解过java基础，基础知识部分仍有待提高。然后面试官问了平时的学习情况，平时是否有看英文官方文档。最后问了面试官进入之后实习用了哪些技术栈，一般用SpringBoot和SpringCloud，但重要的还是内功，基础要打牢固，目前实习生实操能力都有限，重要的还是考察对基础知识的掌握情况，良好的基础有助于写出优秀的代码，至此面试结束，面试结果之后通知。 ​ 这次面试我个人的感受是准备严重不足，虽然做了一定的准备，但是深挖一个知识点，对底层的了解还是不足，还需要在后续继续认真学习。另一方面，目前学习的东西还远不能用于生产中，如上面问到的冷热数据的问题，到现在依旧没有想到合适的解决方案。最后，本次面试过于紧张，但面试官很耐心，引导我寻求问题的解决方法，并给我指出当前的问题，这正是我需要的。不论本次公司面试是否能够作为实习生入职，都对我影响深刻，可以说给了我当头一棒，让我深刻感受到当前所处的情况，以后必加倍努力学习，为成为一名合格的后端开发工程师而奋斗！✊","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://brillianttt.gitee.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Java面试题","slug":"Java面试题","date":"2022-06-21T14:41:47.000Z","updated":"2022-06-22T12:42:59.719Z","comments":true,"path":"2022/06/21/Java面试题/","link":"","permalink":"https://brillianttt.gitee.io/2022/06/21/Java%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"面试题|Java基础17道常见面试题 - 知乎 (zhihu.com) 基本数据类型和引用数据类型的区别_ Java 中操作字符串都有哪些类？它们之间有什么区别？操作字符串的类有：String、StringBuffer、StringBuilder。 String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。 StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。 String str=”i”与 String str=new String(“i”)一样吗？不一样，因为内存的分配方式不一样。String str=”i”的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。 代码示例： 12345String x = \"叶痕秋\";String y = \"叶痕秋\";String z = new String(\"叶痕秋\");System.out.println(x == y); // trueSystem.out.println(x == z); // false String x = “叶痕秋” 的方式，Java 虚拟机会将其分配到常量池中，而常量池中没有重复的元素，比如当执行“叶痕秋”时，java虚拟机会先在常量池中检索是否已经有“叶痕秋”,如果有那么就将“叶痕秋”的地址赋给变量，如果没有就创建一个，然后在赋给变量；而 String z = new String(“叶痕秋”) 则会被分到堆内存中，即使内容一样还是会创建新的对象。 String 类的常用方法都有哪些？ indexOf()：返回指定字符的索引。 charAt()：返回指定索引处的字符。 replace()：字符串替换。 trim()：去除字符串两端空白。 split()：分割字符串，返回一个分割后的字符串数组。 getBytes()：返回字符串的 byte 类型数组。 length()：返回字符串长度。 toLowerCase()：将字符串转成小写字母。 toUpperCase()：将字符串转成大写字符。 substring()：截取字符串。 equals()：字符串比较。 BIO、NIO、AIO 有什么区别？ BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。 NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。 AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://brillianttt.gitee.io/tags/Spring/"}]},{"title":"数字取证技术复习提纲","slug":"数字取证技术复习提纲","date":"2022-06-17T15:31:43.000Z","updated":"2022-06-18T13:33:13.445Z","comments":true,"path":"2022/06/17/数字取证技术复习提纲/","link":"","permalink":"https://brillianttt.gitee.io/2022/06/17/%E6%95%B0%E5%AD%97%E5%8F%96%E8%AF%81%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/","excerpt":"","text":"CHAPTER 1 了解数字取证专业和调查Understanding the Digital Forensics Profession and Investigations CHAPTER 2 调查员办公室和实验室The Investigator’s Office and Laboratory 目标 • 解释如何准备计算机调查 • 用系统的方法进行调查 • 描述公司高科技的程序调查 • 解释数据恢复工作站和软件的要求 • 描述如何进行调查 • 解释如何完成和评论案例 CHAPTER 3 数据采集Data Acquisition CHAPTER 4 处理犯罪和事件现场Processing Crime and Incident Scenes CHAPTER 5 使用Windows和CLI系统Working with Windows and CLI Systems CHAPTER 6 当前数字取证工具Current Digital Forensics Tools 名词解释 计算机取证（数字取证）：是将科学调查技术应用于数字犯罪和攻击领域的一门学科，包括获取和分析数字信息（作为民事、刑事或行政案件的证据） 联邦调查局计算机分析和响应小组(CART)：成立于 1984 年，负责处理越来越多的涉及数字证据的案件 数字取证主要是对电子证据识别、保存、收集、分析和呈堂，从而揭示与数字产品相关的犯罪行为或过失 公司调查：即让私营公司和律师参与解决公司政策违规和诉讼纠纷。 填空 计算机取证相关学科：计算机取证（调查可以从计算机硬盘或其他存储介质中检索到的数据）、网络取证（产生关于犯罪者或攻击者如何获得网络访问权的信息）、数据恢复（恢复被错误删除的信息，通常你知道你在寻找什么）、灾难恢复（使用计算机取证技术来检索客户丢失的信息）、企业网络环境（大型企业计算系统，可能包括不同的或以前独立的系统）、脆弱性评估和风险管理（测试和验证独立工作站和网络服务器的完整性）、诉讼（在法庭上证明有罪或无罪的法律程序） 计算机调查的两个不同类别：公共调查 和 个人或公司调查 公共调查：①让负责刑事调查和起诉的政府机构参与进来②组织必须遵守法律准则 个人或公司调查：①与私营公司、非执法政府机构和律师打交道 ②不受刑法或第四修正案的直接管辖③由定义员工在工作场所的预期行为的内部政策管理 刑事案件遵循的三个阶段：指控、调查、起诉 公司计算机犯罪可能涉及: 电子邮件骚扰、伪造数据、性别和年龄歧视贪污、蓄意破坏、工业间谍 简答 如何开发计算机取证资源？答：你必须知道一个以上的计算平台，如 DOS、Windows_9x、Linux和当前的 Windows 平台；加入尽可能多的计算机用户组:计算机技术调查者网络(CTIN)（每月开会讨论执法部门和公司面临的问题）、高科技犯罪调查协会(HTCIA)：交流有关计算机调查和安全技术的信息；建立计算机取证专家和其他专业人士的网络 执法机构的调查：在刑事案件中，嫌疑人因刑事犯罪而受审，计算机和网络只是可以用来犯罪的工具。刑事案件遵循三个阶段：投诉、调查和起诉， 当有人发现违法行为的证据时，刑事案件就开始了，投诉人提出指控、控告或对事实的推测 ；一名警官采访投诉人，并写一份关于犯罪的报告；调查人员委派、收集和处理与投诉相关的信息；在立案后，这些信息会被移交给检察官；法官必须批准并签署搜查令才能用它来收集证据。 制定公司政策避免犯罪：①避免诉讼的一个方法是公布和维护员工易于阅读和遵守的政策 ②公布的公司政策提供了一系列的权力 （企业可以进行内部调查），有明确的政策授权计算机调查员和取证人员进行调查。③显示警告标识，通常在计算机接入或连接到公司内部网、网络或虚拟专用网络时出现，用来告知最终用户组织保留随意检查计算机系统和网络流量的权利。 公司调查内容：指定授权申请人（授权申请人有权调查），政策应该由执行管理层来定义，应该有直接权力要求计算机调查的团体（企业安全调查、企业道德办公室 等）；在进行安全调查时，要区分情况的类型：滥用或误用公司资产 、互联网滥用等；一定要区分公司的滥用问题和潜在的犯罪问题 保持职业操守：职业操守决定了你的可信度，包括伦理、道德和行为标准。保持客观性意味着你必须形成和对你的案例保持公正的观点。保持职业操守可以保持调查的可信度。方法包括：①通过继续培训提高你的职业操守②在日记中记录你的事实调查方法③参加研讨会、会议和供应商课程 ④专业组织的会员资格会增加你的资历⑤获得较高的公共和私人地位，保持诚实和正直。 解释如何准备计算机调查：首先评估案例，按照公认的程序准备案件，然后收集证据(调查嫌疑人的计算机证据应打包并贴上标签、将证据保存在另一台计算机上），最后记录证据链或监管链。 用系统的方法进行调查：步骤：首先对正在调查的案件类型进行初步评估，然后确定案例的初步设计或方法 创建详细的清单，确定需要的资源，最后获取并复制一个证据磁盘驱动器 描述公司高科技的程序调查：首先要制定格式程序和非正式清单，涵盖高科技调查的所有重要问题，程序是必要的，以确保使用正确的技术，清单是必要的，以确保所有的证据正确收集和处理 解释数据恢复工作站和软件的要求：基本要求包括运行Windows XP或Vista的工作站、写阻止器设备、计算机取证采集工具、计算机取证分析工具、接收源或可疑磁盘数据的目标驱动器、备用 PATA 或 SATA 端口、USB端口、附加有用项目的网络接口如网络接口卡（NIC）、额外USB端口、SCSI 卡等。 描述如何进行调查：收集调查计划中确定的资源、所需项目 （原始存储介质证据保管表、存储介质的证据容器等）、然后收集证据（步骤：①与IT经理会面以采访他②填写证据表格，让 IT 经理签字，将证据放在安全的容器中③填写证据保管表格④把证据带到计算机取证实验室⑤创建取证副本⑥通过锁定容器来保护证据） 解释如何完成和评论案例：完成案例：陈述你做了什么和你发现了什么，包括 ProDiscover 报告以记录您的工作，可重复的发现（重复这些步骤，产生同样的结果），如果需要，使用报告模板，报告应显示嫌疑人是否犯了罪或违反了公司政 策的确凿证据。评论案例：问自己以下问题:在这种情况下，你如何提高自己的表现？ 你期待你发现的结果吗？案件的发展是否出乎你的意料？文档是否尽可能的全面？ 从请求来源收到了什么反馈？有没有发现什么新问题？如果有，它们是什么？你在办案或研究过程中使用了新技术吗？ 描述计算机取证实验室的认证要求：包括国际计算机调查专家协会认证的册电子证据收集专家和法医计算机检验员；高科技犯罪网络认证的注册计算机犯罪调查员、计算机取证认证技术员；EnCase 认证检验员(EnCE)认证；AccessData 认证考官(ACE)认证。 列出计算机取证实验室的物理要求：实验室设施必须是物理安全的，这样证据才不会丢失、损坏或销毁。安全设施应该保持证据数据的完整性，最低要求：小房间有落地墙，门有带锁机制的安全、有安全容器、访客日志；高风险调查应有电磁环境安全防护的设备：如防电磁辐射（EMR），也可使用低辐射工作站代替；使用证据柜保存证据，证据柜应有钢制成，需要放到有监控的地方且带有密码系统，最好建立一个证据储藏室保存证据。 解释选择基本取证工作站的标准：取决于预算和需求，使用功能较弱的工作站处理日常任务，使用多用途工作站完成高端分析任务。对于警察实验室一般一个地区每 25 万人中有一名电脑调查员，一个多用途法医工作站和一个通用工作站。对于个人和公司实验室需求很容易确定，确定当前的硬件平台和操作系统，然后收集在指定环境下工作的工具。 描述用于构建开发取证实验室的商业案例的组件：包括正当理由、预算编制（包括设施成本、计算机硬件要求、软件要求、杂项费用）、批准和收购、实施。 校园网安全解决方案设计概况需求分析方案设计","categories":[],"tags":[{"name":"数字取证技术","slug":"数字取证技术","permalink":"https://brillianttt.gitee.io/tags/%E6%95%B0%E5%AD%97%E5%8F%96%E8%AF%81%E6%8A%80%E6%9C%AF/"}]},{"title":"SpringMVC学习","slug":"SpringMVC学习","date":"2022-05-01T04:35:47.000Z","updated":"2022-07-02T02:18:59.344Z","comments":true,"path":"2022/05/01/SpringMVC学习/","link":"","permalink":"https://brillianttt.gitee.io/2022/05/01/SpringMVC%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"MVC设计模式MVC 设计模式一般指 MVC 框架，M（Model）指数据模型层，V（View）指视图层，C（Controller）指控制层。使用 MVC 的目的是将 M 和 V 的实现代码分离，使同一个程序可以有不同的表现形式。其中，View 的定义比较清晰，就是用户界面。 在 Web 项目的开发中，能够及时、正确地响应用户的请求是非常重要的。用户在网页上单击一个 URL 路径，这对 Web 服务器来说，相当于用户发送了一个请求。而获取请求后如何解析用户的输入，并执行相关处理逻辑，最终跳转至正确的页面显示反馈结果，这些工作往往是控制层（Controller）来完成的。 在请求的过程中，用户的信息被封装在 User 实体类中，该实体类在 Web 项目中属于数据模型层（Model）。 在请求显示阶段，跳转的结果网页就属于视图层（View）。 像这样，控制层负责前台与后台的交互，数据模型层封装用户的输入/输出数据，视图层选择恰当的视图来显示最终的执行结果，这样的层次分明的软件开发和处理流程被称为 MVC 模式。 在学习 Servlet 及 JSP 开发时，JavaBean 相当于 Model，Servlet 相当于 Controller，JSP 相当于 View。 总结如下： 视图层（View）：负责格式化数据并把它们呈现给用户，包括数据展示、用户交互、数据验证、界面设计等功能。 控制层（Controller）：负责接收并转发请求，对请求进行处理后，指定视图并将响应结果发送给客户端。 数据模型层（Model）：模型对象拥有最多的处理任务，是应用程序的主体部分，它负责数据逻辑（业务规则）的处理和实现数据操作（即在数据库中存取数据）。 SUN 公司推出 JSP 技术的同时，也推出了两种 Web 应用程序的开发模式。即 JSP+JavaBean 和 Servlet+JSP+JavaBean。 SpringMVC是什么Spring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，本质上相当于 Servlet。 Spring MVC 是结构最清晰的 Servlet+JSP+JavaBean 的实现，是一个典型的教科书式的 MVC 构架，不像 Struts 等其它框架都是变种或者不是完全基于 MVC 系统的框架。 Spring MVC 角色划分清晰，分工明细，并且和 Spring 框架无缝结合。Spring MVC 是当今业界最主流的 Web 开发框架，以及最热门的开发技能。 在 Spring MVC 框架中，Controller 替换 Servlet 来担负控制器的职责，用于接收请求，调用相应的 Model 进行处理，处理器完成业务处理后返回处理结果。Controller 调用相应的 View 并对处理结果进行视图渲染，最终客户端得到响应信息。 Spring MVC 框架采用松耦合可插拔的组件结构，具有高度可配置性，比起其它 MVC 框架更具有扩展性和灵活性。 此外，Spring MVC 的注解驱动和对 REST 风格的支持，也是它最具特色的功能。无论是在框架设计，还是扩展性、灵活性等方面都全面超越了 Struts2 等 MVC 框架。并且由于 Spring MVC 本身就是 Spring 框架的一部分，所以可以说与 Spring 框架是无缝集成，性能方面具有先天的优越性，对于开发者来说，开发效率也高于其它的 Web 框架，在企业中的应用越来越广泛，成为主流的 MVC 框架。 清晰地角色划分，Spring MVC 在 Model、View 和 Controller 方面提供了一个非常清晰的角色划分，这 3 个方面真正是各司其职，各负其责。 灵活的配置功能，可以把类当作 Bean 通过 XML 进行配置。 提供了大量的控制器接口和实现类，开发者可以使用 Spring 提供的控制器实现类，也可以自己实现控制器接口。 真正做到与 View 层的实现无关。它不会强制开发者使用 JSP，可以根据项目需求使用 Velocity、FreeMarker 等技术。 国际化支持 面向接口编程 与 Spring 框架无缝集成 第一个 SpringMVC程序要创建一个springmvc程序，首先需要在pom.xml中配置依赖 12345678910111213141516171819202122232425262728&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.49&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 接着配置 springmvc相关内容，Spring MVC 是基于 Servlet 的，DispatcherServlet 是整个 Spring MVC 框架的核心，主要负责截获请求并将其分派给相应的处理器处理。所以配置 Spring MVC，首先要定义 DispatcherServlet。跟所有 Servlet 一样，用户必须在 web.xml 中进行配置。 在开发 Spring MVC 应用时需要在 web.xml 中部署 DispatcherServlet，代码如下： 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt; &lt;display-name&gt;springMVC&lt;/display-name&gt; &lt;!-- 部署 DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 表示容器再启动时立即加载servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 处理所有URL --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Spring MVC 初始化时将在应用程序的 WEB-INF 目录下查找配置文件，该配置文件的命名规则是“servletName-servlet.xml”，例如 springmvc-servlet.xml。 也可以将 Spring MVC 的配置文件存放在应用程序目录中的任何地方，但需要使用 servlet 的 init-param 元素加载配置文件，通过 contextConfigLocation 参数来指定 Spring MVC 配置文件的位置，示例代码如下。 12345678910111213141516171819202122 &lt;!-- 部署 DispatcherServlet 这个是springmvc的核心：是请求分发器、前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 表示容器再启动时立即加载servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 在 springmvc中的 / 和 /* / ：只匹配所有的请求，不回去匹配jsp页面 /*：匹配所有的请求，包括jsp页面--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 此处使用 Spring 资源路径的方式进行指定，即 classpath:springmvc-servlet.xml。 上述代码配置了一个名为“springmvc”的 Servlet。该 Servlet 是 DispatcherServlet 类型，它就是 Spring MVC 的入口，并通过 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 配置标记容器在启动时就加载此 DispatcherServlet，即自动启动。然后通过 servlet-mapping 映射到“/”，即 DispatcherServlet 需要截获并处理该项目的所有 URL 请求。 使用注解开发springmvc首先在web.xml中配置springmvc和dispatcherservlet 1234567891011121314151617181920212223&lt;!-- 部署 DispatcherServlet 这个是springmvc的核心：是请求分发器、前端控制器 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- dispatcherservlet要绑定的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 表示容器再启动时立即加载servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;!-- 在 springmvc中的 / 和 /* / ：只匹配所有的请求，不回去匹配jsp页面 /*：匹配所有的请求，包括jsp页面--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 接着创建springmvc-servlet.xml添加配置信息 在上一个springmvc入门项目中的springmvc-servlet.xml如下 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;!-- 处理器映射器--&gt; &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt;&lt;!-- 处理器适配器--&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt;&lt;!-- 视图解析器--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\"&gt;&lt;!-- 前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt;&lt;!-- 后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;bean id=\"/hello\" class=\"com.ma.controller.HelloController\"/&gt;&lt;/beans&gt; 在此处省去了创建处理器映射器和处理器适配器，直接添加这部分即可 12345&lt;context:component-scan base-package=\"com.ma.controller\"/&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!--annotation-driven可以自动完成映射器和适配器两个实例的注入，让@RequestMapping注解生效--&gt;&lt;mvc:annotation-driven/&gt; 而视图解析器还留在这里，全部配置信息如下 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;&lt;!-- 自动扫描包，让指定包下的注解生效，由IOC容器统一管理--&gt; &lt;context:component-scan base-package=\"com.ma.controller\"/&gt;&lt;!-- 过滤静态资源--&gt; &lt;mvc:default-servlet-handler/&gt;&lt;!--annotation-driven可以自动完成映射器和适配器两个实例的注入，让@RequestMapping注解生效--&gt; &lt;mvc:annotation-driven/&gt;&lt;!-- 视图解析器--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\"&gt;&lt;!-- 前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt;&lt;!-- 后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 接着创建controller包和WEB-INF包下面的jsp包，添加信息如下 hellocontroller： 123456789101112131415161718192021package com.ma.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;//使用controller注解，省去了在springmvc-servlet.xml中进行配置bean,使用注解后代表这个类会被//spring接管，被z的这个类中的所有方法，若返回值为String并且有具体页面可以跳转，那么就会被视图解析器解析@Controller@RequestMapping(\"/hello\")public class HelloController &#123; @RequestMapping(\"/h1\") //这里使用两个注解，然后在访问时就可以访问http://localhost:8080/hello/h1来访问该页面 public String hello(Model model)&#123; //封装数据 model.addAttribute(\"msg\",\"hello,springmvcannotation\"); return \"hello\";//返回结果会被视图解析器处理，然后找到WEB-INF/jsp下的hello.jsp &#125;&#125; jsp下的hello.jsp就是取msg：${msg} 小结： 使用springmvc必须配置的三大件：处理器映射器、处理器适配器、视图解析器 通常我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，从而省去大段的xml配置 另外要注意配置maven时，要注意maven项目下的的project structure下的artifacts下对应的项目中，在WEB-INF项目下是否有lib目录，要是没有的话要手动添加lib包并加入library files。 @RequestMapping注解@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 @RequestMapping 注解可用于类或方法上。用于类上，表示类中的所有响应请求的方法都以该地址作为父路径。 @RequestMapping 注解常用属性如下。 1. value 属性value 属性是 @RequestMapping 注解的默认属性，因此如果只有 value 属性时，可以省略该属性名，如果有其它属性，则必须写上 value 属性名称。如下。 1@RequestMapping(value&#x3D;&quot;toUser&quot;)@RequestMapping(&quot;toUser&quot;) value 属性支持通配符匹配，如 @RequestMapping(value=”toUser/*”) 表示 http://localhost:8080/toUser/1 或 http://localhost:8080/toUser/hahaha 都能够正常访问。 2. path属性path 属性和 value 属性都用来作为映射使用。即 @RequestMapping(value=”toUser”) 和 @RequestMapping(path=”toUser”) 都能访问 toUser() 方法。 path 属性支持通配符匹配，如 @RequestMapping(path=”toUser/*”) 表示 http://localhost:8080/toUser/1 或 http://localhost:8080/toUser/hahaha 都能够正常访问。 3. name属性name属性相当于方法的注释，使方法更易理解。如 @RequestMapping(value = “toUser”,name = “获取用户信息”)。 4. method属性method 属性用于表示该方法支持哪些 HTTP 请求。如果省略 method 属性，则说明该方法支持全部的 HTTP 请求。 @RequestMapping(value = “toUser”,method = RequestMethod.GET) 表示该方法只支持 GET 请求。也可指定多个 HTTP 请求，如 @RequestMapping(value = “toUser”,method = {RequestMethod.GET,RequestMethod.POST})，说明该方法同时支持 GET 和 POST 请求。 5. params属性params 属性用于指定请求中规定的参数，代码如下。 1@RequestMapping(value &#x3D; &quot;toUser&quot;,params &#x3D; &quot;type&quot;)public String toUser() &#123; return &quot;showUser&quot;;&#125; 以上代码表示请求中必须包含 type 参数时才能执行该请求。即 http://localhost:8080/toUser?type=xxx 能够正常访问 toUser() 方法，而 http://localhost:8080/toUser 则不能正常访问 toUser() 方法。 1@RequestMapping(value &#x3D; &quot;toUser&quot;,params &#x3D; &quot;type&#x3D;1&quot;)public String toUser() &#123; return &quot;showUser&quot;;&#125; 以上代码表示请求中必须包含 type 参数，且 type 参数为 1 时才能够执行该请求。即 http://localhost:8080/toUser?type=1 能够正常访问 toUser() 方法，而 http://localhost:8080/toUser?type=2 则不能正常访问 toUser() 方法。 6. header属性header 属性表示请求中必须包含某些指定的 header 值。 @RequestMapping(value = “toUser”,headers = “Referer=http://www.xxx.com&quot;) 表示请求的 header 中必须包含了指定的“Referer”请求头，以及值为“http://www.xxx.com”时，才能执行该请求。 7. consumers属性consumers 属性用于指定处理请求的提交内容类型（Content-Type），例如：application/json、text/html。如@RequestMapping(value = “toUser”,consumes = “application/json”)。 8. produces属性produces 属性用于指定返回的内容类型，返回的内容类型必须是 request 请求头（Accept）中所包含的类型。如 @RequestMapping(value = “toUser”,produces = “application/json”)。 除此之外，produces 属性还可以指定返回值的编码。如 @RequestMapping(value = “toUser”,produces = “application/json,charset=utf-8”)，表示返回 utf-8 编码。 使用 @RequestMapping 来完成映射，具体包括 4 个方面的信息项：请求 URL、请求参数、请求方法和请求头。 RestFul风格pring REST 风格可以简单理解为：使用 URL 表示资源时，每个资源都用一个独一无二的 URL 来表示，并使用 HTTP 方法表示操作，即准确描述服务器对资源的处理动作（GET、POST、PUT、DELETE），实现资源的增删改查。 GET：表示获取资源 POST：表示新建资源 PUT：表示更新资源 DELETE：表示删除资源 下面举例说明 REST 风格的 URL 与传统 URL 的区别。 123&#x2F;userview.html?id&#x3D;12 VS &#x2F;user&#x2F;view&#x2F;12&#x2F;userdelete.html?id&#x3D;12 VS &#x2F;user&#x2F;delete&#x2F;12&#x2F;usermodify.html?id&#x3D;12 VS &#x2F;user&#x2F;modify&#x2F;12 我们发现 REST 风格的 URL 中最明显的就是参数不再使用“?”传递。这种风格的 URL 可读性更好，使得项目架构清晰，最关键的是 Spring MVC 也提供对这种风格的支持。 由于 HTTP 不支持 PUT 和 DELETE 请求，所以需要将 DELETE 和 PUT 请求转换成 POST 请求，在 web.xml 中配置过滤器 HiddenHttpMethodFilter。 123456789&lt;!-- HiddenHttpMethodFilter过滤器可以将POST请求转化为put请求和delete请求! --&gt;&lt;filter&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 新建 rest.jsp 代码如下。 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;REST风格&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;发送GET请求&lt;/h4&gt; &lt;a href=\" user/1\"&gt;GET&lt;/a&gt; &lt;h4&gt;发送POST请求&lt;/h4&gt; &lt;form action=\"user/1\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"POST\" /&gt; &lt;/form&gt; &lt;!-- 发送PUT和DELETE请求时，需要添加一个隐藏域 --&gt; &lt;h4&gt;发送PUT请求&lt;/h4&gt; &lt;form action=\" user/1\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"PUT\" /&gt; &lt;input type=\"submit\" value=\"PUT\" /&gt; &lt;/form&gt; &lt;h4&gt;发送DELETE请求&lt;/h4&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"DELETE\" /&gt; &lt;form action=\" user/1\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"DELETE\" /&gt; &lt;input type=\"submit\" value=\"DELETE\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 下面通过 @RequestMapping 映射请求中的 method 参数实现四种请求方式的调用，UserController 代码如下。 1234567891011121314151617181920212223242526272829303132package net.biancheng.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controllerpublic class UserController &#123; @RequestMapping(\"/torest\") public String torest() &#123; return \"rest\"; &#125; @RequestMapping(value = \"/user/&#123;id&#125;\", method = RequestMethod.GET) public String hello(@PathVariable Integer id) &#123; System.out.println(\"test rest get:\" + id); return \"success\"; &#125; @RequestMapping(value = \"/user/&#123;id&#125;\", method = RequestMethod.POST) public String hello() &#123; System.out.println(\"test POST:\"); return \"success\"; &#125; @RequestMapping(value = \"/user/&#123;id&#125;\", method = RequestMethod.DELETE) public String helloDelete(@PathVariable Integer id) &#123; System.out.println(\"test rest delete:\" + id); return \"success\"; &#125; @RequestMapping(value = \"/user/&#123;id&#125;\", method = RequestMethod.PUT) public String helloPUt(@PathVariable Integer id) &#123; System.out.println(\"test rest put:\" + id); return \"success\"; &#125;&#125; 自动装配@Autowired的应用首先这里有一个例子，里面用到了两个注解：@Autowired和@Controller 自动检测配置，也是springmvc中最牛的一项功能。只要一个配置&lt;context:component-scan base-package=””&gt;，b ase-package属性指定要自动检测扫描的包。 该配置会自动扫描指定的包及其子包下面被构造型注解标注的类，并将这些类注册为spring bean，这样就不用在配置文件一个一个 地配置成bean标签。构造型注解包括：@Controller，@Components，@Service，@Repository和使用@Component标注的自定义 注解。生成的bean的ID默认为类的非限定名，也就是把类的名字的首字母换成小写。可以在这些注解的值中写名bean id的 值，如@Controller(“helloworld”)。如果你想细化包被扫描的范围，可以使用context:include-filter和context:exclude-filter。具体使 用方法这里不再详说。注意，没有被扫描到的类是不能注册为bean，也就不能被用来装配其他类。所以这个配置的base-package的 范围非常重要。 springmvc传递参数Spring MVC Controller 接收请求参数的方式有很多种，有的适合 get 请求方式，有的适合 post 请求方式，有的两者都适合。主要有以下几种方式： 通过实体 Bean 接收请求参数 通过处理方法的形参接收请求参数 通过 HttpServletRequest 接收请求参数 通过 @PathVariable 接收 URL 中的请求参数 通过 @RequestParam 接收请求参数 通过 @ModelAttribute 接收请求参数 通过实体Bean接收请求参数实体 Bean 接收请求参数适用于 get 和 post 提交请求方式。需要注意，Bean 的属性名称必须与请求参数名称相同。示例代码如下。 123456789101112@RequestMapping(\"/login\")public String login(User user, Model model) &#123; if (\"bianchengbang\".equals(user.getName()) &amp;&amp; \"123456\".equals(user.getPwd())) &#123; model.addAttribute(\"message\", \"登录成功\"); return \"main\"; // 登录成功，跳转到 main.jsp &#125; else &#123; model.addAttribute(\"message\", \"用户名或密码错误\"); return \"login\"; &#125;&#125; 通过处理方法的形参接收请求参数通过处理方法的形参接收请求参数就是直接把表单参数写在控制器类相应方法的形参中，即形参名称与请求参数名称完全相同。该接收参数方式适用于 get 和 post 提交请求方式。示例代码如下： 123456789101112@RequestMapping(\"/login\")public String login(String name, String pwd, Model model) &#123; if (\"bianchengbang\".equals(user.getName()) &amp;&amp; \"123456\".equals(user.getPwd())) &#123; model.addAttribute(\"message\", \"登录成功\"); return \"main\"; // 登录成功，跳转到 main.jsp &#125; else &#123; model.addAttribute(\"message\", \"用户名或密码错误\"); return \"login\"; &#125;&#125; 通过HttpServletRequest接收请求参数通过 HttpServletRequest 接收请求参数适用于 get 和 post 提交请求方式，示例代码如下： 123456789101112131415@RequestMapping(\"/login\")public String login(HttpServletRequest request, Model model) &#123; String name = request.getParameter(\"name\"); String pwd = request.getParameter(\"pwd\"); if (\"bianchengbang\".equals(name) &amp;&amp; \"123456\".equals(pwd)) &#123; model.addAttribute(\"message\", \"登录成功\"); return \"main\"; // 登录成功，跳转到 main.jsp &#125; else &#123; model.addAttribute(\"message\", \"用户名或密码错误\"); return \"login\"; &#125;&#125; 通过@PathVariable接收URL中的请求参数通过 @PathVariable 获取 URL 中的参数，示例代码如下。 在访问“http://localhost:8080/springMVCDemo02/user/register/bianchengbang/123456”路径时，上述代码会自动将 URL 中的模板变量 {name} 和 {pwd} 绑定到通过 @PathVariable 注解的同名参数上，即 name=bianchengbang、pwd=123456。 12345678910111213@RequestMapping(\"/login/&#123;name&#125;/&#123;pwd&#125;\")public String login(@PathVariable String name, @PathVariable String pwd, Model model) &#123; if (\"bianchengbang\".equals(name) &amp;&amp; \"123456\".equals(pwd)) &#123; model.addAttribute(\"message\", \"登录成功\"); return \"main\"; // 登录成功，跳转到 main.jsp &#125; else &#123; model.addAttribute(\"message\", \"用户名或密码错误\"); return \"login\"; &#125;&#125; 通过@RequestParam接收请求参数在方法入参处使用 @RequestParam 注解指定其对应的请求参数。@RequestParam 有以下三个参数： value：参数名 required：是否必须，默认为 true，表示请求中必须包含对应的参数名，若不存在将抛出异常 defaultValue：参数默认值 通过 @RequestParam 接收请求参数适用于 get 和 post 提交请求方式，示例代码如下。 12345678910111213@RequestMapping(\"/login\")public String login(@RequestParam String name, @RequestParam String pwd, Model model) &#123; if (\"bianchengbang\".equals(name) &amp;&amp; \"123456\".equals(pwd)) &#123; model.addAttribute(\"message\", \"登录成功\"); return \"main\"; // 登录成功，跳转到 main.jsp &#125; else &#123; model.addAttribute(\"message\", \"用户名或密码错误\"); return \"login\"; &#125;&#125; 若遇到参数名称和实体类的属性名不一致的情况，如pwd字段不匹配（实体类为pwd，本方法中为Pwd），需要在@RequestParam后添加参数@RequestParam(“pwd”) String Pwd，使用这种方法进行匹配。 通过@ModelAttribute接收请求参数@ModelAttribute 注解用于将多个请求参数封装到一个实体对象中，从而简化数据绑定流程，而且自动暴露为模型数据，在视图页面展示时使用。 而“通过实体 Bean 接收请求参数”中只是将多个请求参数封装到一个实体对象，并不能暴露为模型数据（需要使用 model.addAttribute 语句才能暴露为模型数据，数据绑定与模型数据展示后面教程中会讲解）。 通过 @ModelAttribute 注解接收请求参数适用于 get 和 post 提交请求方式，示例代码如下。 12345678910111213@RequestMapping(\"/login\")public String login(@ModelAttribute(\"user\") User user, Model model) &#123; if (\"bianchengbang\".equals(name) &amp;&amp; \"123456\".equals(pwd)) &#123; model.addAttribute(\"message\", \"登录成功\"); return \"main\"; // 登录成功，跳转到 main.jsp &#125; else &#123; model.addAttribute(\"message\", \"用户名或密码错误\"); return \"login\"; &#125;&#125; 数据的回显 Model只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解; ModelMap继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承了 linkedMap的方法和特性; ModelAndview 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 SpringMVC整合Mybatis环境要求：IDEA、MySQL5.1、Tomcat 9、Maven3.6 1、创建数据库1234567891011121314CREATE DATABASE ssmbuild;USE ssmbuild;CREATE TABLE &#96;books&#96;(&#96;bookID&#96; INT NOT NULL AUTO_INCREMENT COMMENT &#39;书id&#39;,&#96;bookName&#96; VARCHAR(100) NOT NULL COMMENT &#39;书名&#39;,&#96;bookCounts&#96; INT NOT NULL COMMENT &#39;数量&#39;,&#96;detail&#96; VARCHAR(200) NOT NULL COMMENT &#39;描述&#39;,KEY &#96;bookID&#96;(&#96;bookID&#96;))ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8;INSERT INTO &#96;books&#96;(&#96;bookID&#96;,&#96;bookName&#96;,&#96;bookCounts&#96;,&#96;detail&#96;)VALUES(1,&#39;Java&#39;,1,&#39;从入门到放弃&#39;),(2,&#39;MySQL&#39;,10,&#39;从删库到跑路&#39;),(3,&#39;Linux&#39;,5,&#39;从进门到进牢&#39;) 然后在IDEA上链接数据库ssmbuild。 2、导入依赖1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!-- 依赖：junit，数据库驱动，连接池，servlet，jsp，mybatis，mybatis，mybatis-spring，spring--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;!-- 数据库--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt;&lt;!-- 数据库连接池：c3p0--&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.4&lt;/version&gt; &lt;/dependency&gt;&lt;!-- JSP--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;!-- mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.9&lt;/version&gt; &lt;/dependency&gt;&lt;!-- spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.19&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;!-- 静态资源导出--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 3、设置项目目录，添加资源文件目录如下图所示： resources下配置资源文件： 1、mybatis-config.xml: 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;&lt;!-- 配置 --&gt;&lt;!-- &lt;properties /&gt;&amp;lt;!&amp;ndash; 属性 &amp;ndash;&amp;gt;--&gt;&lt;!-- &lt;settings/&gt;&amp;lt;!&amp;ndash; 设置 &amp;ndash;&amp;gt;--&gt;&lt;!-- &lt;typeAliases /&gt;&amp;lt;!&amp;ndash; 类型命名 &amp;ndash;&amp;gt;--&gt;&lt;!-- &lt;typeHandlers /&gt;&amp;lt;!&amp;ndash; 类型处理器 &amp;ndash;&amp;gt;--&gt;&lt;!-- &lt;objectFactory /&gt;&amp;lt;!&amp;ndash; 对象工厂 &amp;ndash;&amp;gt;--&gt;&lt;!-- &lt;plugins /&gt;&amp;lt;!&amp;ndash; 插件 &amp;ndash;&amp;gt;--&gt;&lt;!-- &lt;environments&gt;&amp;lt;!&amp;ndash; 配置环境 &amp;ndash;&amp;gt;--&gt;&lt;!-- &lt;environment&gt;&amp;lt;!&amp;ndash; 环境变量 &amp;ndash;&amp;gt;--&gt;&lt;!-- &lt;transactionManager /&gt;&amp;lt;!&amp;ndash; 事务管理器 &amp;ndash;&amp;gt;--&gt;&lt;!-- &lt;dataSource /&gt;&amp;lt;!&amp;ndash; 数据源 &amp;ndash;&amp;gt;--&gt;&lt;!-- &lt;/environment&gt;--&gt;&lt;!-- &lt;/environments&gt;--&gt;&lt;!-- &lt;databaseIdProvider /&gt;&amp;lt;!&amp;ndash; 数据库厂商标识 &amp;ndash;&amp;gt;--&gt;&lt;!-- &lt;mappers /&gt;&amp;lt;!&amp;ndash; 映射器 &amp;ndash;&amp;gt;--&gt;&lt;/configuration&gt; 2、applicationContext.xml: 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt;&lt;/beans&gt; 3、database.properties: 1234jdbc.driver &#x3D; com.mysql.jdbc.Driverjdbc.url &#x3D; jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useSSL&#x3D;false&amp;userUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8jdbc.username &#x3D;rootjdbc.password &#x3D;Mby12345@ 如果使用的是mysql8.0+，需要设置数据库管理系统的时区，避免报错 4、创建实体类Books首先新建包com.ma.pojo，然后在pojo包下面创建实体类Books，其中的变量名要和数据库的各字段名一致，或采用驼峰命名法，然后开启映射。 12345678910111213141516package com.ma.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;//采用lombok下的包@Data注解添加get和set方法，以及@All和@No分别添加有参和无参构造函数@Data@AllArgsConstructor@NoArgsConstructorpublic class Books &#123; private int bookID; private String bookName; private int bookCounts; private String detail;&#125; 5、创建MVC中的Model（模型）Model中包含Dao层和Service层，首先从Dao层开始，先创建接口BookMapper BookMapper12345678910111213141516171819202122232425package com.ma.dao;import com.ma.pojo.Books;import org.apache.ibatis.annotations.Param;import java.util.List;public interface BookMapper &#123; //增加一本书 int addBook(Books books); //删除一本书 int deleteBook(@Param(\"bookId\") int id);//id的别名 //更新一本书 int updateBook(Books books); //查询一本书 BooksqueryBookById(int id); //查询所有书 List&lt;Books&gt; queryAllBook();&#125; 接着创建BookMapper.xml映射文件 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ma.dao.BookMapper\"&gt;&lt;!-- 配置 --&gt; &lt;insert id=\"addBook\" parameterType=\"Books\"&gt; insert into ssmbuild.books(bookName,bookCounts,detail) values (#&#123;bookName&#125;,#&#123;bookCounts&#125;,#&#123;detail&#125;); &lt;/insert&gt; &lt;delete id=\"deleteBookById\" parameterType=\"Books\"&gt; delete from ssmbuild.books where bookID=#&#123;bookID&#125; &lt;/delete&gt; &lt;update id=\"updateBook\" parameterType=\"Books\"&gt; update ssmbuild.books set bookName=#&#123;bookName&#125;, bookCounts=#&#123;bookCounts&#125;,detail = #&#123;detail&#125; where bookID=#&#123;bookID&#125;; &lt;/update&gt;&lt;-- 注意在查询时一定要有返回值的类型resultType --&gt; &lt;select id=\"queryBookById\" resultType=\"Books\"&gt; select * from ssmbuild.books where bookid=#&#123;bookId&#125; &lt;/select&gt; &lt;select id=\"queryAllBook\" resultType=\"Books\"&gt; select * from ssmbuild.books &lt;/select&gt; &lt;/mapper&gt; 然后在mybatis的配置文件mybatis-config.xml中注册mapper,另外也要注意mappers的位置，在这里配一个配置信息的参数都是有固定位置的，mappers位于配置的最后一项 123&lt;mappers&gt; &lt;mapper resource=\"com/ma/dao/BookMapper.xml\"/&gt;&lt;/mappers&gt; Service接着创建Service层，包含接口和实现类 BookService.java: 1234567891011121314151617181920212223package com.ma.service;import com.ma.pojo.Books;import java.util.List;public interface BookService &#123; //增加一本书 int addBook(Books books); //删除一本书 int deleteBook(int id); //更新一本书 int updateBook(Books books); //查询一本书 int queryBookById(int id); //查询所有书 List&lt;Books&gt; queryAllBook();&#125; BookServiceImpl.java: 123456789101112131415161718192021222324252627282930313233343536package com.ma.service;import com.ma.dao.BookMapper;import com.ma.pojo.Books;import java.util.List;public class BookServiceImpl implements BookService &#123; //service调用dao层，组合dao private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper)&#123; this.bookMapper=bookMapper; &#125; public int addBook(Books books) &#123; return bookMapper.addBook(books); &#125; public int deleteBook(int id) &#123; return bookMapper.deleteBook(id); &#125; public int updateBook(Books books) &#123; return bookMapper.updateBook(books); &#125; public int queryBookById(int id) &#123; return bookMapper.queryBookById(id); &#125; public List&lt;Books&gt; queryAllBook() &#123; return bookMapper.queryAllBook(); &#125;&#125; SpringMVC整合Spring首先在resources下创建spring的配置文件spring-dao.xml Ajax什么是Ajax AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML） AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术 Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术 在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来，Google Suggest能够自动帮你完成搜索单词 Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表 传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页 使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新 使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面 Ajax可以做什么 注册时，输入用户名自动检测用户是否已经存在 登陆时，提示用户名密码错误 删除数据行时，将ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除 具体内容暂时不进行记录，在学习完js后再重新学习ajax。 拦截器spring的处理器拦截器类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理，开发者可以自己定义一些拦截器来实现特定的功能过滤器与拦截器的区别：拦截器是AOP思想的具体应用(即拦截器的实现原理就是aop横切增强，不会修改源码) 过滤器： servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器： 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问控制器的方法的请求， 如果访问的是jsp/html/css/image/js这些静态资源，是不会进行拦截的(这一点就比过滤器好，因为过滤器不管请求什么，它都会过滤一遍，比较占用资源和时间) 拦截器的具体配置过程如下： 新建一个子model：SpringMVC-07-Interceptor，并将其改为WEB项目 配置web.xml中的DispatcherServlet、CharacterEncodingFilter和session 配置spring容器中的注解驱动、过滤静态资源、扫描包和视图解析器 创建视图解析器对应的jsp文件夹 创建一个controller测试环境是否搭建成功 接着编写测试类 1234567891011121314package com.ma.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class TestController &#123; @GetMapping(\"/t1\") public String test()&#123; System.out.println(\"test执行了\"); return \"OK\"; &#125;&#125; 测试连接请求，发现可以正常返回。 接着编写拦截器MyInterceptor.java 12345678910111213141516171819202122package com.ma.config;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;public class MyInterceptor implements HandlerInterceptor &#123; public boolean preHandle(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"处理前\"); return true;//返回true放行，返回false不放行，根据具体内容执行操作 &#125; //一般用于写拦截日志 public void postHandle(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"处理后\"); &#125; public void afterCompletion(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"清理\"); &#125;&#125; 接着在springmvc的核心配置文件applicationContext.xml文件中配置拦截器 1234567 &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt;&lt;!-- /**表示包括这个请求下面的所有的请求--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.ma.config.MyInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 然后就可以实现拦截器了 登陆验证实例基本配置同上，首先编写前端页面 index.jsp 123456789101112&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;user/goLogin\"&gt;登陆页面&lt;/a&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;user/main\"&gt;首页&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; login.jsp 1234567891011121314151617&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--在web-inf下面所有页面或资源，都只能通过controller或者servlet进行访问--%&gt;&lt;h1&gt;登陆页面&lt;/h1&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/user/login\" method=\"post\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"/&gt; 密码：&lt;input type=\"text\" name=\"password\"/&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; main.jsp 1234567891011&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 然后编写拦截器类 123456789101112131415161718192021222324252627282930package com.ma.config;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class LoginInterceptor implements HandlerInterceptor &#123; public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; HttpSession session = request.getSession(); //登陆页面放行 if(request.getRequestURI().contains(\"goLogin\"))&#123; return true; &#125; if(request.getRequestURI().contains(\"login\"))&#123; return true; &#125; if(session.getAttribute(\"userLoginInfo\")!=null)&#123; return true; &#125; //判断什么情况下未登录 request.getRequestDispatcher(\"/WEB-INF/jsp/login.jsp\").forward(request,response); return false; &#125;&#125; request.getRequestURL()和request.getRequestURI()的区别补充知识：request.getRequestURL()和request.getRequestURI()的区别_kaikaixinxiyiwannian的博客-CSDN博客_request.getrequesturi() 控制器： 12345678910111213141516171819202122232425262728293031package com.ma.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpSession;@Controller@RequestMapping(\"/user\")public class LoginController &#123; @RequestMapping(\"/main\") public String main()&#123; return \"main\"; &#125; @RequestMapping(\"/goLogin\") public String goLogin()&#123; return \"login\"; &#125; @RequestMapping(\"/login\") public String login(HttpSession session, String username, String password)&#123; //将用户的信息存在session中 session.setAttribute(\"userLoginInfo\",username); return \"main\"; &#125; &#125; springmvc核心配置文件修改为： 1234567 &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt;&lt;!-- /**表示包括这个请求下面的所有的请求 现在更改为/user下的所有请求--&gt; &lt;mvc:mapping path=\"/user/**\"/&gt; &lt;bean class=\"com.ma.config.LoginInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brillianttt.gitee.io/tags/SpringMVC/"},{"name":"ssm","slug":"ssm","permalink":"https://brillianttt.gitee.io/tags/ssm/"}]},{"title":"排序算法的复杂度","slug":"排序算法的复杂度","date":"2022-04-30T04:26:10.000Z","updated":"2022-04-30T04:26:46.976Z","comments":true,"path":"2022/04/30/排序算法的复杂度/","link":"","permalink":"https://brillianttt.gitee.io/2022/04/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"","text":"","categories":[],"tags":[{"name":"排序","slug":"排序","permalink":"https://brillianttt.gitee.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"复杂度","slug":"复杂度","permalink":"https://brillianttt.gitee.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6/"}]},{"title":"MySQL学习","slug":"MySQL学习","date":"2022-04-16T02:12:44.000Z","updated":"2022-06-21T04:33:09.040Z","comments":true,"path":"2022/04/16/MySQL学习/","link":"","permalink":"https://brillianttt.gitee.io/2022/04/16/MySQL%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"mysql基本操作创建数据库：1CREATE DATABASE 数据库名; 删除数据库：1drop database 数据库名; 选择数据库：1use 数据库名; 数据类型数值类型：MySQL 支持所有标准 SQL 数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL 和 NUMERIC)，以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持 MyISAM、MEMORY、InnoDB 和 BDB表。 作为 SQL 标准的扩展，MySQL 也支持整数类型 TINYINT、MEDIUMINT 和 BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 Bytes (-128，127) (0，255) 小整数值 SMALLINT 2 Bytes (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 Bytes (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 Bytes (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 Bytes (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 Bytes (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 Bytes (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 日期类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型 大小 ( bytes) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小 用途 CHAR 0-255 bytes 定长字符串 VARCHAR 0-65535 bytes 变长字符串 TINYBLOB 0-255 bytes 不超过 255 个字符的二进制字符串 TINYTEXT 0-255 bytes 短文本字符串 BLOB 0-65 535 bytes 二进制形式的长文本数据 TEXT 0-65 535 bytes 长文本数据 MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 bytes 极大文本数据 注意：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 建表和删除表建表： 1234567CREATE TABLE IF NOT EXISTS &#96;runoob_tbl&#96;( &#96;runoob_id&#96; INT UNSIGNED AUTO_INCREMENT, &#96;runoob_title&#96; VARCHAR(100) NOT NULL, &#96;runoob_author&#96; VARCHAR(40) NOT NULL, &#96;submission_date&#96; DATE, PRIMARY KEY ( &#96;runoob_id&#96; ))ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8; 如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL， 在操作数据库时如果输入该字段的数据为NULL ，就会报错。 AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。 PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。 ENGINE 设置存储引擎，CHARSET 设置编码 删除表： 1DROP TABLE runoob_tbl; CURD创建（Create） 、 更新（Update） 、 读取（Read） 和 删除（Delete） 插入数据（Create）： 123INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); 如果数据是字符型，必须使用单引号或者双引号，如：”value”。 查找数据（Read） ： 1234SELECT column_name,column_nameFROM table_name[WHERE Clause][LIMIT N][ OFFSET M] 查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。 SELECT 命令可以读取一条或者多条记录。 你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据 你可以使用 WHERE 语句来包含任何条件。 你可以使用 LIMIT 属性来设定返回的记录数。 你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。 删除数据（Delete）： 1DELETE FROM table_name [WHERE Clause] 如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。 你可以在 WHERE 子句中指定任何条件 您可以在单个表中一次性删除记录。 修改数据更新（Update）： 123UPDATE table_name SET field1&#x3D;new-value1, field2&#x3D;new-value2[WHERE Clause] 你可以同时更新一个或多个字段。 你可以在 WHERE 子句中指定任何条件。 你可以在一个单独表中同时更新数据。 where子句123SELECT field1, field2,...fieldN FROM table_name1, table_name2...[WHERE condition1 [AND [OR]] condition2..... 查询语句中你可以使用一个或者多个表，表之间使用逗号, 分割，并使用WHERE语句来设定查询条件。 你可以在 WHERE 子句中指定任何条件。 你可以使用 AND 或者 OR 指定一个或多个条件。 WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。 WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。 以下为操作符列表，可用于 WHERE 子句中。 下表中实例假定 A 为 10, B 为 20 操作符 描述 实例 = 等号，检测两个值是否相等，如果相等返回true (A = B) 返回false。 &lt;&gt;, != 不等于，检测两个值是否相等，如果不相等返回true (A != B) 返回 true。 &gt; 大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true (A &gt; B) 返回false。 &lt; 小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true (A &lt; B) 返回 true。 &gt;= 大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true (A &gt;= B) 返回false。 &lt;= 小于等于号，检测左边的值是否小于或等于右边的值, 如果左边的值小于或等于右边的值返回true (A &lt;= B) 返回 true。 如果我们想在 MySQL 数据表中读取指定的数据，WHERE 子句是非常有用的。 使用主键来作为 WHERE 子句的条件查询是非常快速的。 如果给定的条件在表中没有任何匹配的记录，那么查询不会返回任何数据。 like子句（模糊查询）我们知道在 MySQL 中使用 SQL SELECT 命令来读取数据， 同时我们可以在 SELECT 语句中使用 WHERE 子句来获取指定的记录。 WHERE 子句中可以使用等号 = 来设定获取数据的条件，如 “runoob_author = ‘RUNOOB.COM’”。 但是有时候我们需要获取 runoob_author 字段含有 “COM” 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。 SQL LIKE 子句中使用百分号 %字符来表示任意字符，类似于UNIX或正则表达式中的星号 *****。 如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的。 以下是 SQL SELECT 语句使用 LIKE 子句从数据表中读取数据的通用语法： 123SELECT field1, field2,...fieldN FROM table_nameWHERE field1 LIKE condition1 [AND [OR]] filed2 &#x3D; &#39;somevalue&#39; 你可以在 WHERE 子句中指定任何条件。 你可以在 WHERE 子句中使用LIKE子句。 你可以使用LIKE子句代替等号 =。 LIKE 通常与 % 一同使用，类似于一个元字符的搜索。 你可以使用 AND 或者 OR 指定一个或多个条件。 你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件。 UNION操作符MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。 1234567SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]; expression1, expression2, … expression_n: 要检索的列。 tables: 要检索的数据表。 WHERE conditions: 可选， 检索条件。 DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。 ALL: 可选，返回所有结果集，包含重复数据。 MySQL排序（ORDER BY）使用ORDER BY子句来设定按哪个总段的哪种方式来进行排序 12SELECT field1, field2,...fieldN FROM table_name1, table_name2...ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]] 你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。 你可以设定多个字段来排序。 你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。 你可以添加 WHERE…LIKE 子句来设置条件。 GROUP BY 语句GROUP BY 语句根据一个或多个列对结果集进行分组。 在分组的列上我们可以使用 COUNT, SUM, AVG,等函数（替代样例中的function）。 1234SELECT column_name, function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name; 分组新建表 1234567891011121314151617181920212223SET NAMES utf8;SET FOREIGN_KEY_CHECKS &#x3D; 0;-- ------------------------------ Table structure for &#96;employee_tbl&#96;-- ----------------------------DROP TABLE IF EXISTS &#96;employee_tbl&#96;;CREATE TABLE &#96;employee_tbl&#96; ( &#96;id&#96; int(11) NOT NULL, &#96;name&#96; char(10) NOT NULL DEFAULT &#39;&#39;, &#96;date&#96; datetime NOT NULL, &#96;signin&#96; tinyint(4) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;登录次数&#39;, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;-- ------------------------------ Records of &#96;employee_tbl&#96;-- ----------------------------BEGIN;INSERT INTO &#96;employee_tbl&#96; VALUES (&#39;1&#39;, &#39;小明&#39;, &#39;2016-04-22 15:25:33&#39;, &#39;1&#39;), (&#39;2&#39;, &#39;小王&#39;, &#39;2016-04-20 15:25:47&#39;, &#39;3&#39;), (&#39;3&#39;, &#39;小丽&#39;, &#39;2016-04-19 15:26:02&#39;, &#39;2&#39;), (&#39;4&#39;, &#39;小王&#39;, &#39;2016-04-07 15:26:14&#39;, &#39;4&#39;), (&#39;5&#39;, &#39;小明&#39;, &#39;2016-04-11 15:26:40&#39;, &#39;4&#39;), (&#39;6&#39;, &#39;小明&#39;, &#39;2016-04-04 15:26:54&#39;, &#39;2&#39;);COMMIT;SET FOREIGN_KEY_CHECKS &#x3D; 1; 按人名分组：SELECT name, COUNT(*) FROM employee_tbl GROUP BY name; 使用 WITH ROLLUP：WITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。例如我们将以上的数据表按名字进行分组，再统计每个人登录的次数： 1SELECT name, SUM(signin) as signin_count FROM employee_tbl GROUP BY name WITH ROLLUP; 给NULL值一个名称,可以使用coalesce 语法： 1SELECT coalesce(name, &#39;总数&#39;), SUM(signin) as signin_count FROM employee_tbl GROUP BY name WITH ROLLUP; 表的连接JOIN 按照功能大致分为如下三类： INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。 LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。 RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。 NULL值的处理 MySQL 使用 SQL SELECT 命令及 WHERE 子句来读取数据表中的数据,但是当提供的查询条件字段为 NULL 时，该命令可能就无法正常工作。 为了处理这种情况，MySQL提供了三大运算符: IS NULL: 当列的值是 NULL,此运算符返回 true。 IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。 &lt;=&gt;: 比较操作符（不同于 = 运算符），当比较的的两个值相等或者都为 NULL 时返回 true。 关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。 在 MySQL 中，NULL 值与任何其它值的比较（即使是 NULL）永远返回 NULL，即 NULL = NULL 返回 NULL 。 MySQL 中处理 NULL 使用 IS NULL 和 IS NOT NULL 运算符。 事务MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！ 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。 事务用来管理 insert,update,delete 语句 事务要满足的四个条件(ACID)： 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 事务控制语句： BEGIN 或 START TRANSACTION 显式地开启一个事务； COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的； ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改； SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT； RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； ROLLBACK TO identifier 把事务回滚到标记点； SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。 MYSQL 事务处理主要有两种方法：1、用 BEGIN, ROLLBACK, COMMIT来实现 BEGIN 开始一个事务 ROLLBACK 事务回滚 COMMIT 事务确认 2、直接用 SET 来改变 MySQL 的自动提交模式: SET AUTOCOMMIT=0 禁止自动提交 SET AUTOCOMMIT=1 开启自动提交 脏读：指一个事务读取到了另外一个事务未提交的数据 不可重复读:在一个事务内读取表中的某一行数据，多次读取结果不同。(这个不一定是错误，只是某些场合不对)虚读(幻读)：是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。(一般是行影响，多了一行)","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://brillianttt.gitee.io/tags/MySQL/"}]},{"title":"注解和反射","slug":"注解和反射","date":"2022-04-03T13:43:50.000Z","updated":"2022-06-16T15:19:28.493Z","comments":true,"path":"2022/04/03/注解和反射/","link":"","permalink":"https://brillianttt.gitee.io/2022/04/03/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/","excerpt":"","text":"入门注解和反射 另一篇博客（讲的更详细）","categories":[],"tags":[{"name":"注解和反射","slug":"注解和反射","permalink":"https://brillianttt.gitee.io/tags/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"}]},{"title":"Spring学习","slug":"Spring学习","date":"2022-03-30T02:41:47.000Z","updated":"2022-06-22T05:26:07.399Z","comments":true,"path":"2022/03/30/Spring学习/","link":"","permalink":"https://brillianttt.gitee.io/2022/03/30/Spring%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Spring开头重要认识——什么是IOC（控制反转）IoC是什么 Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下： ●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 ●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 IoC能做什么 IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。 IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。 IoC和DIDI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下： ●谁依赖于谁：当然是应用程序依赖于IoC容器； ●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源； ●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； ●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。 IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。 Spring配置别名12&lt;!--别名，xml配置文件中的属性，如果添加了别名，我们也可以使用别名获取到这个对象 --&gt; &lt;alias name=\"user\" alias=\"balabala\"/&gt; Bean的配置12345678&lt;!--id:bean的唯一标识符，也就是相当于对象名class：bean对象对应的全限定名：包名+类型name：也是别名，而且name可以同时取多个别名，适用多种分隔符--&gt;&lt;bean id=\"userTwo\" class=\"com.ma.pojo.UserTwo\" name=\"user2 u2,u3;u4\"&gt; &lt;property name=\"name\" value=\"mby\"/&gt;&lt;/bean&gt; importimport一般用于团队开发使用，可以将多个配置文件合并导入为一个 假设某个项目中有三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的xml文件，使用的时候直接使用总的xml文件即可 DI注入构造器注入1234567891011121314&lt;!-- 第一种有参构造的方式：通过下标赋值--&gt;&lt;!-- &lt;bean id=\"user\" class=\"com.ma.pojo.User\"&gt;--&gt;&lt;!-- &lt;constructor-arg index=\"0\" value=\"mbyyyyy\"/&gt;--&gt;&lt;!-- &lt;/bean&gt;--&gt; &lt;!-- 第二种有参构造的方式：通过类型创建 不建议使用--&gt; &lt;!-- &lt;bean id=\"user\" class=\"com.ma.pojo.User\"&gt;--&gt; &lt;!-- &lt;constructor-arg type=\"java.lang.String\" value=\"qinjiang\"/&gt;--&gt; &lt;!-- &lt;/bean&gt;--&gt; &lt;!-- 第三种有参构造的方式：直接通过参数名来设置--&gt; &lt;bean id=\"user\" class=\"com.ma.pojo.User\"&gt; &lt;constructor-arg name=\"name\" value=\"mby\"/&gt; &lt;/bean&gt; Set方式注入 依赖注入：set注入 依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性由容器来注入 1、复杂类型 12345678910111213package com.ma.pojo;public class Address &#123; private String address; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 2、真实测试对象 123456789101112131415package com.ma.pojo;import java.util.List;import java.util.*;public class Student &#123; private String name; private Address address; private String[] books; private List&lt;String&gt; hobbies; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private Properties info;//配置类 private String wife; 3、beans.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"address\" class=\"com.ma.pojo.Address\"&gt; &lt;property name=\"address\" value=\"hohhot\"/&gt; &lt;/bean&gt; &lt;bean id=\"student\" class=\"com.ma.pojo.Student\"&gt;&lt;!-- 第一种，普通值注入--&gt; &lt;property name=\"name\" value=\"mby\"/&gt;&lt;!-- 第二种，Bean注入,ref--&gt; &lt;property name=\"address\" ref=\"address\"/&gt;&lt;!-- 第三种，数组注入--&gt; &lt;property name=\"books\"&gt; &lt;array&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;value&gt;三国演义&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;!-- list注入--&gt; &lt;property name=\"hobbies\"&gt; &lt;list&gt; &lt;value&gt;看剧&lt;/value&gt; &lt;value&gt;打游戏&lt;/value&gt; &lt;value&gt;打篮球&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;!-- map注入--&gt; &lt;property name=\"card\"&gt; &lt;map&gt; &lt;entry key=\"身份证\" value=\"150104200101212666\"/&gt; &lt;entry key=\"银行卡\" value=\"没密码\"/&gt; &lt;/map&gt; &lt;/property&gt;&lt;!-- set注入--&gt; &lt;property name=\"games\"&gt; &lt;set&gt; &lt;value&gt;lol&lt;/value&gt; &lt;value&gt;coc&lt;/value&gt; &lt;value&gt;bob&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;!-- null值注入--&gt; &lt;property name=\"wife\"&gt; &lt;null/&gt; &lt;/property&gt;&lt;!-- propertiers--&gt; &lt;property name=\"info\"&gt; &lt;props&gt; &lt;prop key=\"学号\"&gt;5120190266&lt;/prop&gt; &lt;prop key=\"性别\"&gt;男&lt;/prop&gt; &lt;prop key=\"姓名\"&gt;mby&lt;/prop&gt; &lt;prop key=\"学历\"&gt;本科&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 4、测试类 123456789101112import com.ma.pojo.Student;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Student student = (Student) context.getBean(\"student\"); System.out.println(student.getName()); System.out.println(student.getAddress()); &#125;&#125; 扩展方式注入：p命名和c命名p和c命名是上面代码的简化、p指的是属性property，c指的是构造器constructor，p命名就是以set方式注入，需要无参构造和set方法，c命名就是构造器注入，需要有参构造。同时需要注意二者都需要导入xml约束 p命名1、xml文件 123456789&lt;!--p命名需要的约束--&gt; xmlns:p=\"http://www.springframework.org/schema/p\" &lt;!--p命名空间注入，可以直接注入属性的值--&gt; &lt;bean id=\"user\" class=\"com.ma.pojo.User\" p:age=\"21\" p:name=\"mby\"/&gt; 2、测试类 12345678910111213import com.ma.pojo.Student;import com.ma.pojo.User;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; @Test public void test2()&#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"userbean.xml\"); User user = context.getBean(\"user\", User.class); System.out.println(user); &#125;&#125; 3、测试对象 123456789101112131415161718192021222324252627282930package com.ma.pojo;public class User &#123;//p命名只使用无参构造和set方法即可，而无参构造可以为隐式的 private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; c命名1、xml文件 123456789&lt;!--c命名需要的约束--&gt; xmlns:p=\"http://www.springframework.org/schema/c\" &lt;!--c命名空间注入，可以通过构造器注入：constructor--&gt; &lt;bean id=\"user2\" class=\"com.ma.pojo.User\" c:age=\"21\" c:name=\"mby\"/&gt; 2、测试类 12345678910111213import com.ma.pojo.Student;import com.ma.pojo.User;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; @Test public void test2()&#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"userbean.xml\"); User user = context.getBean(\"user2\", User.class);//只有这里变了 System.out.println(user); &#125;&#125; 3、测试对象 123456789public class User &#123; private String name; private int age; public User(String name, int age) &#123;//需要有参构造 this.name = name; this.age = age; &#125;//要注意，当同时在xml文件中存在同一个对象的p命名和c命名时，需要将对象的有参和无参构造 //函数同时写出，否则会报错 Bean的作用域用标识符scope(范围)来区分，包含singleton和prototype，分别表示单例模式和原型模式，单例模式只生成一个对象，原型模式生成多个对象。 xml文件 1234&lt;!--原型模式 每次从容器中get的时候都会产生一个新的对象--&gt;&lt;bean id=\"user\" class=\"com.ma.pojo.User\" c:age=\"21\" c:name=\"mby\" scope=\"prototype\"/&gt;&lt;!--单例模式 单例模式也是Spring的默认机制，可以为隐式--&gt; &lt;bean id=\"user\" class=\"com.ma.pojo.User\" c:age=\"21\" c:name=\"mby\" scope=\"singleton\"/&gt; 测试类 12345678@Test public void test3()&#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"userbean.xml\"); User user = context.getBean(\"user\", User.class); User user2 = context.getBean(\"user\", User.class); System.out.println(user==user2);//原型模式输出false，单例模式输出true &#125; 自动装配Bean 自动装配是Spring满足bean依赖的一种方式 Spring会在上下文中自动寻找，并自动给bean装配属性 在Spring 中有三种装配的方式 在xml中显式的配置 在java中显式配置 隐式的自动装配bean byName和byType装配1、xml文件配置 12345678 &lt;bean id=\"cat\" class=\"com.ma.pojo.Cat\"/&gt; &lt;bean id=\"dog\" class=\"com.ma.pojo.Dog\"/&gt; &lt;bean id=\"people\" class=\"com.ma.pojo.People\" autowire=\"byName\"&gt;//装配方式为byName &lt;property name=\"name\" value=\"mby\"/&gt;&lt;!-- &lt;property name=\"dog\" ref=\"dog\"/&gt;--&gt;&lt;!-- &lt;property name=\"cat\" ref=\"cat\"/&gt;--&gt; &lt;/bean&gt; 2、测试类和被测试的实体类 1234567891011121314151617181920212223242526272829public class MyTest &#123; @Test public void test1()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); People people = context.getBean(\"people\", People.class); people.getDog().shot(); people.getCat().shot(); &#125;&#125;public class Cat &#123; public void shot()&#123; System.out.println(\"miao\"); &#125;&#125;public class Dog &#123; public void shot()&#123; System.out.println(\"wang\"); &#125;&#125;public class People &#123; private Cat cat; private Dog dog; private String name; //下面还包含三个变量的get和set方法 byName和byType的区别byName:会自动在容器上下文中查找和自己对象set方法后面的值对应的bean id，若找不到则装配失败 byName的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法一致 byType的时候，需要保证素有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致 注解实现自动装配（重点）这个链接将自动装配的作用解释的很清晰 使用注解须知： 导入约束：contest约束 配置注解的支持:idea只加上context:annotation-config/这一句即可，然后alt+enter自动导入约束 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Autowired使用：直接在属性上使用， 注意xml中的id和实体类中的属性要一致，否则无法导入 使用Autowired在实体类中可以省去实体类中的set方法，前提是自动装配的属性在IOC（Spring容器）中存在且符合类型byType 123456&lt;!--开启注解的支持--&gt;&lt;context:annotation-config/&gt; &lt;bean id=\"cat\" class=\"com.ma.pojo.Cat\"/&gt;&lt;bean id=\"dog\" class=\"com.ma.pojo.Dog\"/&gt;&lt;bean id=\"people\" class=\"com.ma.pojo.People\"/&gt; 1234567public class People &#123; @Autowired //此处通过autowired注解实现自动导入 private Cat cat; @Autowired private Dog dog; private String name; @Qualifie的使用 12345678public class People &#123; @Autowired private Cat cat; @Autowired @Qualifier(value = \"dog222\") private Dog dog; private String name; 如果@AutoWired自动装配的环境比较复杂，自动装配无法通风、、通过一个注解【@Autowired】完成的时候，我们可以使用@Qualifer(value=”xxx”)去配置Autowired的使用，指定一个为唯一的bean对象注入。 @Resources注解 1234567public class People &#123; @Resource private Cat cat; @Resource private Dog dog; private String name; @Resources和@Autowired的对比： 都是用来自动装配的，都可以放在属性字段上 @Autowired通过buType方式实现，而且要求这个对象必须存在 Resources默认通过byName方式实现，如果找不到名字，则通过byType实现；若两个都找不到则报错 执行顺序不同， 使用注解开发在spring4之后，若使用注解开发，必须要保证aop的包被导入，使用注解需要导入context约束，增加注解的支持 bean注解 12&lt;!-- 指定要扫描的包，这个包下的注解就会生效--&gt; &lt;contest:component-scan base-package=\"com.ma.pojo\"/&gt; 1234@Componentpublic class User &#123; public String name=\"mby\";&#125; 用注解注入属性 1234567891011121314151617@Componentpublic class User &#123; @Value(\"mby\") //使用value给属性赋值，相当于在xml文件中添加property的value值，一般简单的程序可以用这个，复杂的还是要用配置文件 public String name;&#125;@Componentpublic class User &#123; public String name; @Value(\"mby\") //Value注解也可以用在set方法上 public void setName(String name)&#123; this.name=name; &#125;&#125; 衍生的注解 ​ @Component有几个衍生注解，在web开发中，会按照mvc三层架构分层： dao【@Respository】 service【@Service】 controller【@Controller】 ​ 这几个注解的功能是一样的，都是代表将某个类注册到Spring中，装配Bean ​ 4. 自动装配 12345@Autowired: 自动装配通过类型、名字，如果不能唯一装配上属性，则需要通过@Qualifier(value=\"xxx\")@Nullable : 字段标记了这个注解，说明这个字段可以为null@Resource ： 自动装配通过名字、类型 作用域 123456789//等价于&lt;bean id=\"user\" class=\"com.ma.pojo.User\"&gt;@Component//等价于&lt;bean class=\"com.ma.pojo.User\" scope=\"prototype\"/&gt;@Scope(\"prototype\")public class User &#123; @Value(\"mby\") public String name;&#125; 小结 xml与注解： xml更加万能，适用于任何场合！维护简单方便 注解不是自己的类使用不了，维护相对复杂 xml与注解的分配： xml用来管理bean 注解只负责完成属性的注入 在使用注解的时候必须开启注解的支持（xml扫描包） 使用Java的方式配置Spring实体类 1234567891011121314151617181920212223242526package com.ma.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;//添加component说明这个类被spring接管了，注册到了容器中@Componentpublic class User &#123; private String name; public String getName() &#123; return name; &#125; @Value(\"mby\") public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125;&#125; 配置文件（配置类） 123456789101112//Configuration代表这是一个配置类，就和我们之前看的beans.xml一致@Configurationpublic class myConfig &#123; //注册一个bean就相当于之前写的一个bean标签 //方法名就相当于id属性 //这个方法的返回值就相当于class属性 @Bean public User getUser()&#123; return new User(); &#125;&#125; 测试类 123456789101112131415import com.ma.config.myConfig;import com.ma.pojo.User;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; //如果完全使用了配置类方式去做，我们就只能通过AnnotationConfig上下文来获取容器 // 通过配置类的class对象加载 ApplicationContext context = new AnnotationConfigApplicationContext(myConfig.class); User getUSer = (User) context.getBean(\"getUser\"); System.out.println(getUSer.getName()); &#125;&#125; 代理模式代理模式的分类： 静态代理 动态代理 静态代理角色分析： 抽象角色：一般会使用接口或者抽象类来解决 真实角色：被代理的角色 代理角色：代理真实角色，代理真是角色后，我们一般会做一些附属操作 客户：访问代理对象的人 代码步骤： 接口 1234public interface Rent &#123; public void rent();&#125; 真实角色 123456//房东public class Host implements Rent &#123; public void rent() &#123; System.out.println(\"房东要出租房子\"); &#125;&#125; 代理角色 1234567891011121314151617181920212223242526//中介public class Proxy implements Rent&#123; private Host host; public Proxy(Host host) &#123; this.host = host; &#125; public void rent() &#123; seeHouse(); hetong(); fare(); host.rent(); &#125; public void seeHouse()&#123; System.out.println(\"中介带你看房\"); &#125; public void fare()&#123; System.out.println(\"收中介费\"); &#125; public void hetong()&#123; System.out.println(\"签合同\"); &#125;&#125; 客户端访问代理角色 1234567public class Client &#123; public static void main(String[] args) &#123; Host host =new Host(); Proxy proxy=new Proxy(host); proxy.rent(); &#125;&#125; 代理模式的好处： 可以使真实角色的操作更加纯粹，不用去关注一些公共的业务 公共也就就交给代理角色!实现了业务的分工 公共业务发生扩展的时候，方便集中管理 缺点： 一个真实角色就会产生一 个代理角色;代码量会翻倍~开发效率会变低 动态代理 动态代理和静态代理角色一样 动态代理的代理类是动态生成的，不是直接写好的 动态代理分为两大类:基于接口的动态代理，基于类的动态代理 基于接口–JDK动态代理 基于类：cglib java字节码实现：javasist 需要了解两个类：Proxy：代理；InvocationHandler：调用处理程序。 动态代理的好处： 可以使真实角色的操作更加纯粹!不用去关注一些公共的业务 公共也就就交给代理角色，实现了业务的分工 公共业务发生扩展的时候，方便集中管理! 一个动态代理类代理的是一个接口，一般就是对应的一类业务 一个动态代理类可以代理多个类，只要是实现了同一个接口即可 12345678910111213141516171819202122232425262728293031323334//插科打诨int main()&#123; cout&lt;&lt;\"计算机专业\"&lt;&lt;endl; cout&lt;&lt;\"c、c++、java、数据结构、算法分析、密码学、课程设计、大作业、毕设、后端项目(反正常见的都能写)\"&lt;&lt;endl; cout&lt;&lt;\"q：1831883931\"&lt;&lt;endl; cout&lt;&lt;\"价格合理 写题有20%-30%定金 需求描述要清晰 真心有需要再加 大家的时间都很宝贵\"&lt;&lt;endl; cout&lt;&lt;\"emmm再来个经验丰富？ 已有 jie dan 两年经验 就是挣个零花💴\"&lt;&lt;endl; cout&lt;&lt;\"再加一个 和淘宝店有大量合作经验 与其去找淘宝店花更多的钱 不如直接来找我😂\"&#125; //// _oo0oo_// o8888888o// 88\" . \"88// (| -_- |)// 0\\ = /0// ___/`---'\\___// .' \\\\| |// '.// / \\\\||| : |||// \\// / _||||| -:- |||||- \\// | | \\\\\\ - /// | |// | \\_| ''\\---/'' |_/ |// \\ .-\\__ '-' ___/-. /// ___'. .' /--.--\\ `. .'___// .\"\" '&lt; `.___\\_&lt;|&gt;_/___.' &gt;' \"\".// | | : `- \\`.;`\\ _ /`;.`/ - ` : | |// \\ \\ `_. \\_ __\\ /__ _/ .-` / /// =====`-.____`.___ \\_____/___.-`___.-'=====// `=---='////// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#125; AOPAop在Spring中的作用提供声明式的事务，允许用户自定义切面 横切关注点∶跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等… 切面(ASPECT)︰横切关注点被模块化的特殊对象。即，它是一个类。 通知(Advice):切面必须要完成的工作。即，它是类中的一个方法。 目标（Target):被通知对象。 代理（Proxy)︰向目标对象应用通知之后创建的对象。 切入点(PointCut):切面通知执行的“地点”的定义。 连接点(JointPoint) :与切入点匹配的执行点。 使用Spring实现Aop使用aop织入，需要导入依赖包 12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.9&lt;/version&gt;&lt;/dependency&gt; 同时在xml文件中要在beans中导入xsd元素(最后两行) 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; 然后创建实体类UserService和其接口 1234567891011121314151617181920212223242526272829package com.ma.service;public interface UserService &#123; public void add(); public void delete(); public void update(); public void select();&#125;package com.ma.service;public class UserServiceImpl implements UserService&#123; public void add() &#123; System.out.println(\"增加一个用户\"); &#125; public void delete() &#123; System.out.println(\"删除一个用户\"); &#125; public void update() &#123; System.out.println(\"修改一个用户\"); &#125; public void select() &#123; System.out.println(\"查询一个用户\"); &#125;&#125; 接着在xml文件中配置接口信息,然后对比三种实现aop的方式 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&lt;!--这三行--&gt; &lt;bean id=\"userService\" class=\"com.ma.service.UserServiceImpl\"/&gt; &lt;bean id=\"log\" class=\"com.ma.log.Log\"/&gt; &lt;bean id=\"afterLog\" class=\"com.ma.log.AfterLog\"/&gt; &lt;/beans&gt; 实现方式1：使用spring的api接口【主要springAPI接口实现】xml文件： 123456789&lt;!-- 方式一：使用原生的spring api接口 需要导入aop的约束--&gt; &lt;aop:config&gt;&lt;!-- 切入点，expression：表达式，execution（要执行的位置）--&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.ma.service.UserServiceImpl.*(..))\"/&gt;&lt;!-- 执行环绕增加--&gt; &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt; log和afterlog类(略麻烦，需要写好几个类作为执行类) 12345678910111213141516public class Log implements MethodBeforeAdvice &#123; //method:要执行的目标对象的方法 //object:参数 //target：目标对象 public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(target.getClass().getName()+\"的\"+method.getName()+\"被执行了\"); &#125;&#125;public class AfterLog implements AfterReturningAdvice &#123; public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(\"执行了\"+method.getName()+\"方法，返回的结果为\"+returnValue); &#125;&#125; 实现方式2：自定义来实现aop【主要是切面的定义】xml文件： 123456789101112 &lt;!-- 方式二：自定义类 需要导入aop的约束--&gt; &lt;bean id=\"diy\" class=\"com.ma.diy.DiyPointCut\"/&gt; &lt;aop:config&gt; &lt;aop:aspect ref=\"diy\"&gt;&lt;!-- 切入点--&gt; &lt;aop:pointcut id=\"point\" expression=\"execution(* com.ma.service.UserServiceImpl.*(..))\"/&gt;&lt;!-- 通知--&gt; &lt;aop:before method=\"before\" pointcut-ref=\"point\"/&gt; &lt;aop:after method=\"after\" pointcut-ref=\"point\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; diy类（较方便） 12345678910package com.ma.diy;public class DiyPointCut &#123; public void before()&#123; System.out.println(\"===========方法执行前==========\"); &#125; public void after()&#123; System.out.println(\"===========方法执行后==========\"); &#125;&#125; 实现方式3：使用注解实现xml文件： 1234&lt;!--方式三--&gt; &lt;bean id=\"AnnotationPointCut\" class=\"com.ma.diy.AnnotationPointCut\"/&gt;&lt;!-- 开启注解支持--&gt; &lt;aop:aspectj-autoproxy/&gt; 注解的实现类(三个注解：before、after和around) 12345678910111213141516171819202122232425262728293031323334package com.ma.diy;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.Signature;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspect //表置这个类是一个切面public class AnnotationPointCut &#123; @Before(\"execution(* com.ma.service.UserServiceImpl.*(..))\") public void before()&#123; System.out.println(\"======方法执行前========\"); &#125; @After(\"execution(* com.ma.service.UserServiceImpl.*(..))\") public void after()&#123; System.out.println(\"======方法执行后========\"); &#125; //在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点 @Around(\"execution(* com.ma.service.UserServiceImpl.*(..))\") public void around(ProceedingJoinPoint pj)throws Throwable&#123; System.out.println(\"环绕前\"); Object proceed = pj.proceed();//执行方法 System.out.println(\"环绕后\"); Signature signature = pj.getSignature();//获得签名 System.out.println(\"signature\"+signature); System.out.println(proceed); &#125;&#125;","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://brillianttt.gitee.io/tags/Spring/"}]},{"title":"MyBatis学习","slug":"Mybatis学习","date":"2022-03-30T02:41:47.000Z","updated":"2022-06-21T13:42:11.456Z","comments":true,"path":"2022/03/30/Mybatis学习/","link":"","permalink":"https://brillianttt.gitee.io/2022/03/30/Mybatis%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"开头第一个Mybatis程序思路：搭建环境-&gt;导入Mybatis-&gt;写代码-&gt;测试！ 搭建环境搭建数据库 123456789101112131415CREATE DATABASE &#96;mybatis&#96;; USE &#96;mybatis&#96;;CREATE TABLE &#96;user&#96;( &#96;id&#96; INT(20) PRIMARY KEY NOT NULL, &#96;name&#96; VARCHAR(30) DEFAULT NULL, &#96;pwd&#96; VARCHAR(30) DEFAULT NULL)ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8;INSERT INTO &#96;user&#96;(&#96;id&#96;,&#96;name&#96;,&#96;pwd&#96;)VALUES(1,&#39;mby&#39;,&#39;123456&#39;),(2,&#39;zs&#39;,&#39;123456&#39;),(3,&#39;ls&#39;,&#39;123456&#39;) 新建项目 新建一个普通的maven项目 删除src目录，将整个文件作为父文件夹 导入maven依赖 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;!--父工程--&gt; &lt;groupId&gt;com.ma&lt;/groupId&gt; &lt;artifactId&gt;Mybatis-study&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;mybatis-01&lt;/module&gt; &lt;/modules&gt; &lt;!--导入依赖--&gt; &lt;dependencies&gt;&lt;!-- mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.9&lt;/version&gt; &lt;/dependency&gt;&lt;!-- mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt;&lt;!-- junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建一个模块 编写mybatis的核心配置文件mybatis-config.xml 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!--核心配置文件--&gt;&lt;configuration&gt;&lt;!-- 环境--&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;userUnicode=true&amp;amp;characterEncoding=UTF-8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"Mby12345@\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 编写mybatis工具类 12345678910111213141516171819202122232425262728package com.ma.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;//工具类public class MybatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; static &#123; try &#123; //使用mybatis第一步：获取sqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(); &#125;&#125; 编写代码 实体类 1234567891011121314151617181920212223242526272829303132333435363738394041package com.ma.pojo;//实体类public class User &#123; private int id; private String name; private String pwd; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", pwd='\" + pwd + '\\'' + '&#125;'; &#125;&#125; Dao接口 1234public interface UserDao &#123; List&lt;User&gt; getUserList();&#125; 接口实现类由原来的UserDaoImpl转变为一个Mapper配置文件 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!--namespace绑定了一个对应的Dao/Mapper接口--&gt;&lt;mapper namespace=\"com.ma.dao.UserDao\"&gt;&lt;!-- 查询接口--&gt; &lt;select id=\"getUserList\" resultType=\"com.ma.pojo.User\"&gt; select * from mybatis.user &lt;/select&gt;&lt;/mapper&gt; 测试test类： 1234567891011121314151617181920212223242526package com.ma.dao;import com.ma.pojo.User;import com.ma.utils.MybatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class UserDaoTest &#123; @Test public void test()&#123; //获取sqlsession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //执行sql UserDao mapper = sqlSession.getMapper(UserDao.class); List&lt;User&gt; userList = mapper.getUserList(); for (User user : userList) &#123; System.out.println(user); &#125; sqlSession.close(); &#125;&#125; 注意点： 1、未加注册接口导致报错： org.apache.ibatis.binding.BindingException: Type interface com.ma.dao.UserDao is not known to the MapperRegistry. 解决：在resources下的mybatis-config.xml配置文件中加入注册信息(注意reources路径的分隔符要用/ 因为后面的mapper文件存在后缀.xml 需要区分开) 1234&lt;!--每一个mapper.xml都需要在mybatis核心配置文件中注册--&gt; &lt;mappers&gt; &lt;mapper resource=\"com/ma/dao/UserMapper.xml\"/&gt; &lt;/mappers&gt; 2、找不到UserMapper.xml文件，因为该xml文件并不在resources中 解决：在pom.xml下添加build信息，扫描xml文件 12345678910111213141516171819&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 最终得到输出信息 123User&#123;id&#x3D;1, name&#x3D;&#39;mby&#39;, pwd&#x3D;&#39;123456&#39;&#125;User&#123;id&#x3D;2, name&#x3D;&#39;zs&#39;, pwd&#x3D;&#39;123456&#39;&#125;User&#123;id&#x3D;3, name&#x3D;&#39;ls&#39;, pwd&#x3D;&#39;123456&#39;&#125; CRUDnamespacenamespace中的包名要和Dao/mapper接口的包名一致 增删查改的具体操作选择，查询语句 id：对应的namespace中的方法名 resulttype：Sql语句执行的返回值 parameterType：参数类型 具体流程大同小异： 首先编写接口 12345678910111213141516public interface UserMapper &#123; //查询全部用户 List&lt;User&gt; getUserList(); //根据ID查询用户 User getUserById(int id); //添加一个用户 int addUser(User user); //修改用户 int updateUser(User user); //删除用户 int deleteUser(int id);&#125; 然后编写配置文件 1234567891011121314151617181920212223&lt;mapper namespace=\"com.ma.dao.UserMapper\"&gt;&lt;!-- 查询接口--&gt; &lt;select id=\"getUserList\" resultType=\"com.ma.pojo.User\"&gt; select * from mybatis.user &lt;/select&gt; &lt;select id=\"getUserById\" parameterType=\"int\" resultType=\"com.ma.pojo.User\"&gt; select * from mybatis.user where id = #&#123;id&#125; &lt;/select&gt;&lt;!-- 添加接口--&gt; &lt;insert id=\"addUser\" parameterType=\"com.ma.pojo.User\"&gt; insert into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;) &lt;/insert&gt;&lt;!-- 修改接口--&gt; &lt;update id=\"updateUser\" parameterType=\"com.ma.pojo.User\"&gt; update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;; &lt;/update&gt;&lt;!-- 删除接口--&gt; &lt;delete id=\"deleteUser\" parameterType=\"int\" &gt; delete from mybatis.user where id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 最后编写各自的测试类 这里要注意在进行查询的时候不需要提交事务，而进行“增删改”的时候需要提交事务（commit） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class UserMapperTest &#123; @Test public void test()&#123; //获取sqlsession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //执行sql UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.getUserList(); for (User user : userList) &#123; System.out.println(user); &#125; sqlSession.close(); &#125; @Test public void getUserById()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close(); &#125; @Test public void addUser()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int n=mapper.addUser(new User(4,\"hhh\",\"123456\")); if(n&gt;0)&#123; System.out.println(\"插入成功\"); &#125; sqlSession.commit();//提交事务 sqlSession.close(); &#125; @Test public void updateUser()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int n=mapper.updateUser(new User(4,\"hh\",\"123\")); if(n&gt;0)&#123; System.out.println(\"修改成功\"); &#125; sqlSession.commit(); sqlSession.close(); &#125; @Test public void deleteUser()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int n=mapper.deleteUser(4); if(n&gt;0)&#123; System.out.println(\"删除成功\"); &#125; sqlSession.commit(); sqlSession.close(); &#125;&#125; 使用Map使用map替代实体类传递参数，可以减小内存空间的使用 以添加用户为例： 接口： 1int addUser2(Map&lt;String,Object&gt; map); xml文件： 123&lt;insert id=\"addUser2\" parameterType=\"map\"&gt; insert into mybatis.user (id,name,pwd) values (#&#123;userid&#125;,#&#123;userName&#125;,#&#123;passWord&#125;)&lt;/insert&gt; 测试类： 1234567891011121314@Testpublic void addUser2()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"userid\",5); map.put(\"userName\",\"balabala\"); map.put(\"passWord\",\"123456\"); mapper.addUser2(map); sqlSession.commit(); sqlSession.close();&#125; 模糊查询以查询用户为例： 接口： 1List&lt;User&gt; getUserLike(String value); xml文件： 123&lt;select id=\"getUserLike\" resultType=\"com.ma.pojo.User\"&gt; select * from mybatis.user where name like #&#123;value&#125;&lt;/select&gt; 测试类： 1234567891011@Test public void getUserLike()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.getUserLike(\"%l%\");//%是通配符 中间的l是查找用户名ls的l for (User user : userList) &#123; System.out.println(user); &#125; sqlSession.close(); &#125; 配置解析核心配置文件 mybatis-config.xml mybatis的配置文件包含了回深深映像mybatis行为的设置和属性信息 要注意下面列出配置文件的组成部分的顺序不能变化，否则会有报错：The content of element type “configuration” must match “(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)”. 也就是说需要按照属性、设置、类型别名balabala依次引入配置 123456789101112properties（属性）settings（设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境配置）environment（环境变量）transactionManager（事务管理器）dataSource（数据源）databaseIdProvider（数据库厂商标识）mappers（映射器） 环境配置 MyBatis可以配置成适应多种环境 不过要记住:尽管可以配置多个环境，但每个SqlSessionFactory实例只能选择一种环境。学会使用配置多套运行环境! Mybatis默认的事务管理器就是JDBC，连接池: POOLED properties（属性）可以通过properties属性来实现引用配置文件 这些属性都是可外部配置且可动态替换的，既可以在典型的Java属性文件中配置，亦可通过properties元素的子元素来传递。【db.properties】 编写一个配置文件db.properties 1234driver = com.mysql.jdbc.Driverurl = jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;userUnicode=true&amp;amp;characterEncoding=UTF-8username =rootpassword =123456 在核心配置文件中引入 123456789&lt;!-- 引入外部配置文件--&gt; &lt;properties resource=\"db.properties\"/&gt;&lt;!-- 引入外部配置文件--&gt; &lt;properties resource=\"db.properties\"&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"pwd\" value=\"123456\"/&gt; &lt;/properties&gt; 可以直接引入外部文件 可以在其中增加一些属性配置 如果两个文件有同一个字段，优先使用外部配置文件的 settings（设置）这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 下表描述了设置中各项设置的含义、默认值等。 设置名 描述 有效值 默认值 cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 true | false true lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。 true | false false typeAliases（类型别名） 类型别名是为Java类型设置一个短的名字。 存在的意义仅在于用来减少类完全限定名的冗余。 1234&lt;!-- 可以给实体类起别名--&gt; &lt;typeAliases&gt; &lt;typeAlias alias=\"User\" type=\"com.ma.pojo.User\"/&gt; &lt;/typeAliases&gt; 也可以指定一个包名，MyBatis会在包名下面搜索需要的Java Bean，比如: 扫描实体类的包，它的默认别名就为这个类的类名，首字母小写 12345&lt;!-- 可以给实体类起别名--&gt; &lt;typeAliases&gt;&lt;!-- &lt;typeAlias alias=\"User\" type=\"com.ma.pojo.User\"/&gt;--&gt; &lt;package name=\"com.ma.pojo\"/&gt; &lt;/typeAliases&gt; 在实体类比较少的时候使用第一种方式，如果实体类很多用第二种方式较好 第一种可以自定义别名，第二种则不行，如果一定要使用则需要在实体上增加注解@Alias(“balabala”) 12@Alias(\"user\")public class User&#123;&#125; 其他配置typeHandlers（类处理器）、objectFactory（对象工厂）、plugins（插件） mapper(映射器)MapperRegistry：注册绑定Mapper文件 方式一： 1234&lt;!--每一个mapper.xml都需要在mybatis核心配置文件中注册--&gt;&lt;mappers&gt; &lt;mapper resource=\"com/ma/dao/UserMapper.xml\"/&gt;&lt;/mappers&gt; 方式二： 12345&lt;!--每一个mapper.xml都需要在mybatis核心配置文件中注册--&gt; &lt;mappers&gt;&lt;!-- &lt;mapper resource=\"com/ma/dao/UserMapper.xml\"/&gt;--&gt; &lt;mapper class=\"com.ma.dao.UserMapper\"/&gt; &lt;/mappers&gt; 注意： 接口和他的mapper配置文件必须同名 接口和他的mapper配置文件必须在同一个包下 方式三：使用扫描包进行注入绑定 1234 &lt;mappers&gt;&lt;!-- &lt;mapper resource=\"com/ma/dao/UserMapper.xml\"/&gt;--&gt; &lt;package name=\"com.ma.dao\"/&gt; &lt;/mappers&gt; 生命周期和作用域生命周期和作用域很重要，错误使用会导致严重的并发问题 SqlSessionFactoryBuilder: 一旦创建SqlSessionFactory就不再需要它了 是局部变量 SqlSessionFactory： 说白了就是可以想象为︰数据库连接池 SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 因此SqlSessionFactory的最佳作用域是应用作用域。 最简单的就是使用单例模式或者静态单例模式。 SqlSession： 连接到连接池的一个请求! SqlSession的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后需要赶紧关闭，否则资源被占用! 解决属性名和字段名不一致的情况新建一个项目，拷贝之前的内容，测试实体类字段不一致的情况 1234public class User &#123; private int id; private String name; private String password; //此时password字段和数据库字段不匹配 编写测试文件查找id=1的用户，结果为：User{id=1, name=’mby’, password=’null’}，发现此时password字段为空，因为password和数据库中的属性名pwd不匹配 123&lt;select id=\"getUserById\" parameterType=\"int\" resultType=\"User\"&gt; select * from mybatis.user where id = #&#123;id&#125;&lt;/select&gt; 上面这段代码就等价于 123&lt;select id=\"getUserById\" parameterType=\"int\" resultType=\"User\"&gt; select id,name,pwd from mybatis.user where id = #&#123;id&#125;&lt;/select&gt; 解决方法： 起别名（不推荐使用） 123&lt;select id=\"getUserById\" parameterType=\"int\" resultType=\"User\"&gt; select *,pwd as passwoed from mybatis.user where id = #&#123;id&#125;&lt;/select&gt; 使用resultMap（结果集映射） 12345678910&lt;resultMap id=\"UserMap\" type=\"User\"&gt; &lt;result column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\" /&gt; &lt;result column=\"pwd\" property=\"password\" /&gt;&lt;/resultMap&gt; &lt;select id=\"getUserById\" resultMap=\"UserMap\"&gt; select * from mybatis.user where id = #&#123;id&#125;&lt;/select&gt; resultMap元素是Mybatis中最重要最强大的元素 resultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了 日志日志工厂Mybatis 通过使用内置的日志工厂提供日志功能。内置日志工厂将会把日志工作委托给下面的实现之一： SLF4J Apache Commons Logging Log4j 2 Log4j (deprecated since 3.5.9) JDK logging MyBatis 内置日志工厂基于运行时自省机制选择合适的日志工具。它会使用第一个查找得到的工具（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。 1234567&lt;configuration&gt; &lt;settings&gt; ... &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt; ... &lt;/settings&gt;&lt;/configuration&gt; logImpl 可选的值有：SLF4J、LOG4J、LOG4J2、JDK_LOGGING、COMMONS_LOGGING、STDOUT_LOGGING、NO_LOGGING LOG4J Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 我们也可以控制每一条日志的输出格式; 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 具体参考log4j_百度百科 (baidu.com) 分页使用Limit分页 12语法：select * from user limit startIndex,pageSize;#从第startIndex行开始，输出pageSize行数据select * from user limit 4; #输出四行数据 [0,4) 使用mybatis实现分页，核心sql 接口 1List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map); Mapper.xml 1234&lt;!-- 分页--&gt; &lt;select id=\"getUserByLimit\" parameterType=\"map\" resultType=\"user\" resultMap=\"UserMap\"&gt; select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125; &lt;/select&gt; 测试 12345678910111213141516@Testpublic void getUserByLimit()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(\"startIndex\",0); map.put(\"pageSize\",2); List&lt;User&gt; userList = mapper.getUserByLimit(map); for (User user : userList) &#123; System.out.println(user); &#125; sqlSession.close();&#125; Lombok使用步骤： 安装lombok插件 在setting中搜素lombok进行安装 导入jar包 12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.22&lt;/version&gt;&lt;/dependency&gt; 在实体类增加注解 12345678910111213141516171819202122@Getter and @Setter@FieldNameConstants@ToString@EqualsAndHashCode@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog@Data@Builder@SuperBuilder@Singular@Delegate@Value@Accessors@Wither@With@SneakyThrows@val@varexperimental @var@UtilityClass@ExtensionMethod (Experimental, activate manually in plugin settings)Lombok config system 优缺点： 优： 能通过注解的形式自动生成构造器、 getter/setter、equals、hashcode、toString等方法，提高了一定的开发效率 让代码变得简洁，不用过多的去关注相应的方法 属性做修改时，也简化了维护为这些属性所生成的getter/setter方法等 缺： 不支持多种参数构造器的重载 虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度 多对一处理 导入lombok 导入lombok 新建实体类Teacher, Student 建立Mapper接口 建立Mapper.XML文件 在核心配置文件中绑定注册我们的Mapper接口或者文件! [方式很多， 随心选] 测试查询是否能够成功! 按照查询嵌套处理123456789101112131415&lt;select id=\"getStudent\" resultMap=\"StudentTeacher\"&gt; select * from student &lt;/select&gt; &lt;resultMap id=\"StudentTeacher\" type=\"Student\"&gt; &lt;result property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;association property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/&gt; &lt;/resultMap&gt; &lt;select id=\"getTeacher\" resultType=\"Teacher\"&gt; select * from teacher where id= #&#123;id&#125; &lt;/select&gt; 按照结果嵌套处理12345678910111213&lt;select id=\"getStudent2\" resultMap=\"StudentTeacher2\"&gt; select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id;&lt;/select&gt;&lt;resultMap id=\"StudentTeacher2\" type=\"Student\"&gt; &lt;result property=\"id\" column=\"sid\"/&gt; &lt;result property=\"name\" column=\"sname\"/&gt; &lt;association property=\"teacher\" column=\"Teacher\"&gt; &lt;result property=\"name\" column=\"tname\"/&gt; &lt;/association&gt;&lt;/resultMap&gt; 一对多处理动态SQL什么是动态SQL:动态SQL就是指根据不同的条件生成不同的SQL语句 搭建环境1234567CREATE TABLE `blog`(`id` VARCHAR(50) NOT NULL COMMENT '博客id',`title` VARCHAR(100) NOT NULL COMMENT '博客标题',`author` VARCHAR(30) NOT NULL COMMENT '博客作者',`create_time` DATETIME NOT NULL COMMENT '创建时间',`views` INT(30) NOT NULL COMMENT '浏览量')ENGINE=INNODB DEFAULT CHARSET=utf8; 创建一一个基础工程1.导包2.编写配置文件3.编写实体类 12345678@Datapublic class Blog &#123; private int id; private String title; private String author; private Date date; private int views;&#125; 4.编写实体类对应Mapper接口和Mapper.xml文件 接口： 123456public interface BlogMapper &#123; //添加用户信息 int addBlog(Blog blog); //查询 List&lt;Blog&gt; queryBlogIF(Map map);&#125; xml: 12345678910111213141516171819202122&lt;mapper namespace=\"com.ma.dao.BlogMapper\"&gt; &lt;insert id=\"addBlog\" parameterType=\"blog\"&gt; insert into mybatis.blog(id,title,author,create_time,views) values (#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;); &lt;/insert&gt; &lt;select id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\"&gt; select * from mybatis.blog where 1=1 &lt;if test=\"title!=null\"&gt; and title=#&#123;title&#125; &lt;/if&gt; &lt;if test=\"author!=null\"&gt; and author=#&#123;author&#125; &lt;/if&gt; &lt;/select&gt;&lt;/mapper&gt; 测试类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MyTest &#123; @Test public void addBlogTest() &#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); Blog blog = new Blog(); blog.setId(IDUtils.getID()); blog.setTitle(\"Mybatis\"); blog.setAuthor(\"狂神说\"); blog.setCreateTime(new Date()); blog.setViews(9999); mapper.addBlog(blog); blog.setId(IDUtils.getID()); blog.setTitle(\"Java\"); mapper.addBlog(blog); blog.setId(IDUtils.getID()); blog.setTitle(\"Spring\"); mapper.addBlog(blog); blog.setId(IDUtils.getID()); blog.setTitle(\"微服务\"); mapper.addBlog(blog); sqlSession.commit(); sqlSession.close(); &#125; @Test public void queryBlogIF()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); HashMap map = new HashMap(); map.put(\"title\",\"Java\"); map.put(\"view\",9999); List&lt;Blog&gt; blogs = mapper.queryBlogIF(map); for (Blog blog : blogs) &#123; System.out.println(blog); &#125; sqlSession.close(); &#125;&#125; trim、where、set通过where标签避免sql查询字段拼接错误，当至少有一个子元素的条件返回sql子句的情况下才去插入where子句，而且若语句的开头为AND或者OR，where元素也会将他们去除，避免拼接错误。 1234567891011&lt;select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"blog\"&gt; select * from mybatis.blog &lt;where&gt; &lt;if test=\"title!=null\"&gt; and title=#&#123;title&#125; &lt;/if&gt; &lt;if test=\"author!=null\"&gt; and author=#&#123;author&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 除了使用where标签，还可以使用trim元素自定义标签 123&lt;trim prefix=\"WHERE\" prefixOverrides=\"AND |OR \"&gt; ...&lt;/trim&gt; prefixOverrides 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 prefixOverrides 属性中指定的内容，并且插入 prefix 属性中指定的内容。 用于动态更新语句的类似解决方案叫做 set。set 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如： 12345678910&lt;update id=\"updateAuthorIfNecessary\"&gt; update Author &lt;set&gt; &lt;if test=\"username != null\"&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test=\"password != null\"&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test=\"email != null\"&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=\"bio != null\"&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; 这个例子中，set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。 来看看与 set 元素等价的自定义 trim 元素吧： 123&lt;trim prefix=\"SET\" suffixOverrides=\",\"&gt; ...&lt;/trim&gt; 注意，我们覆盖了后缀值设置，并且自定义了前缀值。 choose(when,otherwise)if语句的使用方法已经在上面的代码中给出，下面学习choose的使用 123456789101112131415&lt;select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"blog\"&gt; select * from mybatis.blog &lt;where&gt; &lt;choose&gt; &lt;when test=\"title!=null\"&gt; and title=#&#123;title&#125; &lt;/when&gt; &lt;when test=\"author!=null\"&gt; and author=#&#123;author&#125; &lt;/when&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; SQL片段可以通过sql标签讲sql代码进行抽取，然后通过id进行访问，实现代码的复用 12345678910111213&lt;sql id=\"if-title-author\"&gt; &lt;if test=\"title!=null\"&gt; and title=#&#123;title&#125; &lt;/if&gt; &lt;if test=\"author!=null\"&gt; and author=#&#123;author&#125; &lt;/if&gt;&lt;/sql&gt;&lt;select id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\"&gt; select * from mybatis.blog where 1=1 &lt;include refid=\"if-title-author\"&gt;&lt;/include&gt;&lt;/select&gt; 注意： 最好基于单表使用sql片段 在提取片段时不要讲where标签加入 Foreach例句： 1select * from user where 1&#x3D;1 and (id&#x3D;1 or id&#x3D;2 or id&#x3D;3) foreach语句： 12345678910&lt;select id=\"selectPostIn\" resultType=\"domain.blog.Post\"&gt; SELECT * FROM POST P &lt;where&gt; &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"ID in (\" separator=\",\" close=\")\" nullable=\"true\"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 其中，list为集合类，item为集合项，index为索引，open为开头，separator为分隔符，close为结尾 xml： 123456789&lt;select id=\"queryBlogForeach\" parameterType=\"map\" resultType=\"blog\"&gt; select * from mybatis.blog &lt;where&gt; &lt;foreach collection=\"ids\" item=\"id\" open=\"and (\" close=\")\" separator=\"or\"&gt; id=#&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 测试类： 123456789101112131415@Testpublic void queryBlogForeach()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); HashMap map = new HashMap(); ArrayList&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); map.put(\"ids\",ids); ids.add(1); ids.add(2); ids.add(4); List&lt;Blog&gt; blogs = mapper.queryBlogForeach(map); for (Blog blog : blogs) &#123; System.out.println(blog); &#125;&#125; 总结：==动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了== 建议： 现在mysql写出完整的sql语句，再将其改为动态sql以实现通用 面试高频： Mysql引擎 lnnoDB底层原理 索引 索引优化! 缓存一级缓存默认开启，只在一次sqlSession中有效，也就是sqlSession的开启和关闭之间 缓存失效的情况: 查询不同的东西 增删改操作，可能会改变原来的数据，所以必定会刷新缓存! 查询不同的Mapper.xml 手动清理缓存：sqlSession.clear() 二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存·基于namespace级别的缓存，一个名称空间，对应一个二级缓存;·工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中; 如果当前会话关闭了，这个会话对应的一级缓存就没了;但是我们想要的是，会话关闭了—级缓存中的 数据被保存到二级缓存中; 新的会话查询信息，就可以从二级缓存中获取内容; 不同的mapper查出的数据会放在自己对应的缓存(map)中; 步骤： 开启全局缓存 12&lt;!-- 显式开启全局缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; 在要使用二级缓存的Mapper中开启 12345&lt;cache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/&gt; 测试：注意要使用实体类序列化（implements Serializable），否则会报错。 小结： 只要开启了二级缓存，在同一个Mapper下就有效 所有的数据都会先放在一级缓存中; 只有当会话提交，或者关闭的时候，才会提交到二级缓冲中!","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://brillianttt.gitee.io/tags/Spring/"}]},{"title":"mysql+java+jdbc","slug":"mysql-java-jdbc","date":"2022-03-12T13:37:53.000Z","updated":"2022-03-12T13:39:58.741Z","comments":true,"path":"2022/03/12/mysql-java-jdbc/","link":"","permalink":"https://brillianttt.gitee.io/2022/03/12/mysql-java-jdbc/","excerpt":"","text":"JDBC连接Mysql数据库例子1","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://brillianttt.gitee.io/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"https://brillianttt.gitee.io/tags/JDBC/"},{"name":"MySQL","slug":"MySQL","permalink":"https://brillianttt.gitee.io/tags/MySQL/"}]},{"title":"Java集合","slug":"Java集合","date":"2022-03-09T04:06:19.657Z","updated":"2022-03-09T07:57:11.835Z","comments":true,"path":"2022/03/09/Java集合/","link":"","permalink":"https://brillianttt.gitee.io/2022/03/09/Java%E9%9B%86%E5%90%88/","excerpt":"","text":"Java集合的学习","categories":[],"tags":[{"name":"Java - 集合","slug":"Java-集合","permalink":"https://brillianttt.gitee.io/tags/Java-%E9%9B%86%E5%90%88/"}]},{"title":"JavaIO流","slug":"JavaIO流","date":"2022-03-08T07:19:36.118Z","updated":"2022-03-08T15:19:26.043Z","comments":true,"path":"2022/03/08/JavaIO流/","link":"","permalink":"https://brillianttt.gitee.io/2022/03/08/JavaIO%E6%B5%81/","excerpt":"","text":"文件字节流包含FileInputStream和FileOutputStream，使用这两个类文件读写速度较慢。 123456789101112131415161718public static void main(String[] args) throws Exception&#123; FileInputStream fis = new FileInputStream(\"D:/code/java/untitled/src/aaa.txt\"); byte[] data=new byte[1024]; int n; while((n=fis.read(data))!=-1)//循环读出数组，每次可读取1024位，当读取到末尾时返回-1 System.out.println(new String(data,0,n)); System.out.println(n); fis.close();//要记得关闭 //创建输出文件路径 FileOutputStream fos = new FileOutputStream(\"D:/code/java/untitled/src/bbb.txt\"); String string=\"hello world\"; fos.write(string.getBytes()); fos.close(); &#125; 文件字符流包含FileReader和FileWriter 123456789101112131415161718192021import java.io.*;import java.util.ArrayList;public class TestFaceElephant &#123; public static void main(String[] args)throws Exception &#123; //输出文件 FileWriter fw=new FileWriter(\"d://code/java/untitled/src/temp.txt\"); for (int i = 0; i &lt; 10; i++) &#123; fw.write(\"abc\\n\"); &#125; fw.close(); //读取文件 FileReader fr=new FileReader(\"d://code/java/untitled/src/temp.txt\"); int n; char[] data=new char[1024]; while((n=fr.read(data))!=-1)&#123; System.out.println(new String(data,0,n)); &#125; &#125;&#125; 对比文件字节流和字符流（复制文件）123456789101112131415161718192021222324252627//字节流的复制文件可以实现任意类型的文件的复制public static void main(String[] args) throws Exception&#123; FileInputStream fis = new FileInputStream(\"D:/code/java/untitled/src/aaa.txt\"); FileOutputStream fos = new FileOutputStream(\"D:/code/java/untitled/src/bbb.txt\"); byte[] data=new byte[1024]; int n; while((n=fis.read(data))!=-1)//循环读出数组，每次可读取1024位，当读取到末尾时返回-1 fos.write(data); System.out.println(\"复制完成\"); fis.close();//要记得关闭 fos.close(); &#125;//字符流的复制文件只能实现文本文件的复制public static void main(String[] args)throws Exception &#123; FileWriter fw=new FileWriter(\"d://code/java/untitled/src/temp.txt\"); FileReader fr=new FileReader(\"d://code/java/untitled/src/temp1.txt\"); int n; char[] data=new char[1024]; while((n=fr.read(data))!=-1) &#123;//还是循环读入文件 fw.write(data); &#125; fr.close(); fw.close();&#125; 字节缓冲流包含BufferedInputStream和BufferedOutputStream，通过内存建立缓冲区，使得读写更快。 12345678910111213141516171819202122232425public static void main(String[] args) throws Exception&#123; FileInputStream fis = new FileInputStream(\"D:/code/java/untitled/src/aaa.txt\"); BufferedInputStream bis = new BufferedInputStream(fis);//缓冲区找到内存 int n; while((n=bis.read())!=-1) System.out.println((char)n); byte[] data=new byte[1024]; n=0; while((n=bis.read())!=-1) System.out.println(new String(data,0,n)); bis.close(); FileOutputStream fos=new FileOutputStream(\"D:/code/java/untitled/src/bbb.txt\"); BufferedOutputStream bos = new BufferedOutputStream(fos); n=0; for (int i = 0; i &lt; 10; i++) &#123; bos.write(\"hello\".getBytes()); bos.flush();//刷新缓冲输出流到硬盘 &#125; bos.close();//调用close时也会内部调用flush方法，将缓冲输出流刷新到硬盘&#125; 字符缓冲流包含BufferedReader和BufferedWriter，支持高效读写、按行读写、输入换行符。 12345678910111213141516171819202122232425262728293031public static void main(String[] args)throws Exception &#123; FileReader fr=new FileReader(\"d://code/java/untitled/src/temp1.txt\"); BufferedReader br=new BufferedReader(fr); int n; //第一种读取方式 char[] data=new char[1024]; while((n=br.read(data))!=-1) &#123; System.out.println(new String(data,0,n)); &#125; //第二种读取方式:按行读写 String line=null; while((line=br.readLine())!=null) System.out.println(line); fr.close(); br.close(); FileWriter fw=new FileWriter(\"d://code/java/untitled/src/temp.txt\"); BufferedWriter bw=new BufferedWriter(fw); for (int i = 0; i &lt; 10; i++) &#123; bw.write(\"hello java\");//字符流，不用转为byte bw.newLine();//输入一个换行符 bw.flush(); &#125; fw.write(data); bw.close();&#125; 对象流包含ObjectOutputStream和ObjectInputStream ObjectOutputStream首先创建一个学生类： 123456789101112131415161718import java.io.Serializable;//注意此处的Serializable，要想实现序列化，需要实现Serializable接口public class Student implements Serializable &#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 然后主类要这么写： 123456789101112131415import java.io.*;public class TestFaceElephant &#123; public static void main(String[] args)throws Exception &#123; FileOutputStream fis = new FileOutputStream(\"D:/code/java/untitled/src/stu.txt\"); ObjectOutputStream oos = new ObjectOutputStream(fis);//缓冲区找到内存 Student stu1=new Student(\"stu1\",20); Student stu2=new Student(\"stu2\",20); Student stu3=new Student(\"stu3\",20); oos.writeObject(stu1); oos.writeObject(stu2); oos.writeObject(stu3); oos.close(); &#125;&#125; ObjectOutputStream主类这么写： 1234567891011121314151617181920import java.io.*;public class TestFaceElephant &#123; public static void main(String[] args)throws Exception &#123; //创建对象流 FileInputStream fos = new FileInputStream(\"D:/code/java/untitled/src/stu.txt\"); ObjectInputStream ois=new ObjectInputStream(fos); //反序列化 Student stu1= (Student) ois.readObject();//依次读取一个对象 Student stu2= (Student) ois.readObject(); Student stu3= (Student) ois.readObject(); //关闭 ois.close(); System.out.println(stu1.toString()); System.out.println(stu2.toString()); System.out.println(stu3.toString()); &#125;&#125; 如果要定义多个对象，则可以使用ArrayList进行对象： 12345678910111213//读入// Student stu1=new Student(\"stu1\",20);// Student stu2=new Student(\"stu2\",20);// Student stu3=new Student(\"stu3\",20);// ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;();// students.add(stu1);// students.add(stu2);// students.add(stu3);// oos.writeObject(students);//读出//ArrayList&lt;Student&gt; students=(ArrayList&lt;Student&gt;) ois.readObject();// System.out.println(students.toString()); PrintWriter封装了print() / println() 方法 支持写入后换行 支持数据原样打印 1234567891011psvm(String[] args)&#123; // 1 创建打印流 PrintWriter pw = new PrintWriter(\"..\"); // 2 打印 pw.println(12); pw.println(true); pw.println(3.14); pw.println('a'); // 3 关闭 pw.close();&#125; 转换流桥转换流 InputStreamReader / OutputStreamWriter 可将字节流转换为字符流 可设置字符的编码方式 1234567891011121314151617181920212223242526psvm(String[] args) throws Exception&#123; // 1 创建InputStreamReader对象 FileInputStream fis = new FisInputStream(\"..\"); InputStreamReader isr = new InputStreamReader(fis, \"utf-8\"); // 2 读取文件 int data = 0; while((data = isr.read()) != -1)&#123; sout((char)data); &#125; // 3 关闭 isr.close();&#125;psvm(String[] args) throws Exception&#123; // 1 创建OutputStreamReader对象 FileOutputStream fos = new FisOutputStream(\"..\"); OutputStreamWRITER osw = new OutputStreamReader(fos, \"utf-8\"); // 2 写入 for(int i = 0; i &lt; 10; i ++)&#123; osw.write(\"写入内容\"); osw.flush(); &#125; // 3 关闭 osw.close();&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://brillianttt.gitee.io/tags/Java/"},{"name":"IO流","slug":"IO流","permalink":"https://brillianttt.gitee.io/tags/IO%E6%B5%81/"}]},{"title":"数据可视化","slug":"数据可视化","date":"2021-09-11T13:43:10.000Z","updated":"2022-03-08T13:37:38.390Z","comments":true,"path":"2021/09/11/数据可视化/","link":"","permalink":"https://brillianttt.gitee.io/2021/09/11/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/","excerpt":"","text":"SVG基础首先是基本的图像绘制： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset='UTF-8'&gt; &lt;title&gt;SVG Basic Graphics&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width='1200' height='800'&gt; &lt;!--矩形--&gt; &lt;rect width='200' height='100' x='20' y='20' style='fill:rgb(161, 39, 98);stroke:blue;stroke-width:4' /&gt; &lt;!--rx和ry属性可使矩形产生圆角--&gt; &lt;rect width='200' height='100' x='250' y='20' rx='20' ry='10' style='fill:red;stroke:blue;stroke-width:4; opacity: 0.2;' /&gt; &lt;!--圆--&gt; &lt;circle cx='100' cy='280' r='80' style='fill:limegreen' /&gt; &lt;!--椭圆,RX属性定义的水平半径,RY属性定义的垂直半径--&gt; &lt;ellipse cx='330' cy='280' rx='100' ry='80' style='fill:orange' /&gt; &lt;!--直线--&gt; &lt;line x1='0' x2='600' y1='0' y2='360' style='stroke:#000;stroke-width:4' /&gt; &lt;!--多边形,points属性定义多边形每个角的x和y坐标--&gt; &lt;polygon points='100,20 20,90 20,200 150,100' style='fill:green;stroke:orange;stroke-width:4' /&gt; &lt;!--文本--&gt; &lt;text x='160' y='200' font-size='55'&gt; Hello, D3! &lt;/text&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 然后是利用transform对图像进行伸缩变换以及旋转等操作： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset='UTF-8'&gt; &lt;title&gt;SVG Transforms&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width='1200' height='800'&gt;&lt;!-- 此处设置画布大小--&gt; &lt;rect width='200' height='100' x='20' y='20' style='fill:none; stroke:black; stroke-width:6' /&gt;&lt;!--style设置风格，stroke表示边框颜色，stroke-width表示边框宽度--&gt; &lt;rect width='200' height='100' x='20' y='20' style='fill:none; stroke:blue; stroke-width:6' transform=' rotate(-90,200,200) translate(200 200) scale(1 0.5 )' /&gt; &lt;!--此处的rotate中的三个参数分别为旋转的角度和旋转中心的横纵坐标（另外，在SVG中的坐标向下和向右延伸分别为y、x），scale中的参数表示图形放大的倍数，此处要注意是放大原图像，如果先旋转再放大，放大的也还是原图向，可能x、y会相反--&gt; &lt;rect width='200' height='100' x='20' y='20' style='fill:none; stroke:green; stroke-width:6' transform=' translate(200 200) rotate(-90,200,200) scale(1 0.5)' /&gt; &lt;!-- transform='translate(200 200) rotate(-90 200 200) scale(1 0.5)' --&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 再接下来是对SVG中path的学习： 123456789101112131415161718192021222324252627&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset='UTF-8'&gt; &lt;title&gt;SVG:path&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width='1200' height='800'&gt; &lt;!-- 端点 --&gt; &lt;circle cx='150' cy='350' r='20' fill='green' /&gt; &lt;circle cx='550' cy='350' r='20' fill='green' /&gt; &lt;!-- 控制点 --&gt;&lt;!--这个控制点就像是太阳，曲线是向日葵，曲线向着控制点的方向偏转--&gt; &lt;circle cx='30' cy='50' r='10' fill='blue' /&gt; &lt;!--二次贝塞尔曲线--&gt;&lt;!--d中的M150，350表示起始点，中间两个参数表示控制点，最后的两个参数表示曲线终点--&gt; &lt;path d='M150 350 Q30 50 550 350' stroke='red' stroke-width=4 fill='none' /&gt; &lt;path d='M150 350 Q30 50 550 350' stroke='green' stroke-width=4 fill='none' transform='scale(0.5,0.5)' /&gt; &lt;path d='M150 350 Q30 50 550 350' stroke='blue' stroke-width=4 fill='none' transform='translate(300,200)' /&gt; &lt;path d='M150 350 Q30 50 550 350' stroke='red' stroke-width=4 fill='none' opacity=0.5 transform='rotate(-30)' /&gt; &lt;path d='M150 350 Q30 50 550 350' stroke='orange' stroke-width=4 fill='none' opacity=0.5 transform='rotate(90 200 200)' /&gt; &lt;!--opacity表示图像的透明度--&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"SVG","slug":"SVG","permalink":"https://brillianttt.gitee.io/tags/SVG/"},{"name":"D3","slug":"D3","permalink":"https://brillianttt.gitee.io/tags/D3/"}]},{"title":"Python+Excel学习","slug":"Python+Excel学习笔记","date":"2021-04-29T08:30:00.000Z","updated":"2021-05-02T13:50:17.438Z","comments":true,"path":"2021/04/29/Python+Excel学习笔记/","link":"","permalink":"https://brillianttt.gitee.io/2021/04/29/Python+Excel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Excel文件的导入与指定路径保存这是一个测试代码，大致内容就是在qt界面添加一个button，用户在点击button后可以选择路径导入和导出文件 123456789101112131415161718192021222324252627282930313233343536# -*- coding: utf-8 -*-import sysfrom PySide2.QtCore import *from PySide2.QtGui import *from PySide2.QtWidgets import *import text1import demoExcelclass Ui_Form(object): def setupUi(self, Form): if not Form.objectName(): Form.setObjectName(u\"Form\") Form.resize(713, 557) self.pushButton = QPushButton(Form) self.pushButton.setObjectName(u\"pushButton\") self.pushButton.setGeometry(QRect(30, 100, 200, 50)) self.pushButton.clicked.connect(self.openfile) self.retranslateUi(Form) QMetaObject.connectSlotsByName(Form) # setupUi def openfile(self): filePath = QFileDialog.getExistingDirectory(self.pushButton,\"选择图片文件路径\") demoExcel.creatExcel(filePath) print(filePath) def retranslateUi(self, Form): Form.setWindowTitle(QCoreApplication.translate(\"Form\", u\"Form\", None)) self.pushButton.setText(QCoreApplication.translate(\"Form\", u\"选择图片文件路径\", None)) # retranslateUiif __name__ == '__main__': app = QApplication(sys.argv) mainW = QMainWindow() ui = text1.Ui_Form() ui.setupUi(mainW) mainW.show() sys.exit(app.exec_()) 1self.pushButton.clicked.connect(self.openfile)这句意思是在点击button后，调用openfile方法（函数），这个函数调用了另一个文件，这个文件主要实现的是创建一个Excel表格，然后将用户选择的路径传入该文件，并将表格保存到该文件中。 1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/env python# coding=utf-8from xlwt import *def creatExcel(filePath): #需要xlwt库的支持 #import xlwt file = Workbook(encoding = 'utf-8') #指定file以utf-8的格式打开 table = file.add_sheet('aaa') #指定打开的文件名 data = &#123;\\ \"1\":[\"张三\",150,120,100],\\ \"2\":[\"wang\",90,99,95],\\ \"3\":[\"wu\",60,66,68]\\ &#125; #字典数据 ldata = [] num = [a for a in data] #for循环指定取出key值存入num中 num.sort() #字典数据取出后无需，需要先排序 for x in num: #for循环将data字典中的键和值分批的保存在ldata中 t = [int(x)] for a in data[x]: t.append(a) ldata.append(t) for i,p in enumerate(ldata): #将数据写入文件,i是enumerate()函数返回的序号数 for j,q in enumerate(p): print(i,j,q) table.write(i,j,q) file.save(filePath+'/'+'aaa.xls') #这句是保存Excel表格的语句，filePath是传入的路径，aaa.xls是文件名称，这个在后期可以再传入一个参数，将aaa替换为用户设置的名称 Qt Designr设置文本框提示性语言在qt designer中，文本框为line edit和text edit ，二者在被输入文本前，都可设置提示框，就在其属性框的placeholderText后添加提示性语言即可。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://brillianttt.gitee.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://brillianttt.gitee.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"学习深度学习","slug":"学习深度学习","date":"2021-04-10T15:15:20.000Z","updated":"2021-04-13T17:01:16.173Z","comments":true,"path":"2021/04/10/学习深度学习/","link":"","permalink":"https://brillianttt.gitee.io/2021/04/10/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"知网关于深度学习的论文整理《基于深度学习的汉字识别方法研究综述》传统汉字识别方法 图像预处理：在图像分析中 ，获取的图像质量的高低会极大地影响识别的精度。预处理一般包括了灰度化、直方图均衡化 、倾斜检测与校正 、行与字切分等操作方法。 文本版面分析：通常对版面处理分为版面分析、版面理解和版面重构。主要从印刷版面的结构来分析 ，根据连通域大小或像素点分布等特征 ，将属性标记出来。然后是版面理解，根据版面分析时记载的连通域位置信息，确定连通域归属的序列 ，最后进行版面重构复原 。 字符切割：将汉字信息进行逐行切割 ，再对逐行信息进行逐字切割。 归一化处理：更加准确地进行后续字符识别。 特征提取：得到每个字符的特征描述。 字符的单字识别：依据每一个字符的特点进行预分类 ，产生候选字符集 ，再从候选字符集鉴别出待定字符。 纠错处理：通过上下文关系来对识别的结果进行纠错处理。 输出识别结果。 基于深度学习的汉字识别方法目前基于深度学习的文字识别主要有两种方案 ，即文字检测加汉字识别的方法 ，分两步依次进行。而另一种则是直接训练一个端到端的模型同时完成文字检测和文字识别。 经典目标检测算法在介绍汉字识别算法之前,首先引入几种在目标检测领域应用非常广泛的经典模型,目前主流的文字识别算法大多基于这些优化改进而来。FCNN network是由美国加州大学伯克利分校的Long 等人于2015年8月在CVPR上提出的一种图像分割的算法,主要结构如图所示： 该算法首次将端到端的卷积网络推广到语义分割的任务中 ，提出了完全卷积网络的概念，可以接受任意尺寸的输入图像，用反卷积层来上采样最后卷积层的feature map，可以恢复原图像的大小并完成对每个像素的预测 ，同时保留原图像的空间信息。 文字检测识别算法文字识别端到端的场景汉字识别研究前景与应用​ 如何提高汉字的识别率仍是目前的研究热点，现有的汉字识别还只对背景简单的印刷体文字取得较好的效果,比如名片识别、证件识别等。但对于一些复杂的场景,如自然场景图片中光照、文字的大小、样式使得汉字识别处理问题极具挑战性,现有的技术还远远没有达到令人满意的程度。​ 当前汉字识别技术的应用领域很广泛”,特别是在无人车、智慧医疗、自动化办公、金融欺诈检测、恐怖主义威胁级别检测等领域发挥着举足轻重的作用。例如用OCR进行文稿的识别录入,虽然国内外市场中已有很多这样的产品,但这类技术依然不算成熟,有表格、图形的文档常常需要手工干预。对图形、文本等混排的复杂版面进行自动切分的汉字识别系统也是目前研究的重点之一,特别是应用在对出版刊物的识别上,方便人们快速进行信息录入。还有对卡证文字的识别,如对身份证、银行卡、名片等识别,分别应用于用户注册、银行开户、交通出行等多种场景中。​ 汉字识别系统还可广泛应用于政府、税务、医疗、金融等各行业的各种表格数据的输入和处理,这些领域常常需要统计大量的人员数据信息,有些还是手写完成的。自动文字识别,信息录入将极大地提高工作效率。 名词解释卷积神经网络卷积神经网络（Convolutional Neural Networks, CNN）是一类包含卷积计算且具有深度结构的前馈神经网络（Feedforward Neural Networks），是深度学习（deep learning）的代表算法之一 。卷积神经网络具有表征学习（representation learning）能力，能够按其阶层结构对输入信息进行平移不变分类（shift-invariant classification），因此也被称为“平移不变人工神经网络（Shift-Invariant Artificial Neural Networks, SIANN）” 语义分割神经网络中“端到端”思想​ 深度学习的一个重要思想就是“端到端”的学习方式，属表示学习的一种。这是深度学习区别于其他机器学习算法的最重要的一个方面。其他机器学习算法，如特征选择算法、分类器算法、集成学习算法等，均假设样本特征是给定的，并在此基础上设计具体的机器学习算法，在深度学习时代之前，样本表示基本都使用人工特征，人工特征的优劣往往在很大程度上决定了最终的任务精度​ 端到端的学习方式就是在整个学习流程中并不进行人为的子问题划分，而是完全交给深度学习模型直接学得从原始输入到期望输出的映射。相比分治策略，“端到端”的学习方式具有协同增效的优势，有更大可能获得全局最优解。​ 对于深度模型，其输入数据是未经任何人为加工的原始样本形式，后续则是堆叠在输入层上的众多操作层。这些操作层整体可被看做一个复杂的函数Fcnn，最终损失函数由数据损失和模型参数的正则化损失共同组成，深度模型的训练则在最终损失驱动下对模型进行参数更新，并将误差反向传播至网络各层。模型的训练过程可以简单抽象为从原始数据向最终目标的直接“拟合”，而中间的这些部件正起到了将原始数据映射为特征(即特征学习)，随后再映射为样本标记(即目标任务，如分类)的作用。下面是组成Fcnn的各个基本部件。 这里提到的基本部件，在这里给出了解释。","categories":[{"name":"学习","slug":"学习","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习 - 深度学习","slug":"学习-深度学习","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"高考招生考试报自动识别与格式化软件","slug":"高考招生考试报自动识别与格式化软件","date":"2021-04-09T08:29:55.000Z","updated":"2021-04-10T15:15:32.443Z","comments":true,"path":"2021/04/09/高考招生考试报自动识别与格式化软件/","link":"","permalink":"https://brillianttt.gitee.io/2021/04/09/%E9%AB%98%E8%80%83%E6%8B%9B%E7%94%9F%E8%80%83%E8%AF%95%E6%8A%A5%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"界面样式初步计划应有一下内容： 左上角地软件名称与软件界面的主体部分标识软件名称 待识别文件夹路径的选择按钮、待导出文件夹路径的选择按钮 （目前待处理的图片与已经提出去文字的图片效果的展示框——可视化界面） （已导出招生学校的各类信息输出——可视化界面）","categories":[{"name":"项目","slug":"项目","permalink":"https://brillianttt.gitee.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://brillianttt.gitee.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"写给学弟学妹的碎碎念","slug":"写给学弟学妹们的一封信","date":"2021-03-19T14:18:50.000Z","updated":"2021-03-20T11:11:50.747Z","comments":true,"path":"2021/03/19/写给学弟学妹们的一封信/","link":"","permalink":"https://brillianttt.gitee.io/2021/03/19/%E5%86%99%E7%BB%99%E5%AD%A6%E5%BC%9F%E5%AD%A6%E5%A6%B9%E4%BB%AC%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/","excerpt":"","text":"亲爱的学弟学妹们你们好： ​ 我叫马博宇，是宋老师带的上一届高中班级里的一名学生。十分荣幸能被宋老师邀请，和大家分享我在大学的生活。 ​ 先进行一个简短的自我介绍，我在四川的西南科技大学上学，大二计算机专业，高考理科538分，这个是当时学校里的展板展示的成绩： 简短介绍完毕，下面给大家分享一下美滋滋的大学生活😁 大学生的日常日常交往​ 去外地上学的好处是可以去逛学校所在城市的各种景点和商业街。虽然我所在的城市是绵阳，但是离成都很近，在节假日的时候经常可以来一场说走就走的旅行，去成都或者重庆耍耍。另一方面，在外地上学还可以认识许许多多不同地方的朋友。虽然我在四川上学，但是周围的同学们有相当一部分都是外地的同学，就比如我的舍友，有湖南长沙的，辽宁沈阳的、还有一个是四川达州的同学。五湖四海的朋友聚在一起，每天都有聊不完的话题，虽然我在大学还没怎么出去玩过，但是在他们的描述下，我总是忍不住想在下一个五一假期中，去他们家乡玩一玩。 ​ 在大学里，除了日常和同学的交往，耍个朋友（四川方言，内蒙话译为找个对象）也是很常见的啦，我。。。历经五年单身，终于也有幸在前几天脱单了。在大学里每天不会像高中一样，情侣们见到老师要躲着走，拉手手也要悄咪咪的，因为在大学中，恋爱应该也算是一门“必修课”，在自爱的同时学会去爱别人，和自己的那个ta共同走过大学四年生活是一件非常美好的事情💓 日常生活​ 在大学中，不会再有老师和家长督促我们的学习（真的，但是不学就会挂科，挂科就得重修），8课程也不会像高中一样设置的十分紧密（还是看学习的专业），在没课的时候可以睡到日上三竿（也是看学习的专业）。 ​ 大学里最常见的场景是什么呢，早晨八点上课，七点四十才起床，十分钟洗漱，剩下的十分钟先奔向食堂买早饭，再冲向教室准备上课。中午下课了大家一窝蜂的冲向食堂或者校外干饭，这个应该是每一个大学都会出现的经典场面了。 ​ 除此之外，每个大学中会有各种各样的社团和部门，也可以担任班委，我之前加入了我们学校的志愿服务团队，并且担任了班级的学习委员。平时，同学们在日常的学习之余可以经常参加社团和部门开展的/各种活动。就拿我自己做过的一些活动举几个栗子： 学校的青年志愿者协会和绵阳市志愿者联合开展的大型活动科博会志愿者： 还有幸近距离见到了李兰娟、董明珠、曹德旺、鲁健等一众大佬： 学校的冬树刷白活动： 四川省高水平足球赛志愿者： 绵阳科技馆讲解活动： “科技进青义”支教活动： 还有学院组织的篮球班赛： 日常学习​ 大学的学习不同于初高中，从学习内容来看，高中三年，只需学习九门课程，到了高二高三时候，就只剩下六门了；而大学四年需要学习共近百门基础课、公共课和专业课。从学习深度来看，高中虽然只有六门主要课程，但在高中时期需要对这六门课程的所有基础知识做到融汇贯通，这样才能达到高考考查的基本要求。从学习动力上看，高中时候大家会受到全方位的鼓舞，来自父母、老师、朋友、学长学姐甚至是许多陌生人的鼓励，而自己不仅为了来自亲朋好友的殷切期望，更为了自己高考考一个好成绩去上个好大学而不懈努力。在大学里就很少会有其他人的“唠叨”了，除了“挂科警告”之外可能很少会有其他事情逼着自己学习，所以在大学中的学习，更多的还是依靠自己的坚持不懈，靠目标驱动，为实现什么样的人生目标而去不懈努力。 ​ 在我大学一年多的时间里，通过认真的学习，考过了英语四六级，专业排名年级前20%，在去年六月通过了转专业面试，从电子信息工程专业转到了现在的计算机专业，学习我十分感兴趣的编程。目前在计算机学院的机器视觉实验室学习图像处理和文字识别方面的知识。 好的大学“好”在了哪里​ 这个问题在另一个视频中，你们的张帅学长对这个问题进行了很具体的描述，我在他的基础上举一个更加现实的栗子~ ​ 就拿我的学校西南科大和内大来作比较，我们学校是一所”双非“院校，内大是”211“。我和张帅两个人高考差了27分，同样是计算机专业，体现在学校的选择上的差距是十分明显的。对于大家最关心的”保研“名额，我所在的学院保研名额数量是全校较高的，每一百个同学，保研名额大概有3-5个，而内大其他专业的保研率为5%左右，像计算机专业这类热门专业，保研率在40%左右，内大基地班则能达到50%以上。在经费上，实验室拨的经费较少，大部分实验室的收入来源都是在外面的公司和企业接项目，同学们来做，而211学校对实验室的支持更大，会给予大量的经费用作实验室的发展。在奖学金上，除去国家和学校本身设置的几种奖学金，211学校会比普通双非一本得到更多的社会支持，会有更多的来自社会企业对优秀学生发展的支持，其中就包含了奖学金这一项。在大学中，学习好拿奖学金拿到手软不是一件开玩笑的事情。 ​ 上面说到的是几个具体的例子，实际上，211或985学校比其他本科优秀的地方远不止这些，更优秀的老师和同学、更好的学习和科研氛围、更加宽广的就业前景、还有更大的平台……这些普通学校所没有的或缺乏的东西，带给学生的好处和光环会让学生一生受用。 写在最后​ 宋老师让我们录视频的目的是激励大家摆脱现在的习气，以更加精神饱满的劲头，去面对还有一年多就要到来的高考。我没有很好的方式给大家鼓励，就给大家看一个我当时在高考成绩出来以后发的一个知乎吧，希望在一年多以后的高考，大家也能对自己的亲朋好友骄傲的说：我没有辜负我的高中三年，我用自己的努力和汗水，换来了我终身为之骄傲的好成绩！ 送给大家一句我很喜欢的话：乾坤未定，你我都是黑马。 这句话一直激励我在高三繁重的学业中前进，最终取得了很好的成绩，现在送给你们，也祝愿学弟学妹们能找到自己的发力点，在高中的最后一年里，听老师的话，做最充足的准备，去迎接高考😉 写在最后的最后​ 我的qq:2363255644大家如果有学习上的困扰，或者希望能再打打鸡血，可以在忙碌的一周中抽出周末空闲的时候找我聊天，我很愿意为大家提供力所能及的帮助。 ​ 再给大家分享一点日常照片（请不要care直男拍照~） ​ 毕业典礼时候拍的！！！真心感谢宋老师、魏老师还有其他各科老师在高中时候为我提供了无数的帮助，一遍又一遍的为我答疑解惑，真心感谢您们💓 再来张和魏老师拍的！ 再来长和张老师拍的😋(张老师不仅是良师益友，还是我的顶头上司，我高中是物理课代表hhhhh) 还有最好的朋友！最棒最优秀最努力最上进的张帅长大学士！！！ 再分享一张我们毕业以后一起玩耍的皂片 都是非常优秀非常上进的小伙伴呀~ ​ 谢谢大家看完~ 祝福你们！ ​ 你们的小学长 ​ 2021.3.19","categories":[{"name":"随笔","slug":"随笔","permalink":"https://brillianttt.gitee.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://brillianttt.gitee.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"QT的学习","slug":"QT的学习","date":"2021-03-09T03:22:40.000Z","updated":"2021-03-13T09:18:43.076Z","comments":true,"path":"2021/03/09/QT的学习/","link":"","permalink":"https://brillianttt.gitee.io/2021/03/09/QT%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"第零个QT程序下载安装配置好qt后，打开qt Creator，点击左上角的文件-&gt;新建文件或项目-&gt;QT Widgets Application，然后设置好文件名称，名称中不可以有中文出现，创建路径中也不可以出现中文，然后点击下一步，选择qmake，再下一步设置细节： 在Base class中可以选择QMainWindow，QWidget和QDialog三个类，默认创建窗口类；其中QWidget是另外两个类的基类，QMainWindow可以使用设计、debug等功能，QDialog是以对话框的形式展现出来界面。 下面的Generate form创建界面可以勾选，选上以后可以通过拖拽一些工具便捷的设计界面。 再次点击下一步，勾选Select all kits，并再次点击下一步。 在这一步中会出现一个”添加版本控制系统“，这个一般用在开发一些大型软件时用到，可以选用vss、svn、git等版本控制系统。 点击完成，结束创建。 于是我们得到了最开始的项目形态： 下面是main.cpp代码的具体介绍 1234567891011121314#include \"widget.h\"#include &lt;QApplication&gt;//包含一个应用程序类的头文件//main程序入口 argc命令行变量的数量 argv命令行变量的数组int main(int argc, char *argv[])&#123; //a为应用程序对象，在qt中，应用程序对象有且只有一个 QApplication a(argc, argv); //窗口对象 myWidget父类-&gt;QWidget Widget w; //窗口对象，默认不会显示，必须调用show方法显示窗口 w.show(); //让程序对象进入消息循环，如同c程序中的system(\"pause\")使得窗口不会一闪而过一样，代码阻塞到当前行 return a.exec();&#125; 对qt文件的认识一些常用快捷键12345678910111213//命名规范：//类名首字母大写，单词和单词之间首字母大写//函数名、变量名称首字母小写//快捷键：//注释： ctrl+///运行： ctrl+r//编译： ctrl+b//查找： ctrl+f//整行移动： ctrl+shift+↑或者↓//帮助文档: F1或者单独打开帮助文档：D:\\AppProgram\\qt\\qt5.12.5\\5.12.5\\mingw73_64\\bin assistant.exe//自动对齐： ctrl+i//同名的.h和.cpp切换： F4 对.pro文件的认识.pro文件为项目的工程文件，pro是project的缩写，下面是.pro文件的基本代码及注释： 123456789101112131415161718192021222324252627282930313233QT += core gui //qt包含的模块 gui模块是qt的基本模块之一，后文有图会大致介绍greaterThan(QT_MAJOR_VERSION, 4): QT += widgets//大于4版本以上 包含widget模块CONFIG += c++11//在qt中的注释是以#开头的，而不是//# The following define makes your compiler emit warnings if you use# any Qt feature that has been marked deprecated (the exact warnings# depend on your compiler). Please consult the documentation of the# deprecated API in order to know how to port your code away from it.DEFINES += QT_DEPRECATED_WARNINGS# You can also make your code fail to compile if it uses deprecated APIs.# In order to do so, uncomment the following line.# You can also select to disable deprecated APIs only up to a certain version of Qt.#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 # disables all the APIs deprecated before Qt 6.0.0SOURCES += \\ main.cpp \\ //源文件 widget.cppHEADERS += \\ //头文件 widget.hFORMS += \\ widget.uiTARGET = 01_firstPROJET //生成的.exe文件的名称,修改名称直接可以在这里修改 下面有单独运行.exe文件的方法TEMPLATE = app //模板 应用程序模板 全称为Application# Default rules for deployment.qnx: target.path = /tmp/$$&#123;TARGET&#125;/binelse: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin!isEmpty(target.path): INSTALLS += target qt的主要模块 最近主要学习widgets、core和gui模块。 单独运行.exe文件的方法在编译运行后，在qt界面选择工程文件，右键选择在Explorer中显示，打开项目的文件夹位置，然后回退找到build-untitled7-Desktop_Qt_5_12_5_MinGW_64_bit-Release这个文件（这里是以release版本编译的，debug版本暂时没有试过），然后点击选择release文件找到.exe文件，双击打开。 ​ 然后！就会发现大概率打不开（第一次用这个方法的时候），继而通过搜索引擎解决各种问题，其中有移动libstdc++-6.dll文件、移动libgcc_s_seh-1.dll文件以及配置系统变量等方法，但在我的电脑上都无法成功解决问题，最后找到了这种方法，简简单单解决。 .h文件123456789101112131415161718192021#ifndef WIDGET_H //包含头文件#define WIDGET_H#include &lt;QWidget&gt; //包含一个头文件QWidget窗口类QT_BEGIN_NAMESPACEnamespace Ui &#123; class Widget; &#125;QT_END_NAMESPACEclass Widget : public QWidget //从QWidget中继承&#123; Q_OBJECT //Q_OBJECT宏，允许类中使用信号和槽的机制public: Widget(QWidget *parent = nullptr);//构造函数，默认值为0 ~Widget();//析构函数private: Ui::Widget *ui;&#125;;#endif // WIDGET_H .cpp文件widget.cpp文件： 1234567891011121314#include \"widget.h\"#include \"ui_widget.h\"Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget)&#123; ui-&gt;setupUi(this);&#125;Widget::~Widget()&#123; delete ui;&#125; 第一个QT程序添加一个按钮用到的API123456789101112131415161718192021222324252627282930313233#include \"widget.h\"#include \"ui_widget.h\"#include \"qdebug.h\"#include &lt;QPushButton&gt; //按钮控件的头文件Widget::Widget(QWidget *parent) : QWidget(parent)&#123; // qDebug()&lt;&lt;\"a\"; QPushButton * btn=new QPushButton;//新建一个按钮对象 btn-&gt;show();//show函数一般是作为顶层方式弹出窗口控件，如果这样调用会出来两个框框 //所以需要让btn对象依赖在Widget中 btn-&gt;setParent(this); //显示文本 btn-&gt;setText(\"第一个按钮\"); QPushButton *btn2=new QPushButton(\"第二个按钮\",this);// btn2-&gt;setParent(this);// btn2-&gt;setText(\"第二个按钮\"); //移动窗口 btn2-&gt;move(100,100); //重置窗口大小 resize(800,600); //设置窗口标题 setWindowTitle(\"第一个窗口\"); //设置窗口固定大小 setFixedSize(1600,600);//函数原型为void setFixedSize(int w, int h);第一个参数为宽，第二个为高 setFixedWidth(1000); setFixedHeight(600);&#125;Widget::~Widget()&#123;&#125; 对象树当创建的对象再堆区的时候，如果指定的父亲是QObject派剩下来的类或者QObject子类派剩下来的类，可以不用管理释放的操作，对象将会被放入到对象树中。这在一定程度上简化了内存的回收机制。 举个栗子，在头文件部分新添加一个c++ class文件new一个按钮时，设定父类为qwidget（qpushbuton是它的子类），btn-&gt;setParent(this)把btn设置到对象树中。在QObject释放时，它会释放掉对象树中所有的资源。所以即使申请的时堆上的资源，也无需我们自己手动释放。 QT中的坐标系以左上角为原点(0,0)，X向左增加，Y向下增加。 对于嵌套窗口，其坐标是相对于父窗口来说的。","categories":[],"tags":[{"name":"QT","slug":"QT","permalink":"https://brillianttt.gitee.io/tags/QT/"}]},{"title":"QT+opencv+vs从安装到实现一个小软件","slug":"QT+opencv+vs从安装到实现一个小软件","date":"2020-12-15T13:51:26.000Z","updated":"2020-12-18T12:15:08.633Z","comments":true,"path":"2020/12/15/QT+opencv+vs从安装到实现一个小软件/","link":"","permalink":"https://brillianttt.gitee.io/2020/12/15/QT+opencv+vs%E4%BB%8E%E5%AE%89%E8%A3%85%E5%88%B0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B0%8F%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"QT下载与安装除了官网可以下载，还可以在国内镜像源下载qt，比如清华大学镜像源也可以下载。 版本我选择的是5.12，在镜像源里选择qt/archive/qt/5.12/5.12.0/qt-opensource-windows-x86-5.12.0.exe,之后下载即可。 下载安装完qt后我们需要再在vs上下载一个插件,路径为:扩展-&gt;管理扩展-&gt;联机-&gt;右侧搜索qt,之后下载qt visual studio tools;如果下载时进度条一直没有前进,则可在搜索到qt后点击右侧的详细信息进入官网下载插件。 之后教程见这里。安装后试运行可能会出一个bug：无法打开 源 文件 “ui_QtGuiApplicationx.h”，这个错误的解决见这里和这里。 opencv环境配置在下载好opencv后，并配置完系统的环境变量后，每新建一个工程都需要重新配置一遍opencv的环境，虽然有些麻烦，但熟悉流程后配环境还是很简单的事情。这是我最开始配置环境时参考的博客。 第一步在新建了一个qt gui application以后,打开解决方案资源管理器,按住Alt+Enter打开属性页 第二步找到vc++部分的包含目录和库目录 其中，包含目录添加opencv文件中的如下三个目录（根据自己opencv的安装路径添加） E:\\OpenCV\\opencv\\build\\include ​ E:\\OpenCV\\opencv\\build\\include\\opencv ​ E:\\OpenCV\\opencv\\build\\include\\opencv2 之后填写库目录，如E:\\OpenCV\\opencv\\build\\x64\\vc14\\lib（同样按照自己的路径进行填写） 下面再再属性页中找到链接器中的输入部分，对附加依赖项进行填写，这部分的内容要查看上面库目录路径中的文件进行参考，如我的是opencv_world450d.lib,文件名称如果加d则为debug版本使用的，入如果是release版本则要选择不加d的文件。 第三步任意写一段代码测试一下是否能运行成功。 qt+opencv在新建完qt项目、配置完opecncv的环境之后，我们开始做一个简单的小软件出来！ 新建文件首先，打开解决方案资源管理器，双击打开.ui文件，进入设计师界面。 然后依次找到push button、scroll area和label，拖拽进入工作区，位置任意定义。 在右侧对象查看器中修改对应部分对象的名称 接下来要写对应的代码。 头文件编辑首先要写.h文件， 代码如下，如果按格式on_控件名_clicked命名函数，QT会默认完成函数和按钮动作的链接，如果不这样命名的话就必须得去设置信号槽函数。 12345678910111213141516171819202122232425262728293031#pragma once#include &lt;QtWidgets/QMainWindow&gt;#include\"ui_QtGuiApplication1.h\"#include&lt;QGraphicsScene&gt; #include&lt;QGraphicsView&gt; //graphicsview类#include&lt;opencv2\\imgproc\\imgproc.hpp&gt;#include &lt;opencv2\\core\\core.hpp&gt;#include &lt;opencv2\\highgui\\highgui.hpp&gt; //opencv申明#include &lt;qfiledialog.h&gt; //getopenfilename 类申明#include &lt;qlabel.h&gt; //label类using namespace cv;class QtGuiApplication1 : public QMainWindow&#123; Q_OBJECTpublic: QtGuiApplication1(QWidget *parent = Q_NULLPTR); ~QtGuiApplication1(); private slots: void on_Progress_clicked(); void on_OpenFig_clicked(); private: Ui::QtGuiApplication1Class ui; Mat image;//mat类声明 QLabel* label; QLabel* label_2;&#125;; 上面的函数名称要对照自己的代码进行修改。 之后编辑信息槽，这一步的目的是使得按钮的动作和函数连接起来。（长按拖动到两个按钮上) 在配置连接部分选择clicked(),进行编辑，添加槽on_OpenFig_clicked()和on_Progress_clicked()。 完成连接后结果如上图，保存后关闭ui即可。 cpp文件编辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include \"QtGuiApplication1.h\"#include &lt;opencv2/imgproc/types_c.h&gt;#include&lt;opencv2\\imgproc\\imgproc.hpp&gt;#include &lt;opencv2\\core\\core.hpp&gt;using namespace cv;using namespace std;QtGuiApplication1::QtGuiApplication1(QWidget *parent) : QMainWindow(parent)&#123; ui.setupUi(this); &#125;QtGuiApplication1::~QtGuiApplication1()&#123; &#125;void QtGuiApplication1::on_OpenFig_clicked()&#123; QString filename; filename = QFileDialog::getOpenFileName(this, tr(\"Sele\"), \"\", tr(\"Images (*.png *.bmp *.jpg *.tif *.GIF )\")); if (filename.isEmpty()) &#123; return; &#125; else &#123; string str = filename.toStdString(); // 将filename转变为string类型； image = imread(str); //image=imread(fileName.toLatin1().data); cvtColor(image, image,CV_BGR2RGB);// CV_BGR2RGB cv::resize(image, image, Size(300, 200)); QImage img = QImage((const unsigned char*)(image.data), image.cols, image.rows,image.step, QImage::Format_RGB888); label = new QLabel(); label-&gt;setPixmap(QPixmap::fromImage(img)); label-&gt;resize(QSize(img.width(), img.height())); ui.scrollArea-&gt;setWidget(label); &#125;&#125;void QtGuiApplication1::on_Progress_clicked()&#123; Mat image1; flip(image, image1,3);//反转函数 0 上下反转；整数，水平发转；负数，水平垂直均反转 QImage img1 = QImage((const unsigned char*)(image1.data), image1.cols, image1.rows, image1.step,QImage::Format_RGB888); label_2 = new QLabel(); label_2-&gt;setPixmap(QPixmap::fromImage(img1)); label_2-&gt;resize(QSize(img1.width(), img1.height())); ui.scrollArea_2-&gt;setWidget(label_2);&#125; 大功告成✌，运行结果示例： 常见问题在刚完成.cpp文件的书写时，常会报错这个错：E0135 class “Ui::QtGuiApplication1Class” 没有成员 “xxx”，这是因为。。。（好像是因为反应比较慢），我们需要先编译一次（ctrl+f5也行），然后在解决方案资源管理器-&gt;右键点击自己的项目-&gt;重新扫描解决方案，这个错就被消除了。","categories":[],"tags":[{"name":"QT","slug":"QT","permalink":"https://brillianttt.gitee.io/tags/QT/"}]},{"title":"博客的音乐功能设置","slug":"博客的音乐功能设置","date":"2020-12-11T12:09:27.504Z","updated":"2020-12-17T03:28:04.312Z","comments":true,"path":"2020/12/11/博客的音乐功能设置/","link":"","permalink":"https://brillianttt.gitee.io/2020/12/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%9F%B3%E4%B9%90%E5%8A%9F%E8%83%BD%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"今天刚开始设置博客的音乐组件，留下一点小笔记备用😁首先，音乐的获取可以通过这两个方式：1、可以在网易云音乐上直接搜索喜欢的歌曲，找到外部链接2、自己创建网易云歌单，添加喜欢的歌曲，再找到自己歌单的外部链接之后再主题在文件夹下搜索music，找到music.ejs文件,在其中将”iframe”处替换成刚找到链接。最后将主题的yml文件中的#music部分做修改，更改http链接与音乐id就大功告成啦！(ps：在代码中修改各项参数可以更改音乐播放器的大小，将宽度和高度改为0或1可以隐藏音乐播放器，做到完完全全的“背景音乐”)","categories":[{"name":"博客开发","slug":"博客开发","permalink":"https://brillianttt.gitee.io/categories/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"敲代码时遇到的常见bug及解决方法","slug":"敲代码时遇到的常见bug及解决方法","date":"2020-11-22T09:21:19.000Z","updated":"2020-11-26T13:41:27.102Z","comments":true,"path":"2020/11/22/敲代码时遇到的常见bug及解决方法/","link":"","permalink":"https://brillianttt.gitee.io/2020/11/22/%E6%95%B2%E4%BB%A3%E7%A0%81%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%B8%B8%E8%A7%81bug%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"Android Studio类错误ndk配置清戳这里 配置NDK遇到的错误在下载ndk成功后如果没有配置环境，会报如下错误： 1Caused by: org.gradle.api.InvalidUserDataException: NDK not configured 这里是解决办法","categories":[],"tags":[{"name":"BUG解决","slug":"BUG解决","permalink":"https://brillianttt.gitee.io/tags/BUG%E8%A7%A3%E5%86%B3/"}]},{"title":"OpenCV学习中的参考博客","slug":"OpenCV学习中的参考博客","date":"2020-11-19T13:07:16.000Z","updated":"2020-11-26T13:41:27.673Z","comments":true,"path":"2020/11/19/OpenCV学习中的参考博客/","link":"","permalink":"https://brillianttt.gitee.io/2020/11/19/OpenCV%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"下面是一些个人认为讲的很好的一些博客，对自己在OpenCV学习上有很大的帮助 图片边缘填充","categories":[],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://brillianttt.gitee.io/tags/OpenCV/"}]},{"title":"图像处理作业","slug":"图像处理作业","date":"2020-11-06T15:00:43.000Z","updated":"2020-11-08T11:46:07.462Z","comments":true,"path":"2020/11/06/图像处理作业/","link":"","permalink":"https://brillianttt.gitee.io/2020/11/06/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"第一次作业内容如图：在刚留这个作业时学长给了一些解题的思路，快到作业截止提交的时间才做出来。。。 言归正传，这道题的思路比较简单，就是把图片先进行灰度化和二值化的处理，然后再将二值图中的黑色部分找到，将原图中的蓝色部分变为黑色，最后裁剪就可以了，但中间有一些小坑，在最开始做的时候出现并困扰了我挺长时间，之前得到的图片是这个样子的：这是因为在处理时没有将图片进行二值化处理，而图片本身像素不够高，很多地方的颜色都有细微的差别，因而在直接暴力将背景中的蓝色修改为黑色是不可行的，会出现“其岸势犬牙差互”的情况。 经过学长提醒，我后来的思路是这样子的： 1、对图片进行灰度化、二值化处理，并将处理后的图片保存到另一个变量part中。 2、对二值图part进行遍历，找到图片🐕的四个边缘值（最上、下、左、右）的坐标，然后用rect这个函数对二值图和原图进行裁剪。 3、对二值图再次进行遍历，在二值图的某像素点为黑色时，将原图上的对应像素点也变为黑色 经过这几个步骤，即可得到想要答案。 源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include&lt;iostream&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include \"opencv2/imgproc/imgproc.hpp\" #include &lt;opencv2/core/core.hpp&gt; using namespace std;using namespace cv; int main()&#123; Mat img,part1,part,src=imread(\"D:/code/dog.png\"); cvtColor(src,part1, COLOR_BGR2GRAY);//灰度化 threshold(part1, part, 175, 255, THRESH_BINARY);//二值化 imshow(\"二值图\",part); imwrite(\"D:/code/doggle.png\", part); part = imread(\"D:/code/doggle.png\"); int i, j, x1 = part.rows/2, x2 = part.rows / 2, y1 = part.cols / 2, y2=part.cols / 2;//给四个极值赋初值，其中.row和.cols分别返回图片的宽和长 int cPointB,cPointb;//currentPoint; //cout &lt;&lt; part.rows &lt;&lt; ' ' &lt;&lt; part.cols &lt;&lt; endl;调试用 for (i = 0; i &lt; part.rows; i++)//遍历图片找极值 for (j = 0; j &lt; part.cols; j++) &#123; cPointb = part.at&lt;Vec3b&gt;(i,j)[0]; if (0!=cPointb )//也可以把rgb三个颜色都判断下是否为零（全为0即为黑色），不过没有意义 &#123; if (i &lt; x1)x1 = i; else if (i &gt; x2)x2 = i; if (j &lt; y1)y1 = j; else if (j &gt; y2)y2 = j; &#125; &#125; cout &lt;&lt; x1 &lt;&lt; ' ' &lt;&lt; y1 &lt;&lt; ' ' &lt;&lt; x2 &lt;&lt; ' ' &lt;&lt; y2 &lt;&lt; endl; Rect m_select; m_select = Rect(y1, x1 ,y2 - y1,x2 - x1);//进行裁剪,注意此处x、y的坐标是相反的！ Mat roi = part(m_select); imshow(\"ans\", roi); imwrite(\"D:/code/dogcaijian.png\", roi); src=src(m_select);//对原图进行裁剪 cout &lt;&lt; src.rows &lt;&lt; ' ' &lt;&lt; src.cols &lt;&lt; endl; for(i=0;i&lt; src.rows;i++) for(j=0;j&lt; src.cols;j++) &#123; if(roi.at&lt;Vec3b&gt;(i,j)[0]==0) &#123; //cout &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt; ' ' &lt;&lt; \"j=\" &lt;&lt; j &lt;&lt; endl; src.at&lt;Vec3b&gt;(i,j)[0]=0;//&lt;Vec3b&gt;(i,j)[0]为蓝色值 src.at&lt;Vec3b&gt;(i,j)[1]=0;//&lt;Vec3b&gt;(i,j)[1]为绿色值 src.at&lt;Vec3b&gt;(i,j)[2]=0;//&lt;Vec3b&gt;(i,j)[2]为红色值 //对R、G、B三个值都赋值为0，得到黑色像素点 &#125; &#125; imshow(\"doggle\",src); waitKey(0); return 0;&#125; 最终结果： 附一个颜色表，在最后遍历的时候可以换成不同的颜色玩~ 第二次作业内容如图：分析：本题需要注意除了要把苹果部分抠出来，还需要将苹果缩小，放到背景图中的“上层”。 思路可以是这样的： 1、先对苹果的logo进行灰度化和二值化的处理。 2、然后将图二裁剪到和图一一样大，将图一再次缩小，放到背景图片中，将其余部分变黑。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include&lt;iostream&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include \"opencv2/imgproc/imgproc.hpp\" #include &lt;opencv2/core/core.hpp&gt; using namespace std;using namespace cv; //opencv 的命名空间int main()&#123; Mat pingguo, beijing,temp,pg; temp=imread(\"D:\\\\code\\\\opencv\\\\resources\\\\apple.jpg\"); beijing = imread(\"D:\\\\code\\\\opencv\\\\resources\\\\background.jpg\"); Rect r = Rect(0, 0, temp.rows, temp.cols); putText(temp, \"Apple\", Point(temp.rows/2-80, temp.cols-30),FONT_HERSHEY_SIMPLEX, 2, Scalar(0, 0, 0), 5, LINE_AA, false); cvtColor(temp,pg, COLOR_BGR2GRAY);//灰度化 //imshow(\"灰度图\", pg); threshold(pg,pg ,100, 255, THRESH_BINARY);//二值化 //imshow(\"二值图\", pg); vector&lt;int&gt; a; a.push_back(IMWRITE_JPEG_QUALITY); //选择jpeg a.push_back(255); //在这个填入你要的图片质量（255为无损保存，一定要进行255，否则图像失真） imwrite(\"D:\\\\code\\\\opencv\\\\resources\\\\x.jpg\", pg, a); //imwrite(\"D:\\\\code\\\\opencv\\\\resources\\\\x.jpg\", pg); pingguo = imread(\"D:\\\\code\\\\opencv\\\\resources\\\\x.jpg\");//,IMREAD_UNCHANGED); pingguo = imread(\"d:\\\\code\\\\opencv\\\\resources\\\\x.jpg\"); //imshow(\"apple\",pingguo); beijing = beijing(r); //imshow(\"background\", beijing); imwrite(\"d:\\\\code\\\\opencv\\\\resources\\\\caijian.jpg\", beijing); for(int i=0;i&lt;pingguo.rows ;i++) for(int j=0;j&lt; pingguo.cols;j++) &#123; if ((int)pingguo.at&lt;Vec3b&gt;(i, j)[0] &gt;= 240 &amp;&amp; (int)pingguo.at&lt;Vec3b&gt;(i, j)[0] &lt;= 255 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i, j)[1] &gt;= 240 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i, j)[1] &lt;= 255 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i, j)[2] &gt;= 240 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i, j)[2] &lt;= 255) &#123; //cout &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt; ' ' &lt;&lt; \"j=\" &lt;&lt; j &lt;&lt; endl; beijing.at&lt;Vec3b&gt;(i,j)[0]=0; beijing.at&lt;Vec3b&gt;(i,j)[1]=0; beijing.at&lt;Vec3b&gt;(i,j)[2]=0; &#125; &#125; imshow(\"beijing\", beijing); waitKey(0); return 0;&#125; 但是这种方法在实现的过程中出现了许多问题： 1、没有将苹果logo缩小。 2、苹果的处理不精细，在嵌套的for循环中本应该有判断语句中0（蓝色值）为255，而这个代码中判断如果大于240即可，这是因为在图片的二值化处理过程中，经过二值化处理的图片本应该是单通道输入和输出的，但是输入后再读取这个图片的时候是三通道读取，就会出现问题。在上面的给出的代码是经过了处理，保存的是单通道图片，但是我在遍历图片的rgb三个值时还能发现除了0和255外其他的值（如1、2、3、254、253）百度了下这是会经常出现的失真问题，我就将这部分代码由直接判断是否为255（白色）变为了判断一个范围值。 困难总比办法多，但是不慌，还有机会，现在有第二种思路： 1、还是先按照苹果logo图片的大小截取一部分背景，以此作为最终背景。 2、将“apple”插入苹果图，然后进行图片的灰度化和二值化，再利用resize()函数将图片缩小为原来的0.5倍并保存。 3、制作苹果图的掩膜。 4、与背景图进行与运算，得出最终图片。 先放一个铁憨憨的代码（还是没用上掩膜操作）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include&lt;iostream&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include \"opencv2/imgproc/imgproc.hpp\" #include &lt;opencv2/core/core.hpp&gt; using namespace std;using namespace cv;int main()&#123; Mat pingguo, beijing,temp,pg,mask,xpg; temp=imread(\"D:\\\\code\\\\opencv\\\\resources\\\\apple.jpg\"); beijing = imread(\"D:\\\\code\\\\opencv\\\\resources\\\\background.jpg\"); Rect r = Rect(200, 200, temp.rows, temp.cols); putText(temp, \"Apple\", Point(temp.rows/2-80, temp.cols-30),FONT_HERSHEY_SIMPLEX, 2, Scalar(0, 0, 0), 5, LINE_AA, false);//将字母插入，后续补充 cvtColor(temp,pg, COLOR_BGR2GRAY);//灰度化 //imshow(\"灰度图\", pg); threshold(pg,pg ,100, 255, THRESH_BINARY);//二值化 //imshow(\"二值图\", pg); vector&lt;int&gt; a;//开始无失真保存 a.push_back(IMWRITE_JPEG_QUALITY); //选择jpeg a.push_back(255); //在这个填入需要的图片质量（255为无损保存，一定要进行255，否则图像失真） resize(pg, pingguo, Size(), 0.5, 0.5);//缩放为原来的0.5倍，并存储在pingguo里 imwrite(\"D:\\\\code\\\\opencv\\\\resources\\\\x.jpg\", pingguo, a); //imwrite(\"D:\\\\code\\\\opencv\\\\resources\\\\x.jpg\", pg); imshow(\"temp\", pingguo); pingguo = imread(\"d:\\\\code\\\\opencv\\\\resources\\\\x.jpg\"); //imshow(\"apple\",pingguo); beijing = beijing(r); //imshow(\"background\", beijing); imwrite(\"d:\\\\code\\\\opencv\\\\resources\\\\caijian.jpg\", beijing); for(int i= 0;i&lt; beijing.rows ;i++) for(int j= 0;j&lt; beijing.cols;j++) &#123; if (!(i - pingguo.rows / 2 &gt;= 0 &amp;&amp; j - pingguo.cols / 2 &gt;= 0 &amp;&amp; i - pingguo.rows / 2 &lt; pingguo.rows &amp;&amp; j - pingguo.cols / 2 &lt; pingguo.cols &amp;&amp; (int)pingguo.at&lt;Vec3b&gt;(i - pingguo.rows / 2, j - pingguo.cols / 2)[0] &gt;= 0 &amp;&amp; (int)pingguo.at&lt;Vec3b&gt;(i - pingguo.rows / 2, j - pingguo.cols / 2)[0] &lt;= 5 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i - pingguo.rows / 2, j - pingguo.cols/2)[1] &gt;= 0 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i - pingguo.rows / 2, j - pingguo.cols/2)[1] &lt;= 10 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i - pingguo.rows / 2, j - pingguo.cols/2)[2] &gt;= 0 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i - pingguo.rows / 2, j - pingguo.cols/2)[2] &lt;= 10)) &#123;//这个判断条件是通过推导得出的，可能与题目需要的做题方法不同 beijing.at&lt;Vec3b&gt;(i,j)[0]=0; beijing.at&lt;Vec3b&gt;(i, j)[1]=0; beijing.at&lt;Vec3b&gt;(i, j)[2]=0; &#125; &#125; imwrite(\"D:\\\\code\\\\opencv\\\\resources\\\\ans2.jpg\",beijing); imshow(\"beijing\", beijing); waitKey(0); return 0;&#125; 中间用到的部分函数介绍： 12345678910111213resize(pg, pingguo, Size(), 0.5, 0.5);//五个参数分别为要做缩放的图片，缩放后的图片，size函数，长的缩放倍数，宽的缩放倍数putText(temp, \"Apple\", Point(temp.rows/2-80, temp.cols-30),FONT_HERSHEY_SIMPLEX, 2, Scalar(0, 0, 0), 5, LINE_AA, false);函数原型为： void putText( Mat&amp; img, const string&amp; text, Point org, int fontFace,double fontScale， Scalar color, int thickness=1, int lineType=8 );参数1：， Mat&amp; img，待写字的图片，我们写在img图上参数2：，const string&amp; text，待写入的字参数3：， Point org， 第一个字符左下角坐标参数4：，int fontFace，字体类型，FONT_HERSHEY_SIMPLEX ，FONT_HERSHEY_PLAIN ， FONT_HERSHEY_DUPLEX 等等等。参数5：，double fontScale，字体大小参数6：，Scalar color，字体颜色，颜色用Scalar（）表示参数7：， int thickness，字体粗细参数8：， int lineType，线型 CV_8UC1的介绍：见链接 最终效果：","categories":[],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://brillianttt.gitee.io/tags/OpenCV/"}]},{"title":"c语言基础之文件操作","slug":"c语言基础之文件操作","date":"2020-10-15T16:33:21.000Z","updated":"2020-10-15T16:36:52.151Z","comments":true,"path":"2020/10/16/c语言基础之文件操作/","link":"","permalink":"https://brillianttt.gitee.io/2020/10/16/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"","text":"关于文件处理，暂时先借鉴这位博主的博客。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://brillianttt.gitee.io/tags/C-C/"}]},{"title":"OpenCV学习","slug":"OpenCV的学习","date":"2020-10-13T13:15:49.000Z","updated":"2021-03-09T15:20:04.979Z","comments":true,"path":"2020/10/13/OpenCV的学习/","link":"","permalink":"https://brillianttt.gitee.io/2020/10/13/OpenCV%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"今天突然发奋学习之学习OpenCV 安装教程见这里或者这里,文章中没有提到，配置完环境变量以后还需要重启vs2019~ 图像读取与显示12345678910111213141516171819202122232425#include&lt;opencv2/opencv.hpp&gt;#include&lt;iostream&gt;using namespace cv;using namespace std;int main(int argc, char** argv)&#123; //Mat img = imread(\"D:/25.jpg\",0);//imrean()功能为载入一张图片；第二个参数为灰度，为0时为灰色,为1时为原图 Mat src = imread(\"D:/15.jpg\",IMREAD_GRAYSCALE);//注意这里的路径和直接ctrl+v过来的路径不同，是用“/”而不是“\\” 其次，IMREAD_GRAYSCALE是使图片变为灰色 //Mat src = imread(\"D:/25.jpg\"); if (src.empty()) &#123; printf(\"could not load image...\\n\"); return -1; //return 0：一般用在主函数结束时，按照程序开发的一般惯例，表示成功完成本函数。 //return -1：:表示返回一个代数值，一般用在子函数结尾。按照程序开发的一般惯例，表示该函数失败； &#125;//判断是否能找到图片，如果找不到则输出balabala namedWindow(\"输入窗口\",WINDOW_FREERATIO);//引号内内容为提取出的图片右上角的名称，如果没有添加该语句则名称默认为图片大小，WINDOW_FREERATIO函数可以使得图像自由变化大小 imshow(\"输入窗口\", src);//imshow()功能为把刚才的图片显示出来 imwrite(\"hhhh.jpg\", src);//输出一张图片到工程目录下，第一个参数为图片名称 waitKey(0);//等待按键时间:0ms，等待后退出 destroyAllWindows();//结束程序，并释放之前分配的与窗口有关的所有内存空间 return 0;&#125; 其中有 cv.IMREAD_COLOR： 加载彩色图像。任何图像的透明度都会被忽视。它是默认标志。 cv.IMREAD_GRAYSCALE：以灰度模式加载图像 cv.IMREAD_UNCHANGED：加载图像，包括alpha通道 使用MatplotlibMatplotlib是Python的绘图库，可为你提供多种绘图方法。你将在接下来的文章中看到它们。在这里，你将学习如何使用Matplotlib显示图像。你可以使用Matplotlib缩放图像，保存图像等。 1234567import numpy as npimport cv2 as cvfrom matplotlib import pyplot as pltimg = cv.imread('messi5.jpg',0)plt.imshow(img, cmap = 'gray', interpolation = 'bicubic')plt.xticks([]), plt.yticks([]) # 隐藏 x 轴和 y 轴上的刻度值plt.show() 读取和保存视频文件读取要捕获视频，你需要创建一个 VideoCapture 对象。它的参数可以是设备索引或视频文件的名称。设备索引就是指定哪个摄像头的数字。正常情况下，一个摄像头会被连接(就像我的情况一样)。所以我简单地传0(或-1)。你可以通过传递1来选择第二个相机，以此类推。在此之后，你可以逐帧捕获。但是在最后，不要忘记释放俘虏。 12345678910111213141516171819202122import numpy as npimport cv2 as cvcap = cv.VideoCapture(0)#如果要读取文件，只需将0变为文件的路径if not cap.isOpened(): print(\"Cannot open camera\") exit()while True: # 逐帧捕获 ret, frame = cap.read() # 如果正确读取帧，ret为True if not ret: print(\"Can't receive frame (stream end?). Exiting ...\") break # 我们在框架上的操作到这里 gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) # 显示结果帧e cv.imshow('frame', gray) if cv.waitKey(1) == ord('q'): break# 完成所有操作后，释放捕获器cap.release()cv.destroyAllWindows() 保存所以我们捕捉一个视频，一帧一帧地处理，我们想要保存这个视频。对于图像，它非常简单，只需使用 cv.imwrite()。这里还需要做一些工作。这次我们创建一个 VideoWriter 对象。我们应该指定输出文件名(例如: output.avi)。然后我们应该指定 FourCC 代码(详见下一段)。然后传递帧率的数量和帧大小。最后一个是颜色标志。如果为True ，编码器期望颜色帧，否则它与灰度帧一起工作。FourCC：http://en.wikipedia.org/wiki/FourCC 是用于指定视频编解码器的4字节代码。可用代码列表可在fourcc.org中:http://www.fourcc.org/codecs.php 找到。它取决于平台。遵循编解码器对我来说效果很好 123456789101112131415161718192021import numpy as npimport cv2 as cvcap = cv.VideoCapture(0)# 定义编解码器并创建VideoWriter对象fourcc = cv.VideoWriter_fourcc(*'XVID')out = cv.VideoWriter('output.avi', fourcc, 20.0, (640, 480))while cap.isOpened(): ret, frame = cap.read() if not ret: print(\"Can't receive frame (stream end?). Exiting ...\") break frame = cv.flip(frame, 0) # 写翻转的框架 out.write(frame) cv.imshow('frame', frame) if cv.waitKey(1) == ord('q'): break# 完成工作后释放所有内容cap.release()out.release()cv.destroyAllWindows() opencv的绘图功能在上述所有功能中，您将看到一些常见的参数，如下所示： img：您要绘制形状的图像 color：形状的颜色。对于BGR，将其作为元组传递，例如：(255,0,0)对于蓝色。对于灰度，只需传递标量值即可。厚度：线或圆等的粗细。如果对闭合图形（如圆）传递 -1 ，它将填充形状。默认厚度= 1 lineType：线的类型，是否为8连接线，抗锯齿线等。默认情况下，为8连接线。 cv.LINE_AA给出了抗锯齿的线条，看起来非常适合曲线。 1234567先创建黑色的图像：img &#x3D; np.zeros((512,512,3), np.uint8)绘制直线：cv.line(img,(0,0),(511,511),(255,0,0),5)绘制矩形：cv.rectangle(img,(384,0),(510,128),(0,255,0),3) 分别给出了矩形的左上角和右下角坐标画圆：cv.circle(img,(447,63), 63, (0,0,255), -1)，需要中心坐标和半径 ##向图片中添加文本：要将文本放入图像中，需要指定以下内容。 - 您要写入的文字数据 - 您要放置它的位置坐标（即数据开始的左下角）。 - 字体类型（检查cv.putText文档以获取受支持的字体） - 字体比例（指定字体大小） - 常规的内容，例如颜色，厚度，线条类型等。为了获得更好的外观，建议使用lineType = cv.LINE_AA。 12font = cv.FONT_HERSHEY_SIMPLEXcv.putText(img,'OpenCV',(10,500), font, 4,(255,255,255),2,cv.LINE_AA) 图像拼接123456789101112131415161718192021222324252627#include&lt;opencv2\\opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace cv;using namespace std;int main() &#123; Mat image = imread(\"D:/25.jpg\"); Mat logo = imread(\"D:/16.jpg\"); Mat imageROI = image(Rect(image.cols - logo.cols, image.rows - logo.rows, logo.cols, logo.rows)); //Mat imageROI = image(Range(350,350+logo.rows),Range(800,800+logo.rows)); //效果同上 //将logo加到原图上 addWeighted(imageROI, 1.0, logo, 1, 0., imageROI); //使用掩模,效果同上 /* Mat mask = imread(\"C:\\\\Users\\\\Nelsoner\\\\Desktop\\\\Camera Roll\\\\001.jpg\"); logo.copyTo(imageROI, mask);*/ namedWindow(\"hah\"); imshow(\"hah\", image); imwrite(\"hhh.jpg\", image); waitKey(0); destroyAllWindows; return 0;&#125; ROI关于ROI(region of interest——感兴趣区域)的定义，可以看这里 addWeighted第一个参数：InputArray src1，表示需要加权的第一个数组，常常填一个Mat 第二个参数：double alpha，表示第一个数组的权重 第三个参数：InputArray src2，表示第二个数组，需要和第一个数组拥有相同的尺寸和通道数 第四个参数：double beta，第二个数组的权重值，值为1-alpha 第五个参数：double gamma，一个加到权重总和上的标量值。 第六个参数：OutputArray dst，输出的数组，和输入的两个数组拥有相同的尺寸和通道数 dst = src1[I] * alpha + src2[I] * beta + gamma 第七个参数：int dtype，输出阵列的可选深度，有默认值-1。当两个输入数组具有相同深度时，这个参数设置为-1（默认值），即等同于src1.depth()。 下边是一个使用addWeighted()函数实现线性混合操作的例子： 123456789101112131415161718192021222324252627282930313233 #include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;iostream&gt; using namespace cv;using namespace std; void main()&#123; //【0】定义一些局部变量 double alphaValue = 0.5; double betaValue; Mat srcImage1, srcImage2, dstImage; // 【1】读取图像 ( 两幅图片需为同样的类型和尺寸 ) srcImage1 = imread(\"mogu.jpg\"); srcImage2 = imread(\"rain.jpg\"); if (!srcImage1.data) cout &lt;&lt; \"读取srcImage1错误！ \\n\" &lt;&lt; endl; imshow(\"1图原始图\", srcImage1); if (!srcImage2.data) cout &lt;&lt; \"读取srcImage2错误！ \\n\" &lt;&lt; endl; imshow(\"2图原始图\", srcImage2); // 【2】进行图像混合加权操作 betaValue = (1.0 - alphaValue); addWeighted(srcImage1, alphaValue, srcImage2, betaValue, 0.0, dstImage); // 【3】显示效果图 imshow(\"&lt;3&gt;线性混合示例窗口【效果图】\", dstImage); waitKey();&#125; Canny边缘识别函数123456789101112131415161718192021222324#include&lt;opencv2\\highgui\\highgui.hpp&gt;#include&lt;opencv2\\imgproc\\imgproc.hpp&gt;using namespace cv;using namespace std;int main() &#123; //载入原图 Mat srcImage = imread(\"D:/17.jpg\"); //显示原图 imshow(\"【原图】Canny边缘检测\", srcImage); Mat dstImage, edge, grayImage; //【1】创建于src同类型和大小的矩阵dst dstImage.create(srcImage.size(), srcImage.type()); //【2】将原图像转换成灰度图像 cvtColor(srcImage, grayImage, COLOR_BGR2GRAY); //【3】先使用3*3内核来降噪 blur(grayImage, edge, Size(3, 3)); //【4】运行Canny算子 Canny(edge, edge, 3, 9, 3); //显示效果图 imshow(\"【效果图】Canny边缘检测\", edge); waitKey(0); return 0;&#125; 图像的二值化见链接。 颜色反转、图片边缘扩展、这里 将视频文件逐帧保存123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;iostream&gt;using namespace std;using namespace cv;int main()&#123; //打开视频文件：其实就是建立一个VideoCapture结构 VideoCapture capture(0);//()中为0时调用电脑摄像头，为视频文件地址时调用文件 //检测是否正常打开:成功打开时，isOpened返回ture if (!capture.isOpened()) cout &lt;&lt; \"fail toopen!\" &lt;&lt; endl; //获取整个帧数 long totalFrameNumber = capture.get(CAP_PROP_FRAME_COUNT); cout &lt;&lt; \"整个视频共\" &lt;&lt; totalFrameNumber &lt;&lt; \"帧\" &lt;&lt; endl; //设置开始帧() long frameToStart = 1; capture.set(CAP_PROP_POS_FRAMES, frameToStart); cout &lt;&lt; \"从第\" &lt;&lt; frameToStart &lt;&lt; \"帧开始读\" &lt;&lt; endl; //设置结束帧 int frameToStop = 10000; if (frameToStop &lt; frameToStart) &#123; cout &lt;&lt; \"结束帧小于开始帧，程序错误，即将退出！\" &lt;&lt; endl; return -1; &#125; else &#123; cout &lt;&lt; \"结束帧为：第\" &lt;&lt; frameToStop &lt;&lt; \"帧\" &lt;&lt; endl; &#125; //获取帧率 double rate = capture.get(CAP_PROP_FPS); cout &lt;&lt; \"帧率为:\" &lt;&lt; rate &lt;&lt; endl; //定义一个用来控制读取视频循环结束的变量 bool stop = false; //承载每一帧的图像 Mat frame; //显示每一帧的窗口 //namedWindow( \"Extractedframe\" ); //两帧间的间隔时间: //int delay = 1000/rate; double delay = 1000 / rate; //利用while循环读取帧 //currentFrame是在循环体中控制读取到指定的帧后循环结束的变量 long currentFrame = frameToStart; while (!stop) &#123; //读取下一帧 if (!capture.read(frame)) &#123; cout &lt;&lt; \"读取视频失败\" &lt;&lt; endl; return -1; &#125; //cout &lt;&lt; \"正在读取第\" &lt;&lt; currentFrame &lt;&lt; \"帧\" &lt;&lt; endl; //imshow( \"Extractedframe\", frame ); //此处为跳帧操作 if (currentFrame % 5 == 0) //此处为帧数间隔，修改这里就可以了 &#123; cout &lt;&lt; \"正在写第\" &lt;&lt; currentFrame &lt;&lt; \"帧\" &lt;&lt; endl; stringstream str; str &lt;&lt; \"d:/temp/\" &lt;&lt; currentFrame &lt;&lt; \".png\"; /*图片存储位置*/ cout &lt;&lt; str.str() &lt;&lt; endl; imwrite(str.str(), frame); &#125; //waitKey(intdelay=0)当delay≤ 0时会永远等待；当delay&gt;0时会等待delay毫秒 //当时间结束前没有按键按下时，返回值为-1；否则返回按键 int c = waitKey(delay); //按下ESC或者到达指定的结束帧后退出读取视频 if ((char)c == 27 || currentFrame &gt; frameToStop) &#123; stop = true; &#125; //按下按键后会停留在当前帧，等待下一次按键 if (c &gt;= 0) &#123; waitKey(0); &#125; currentFrame++; &#125; //关闭视频文件 capture.release(); waitKey(0); return 0;&#125; 创建掩膜时一些参数的说明关于Scalar的说明 首先单词scalar的意思是标量，但是我们经常可以看到Scalar是包含多个值的，很像是一个向量，这是怎么回事呢？很是让人感觉困惑。先收起我们的困惑，首先来看看，Scalar的定义： 1234typedef struct Scalar&#123; double val[4];&#125;Scalar; Scalar最多可以存储四个值，没有提供的值默认是0。 Scalar常用的使用场景如下： 1Mat M(7,7,CV_32FC2,Scalar(1,3)); 上面的代码表示：创建一个2通道，且每个通道的值都为（1,3），深度为32，7行7列的图像矩阵。CV_32F表示每个元素的值的类型为32位浮点数，C2表示通道数为2，Scalar（1,3）表示对矩阵每个元素都赋值为（1,3），第一个通道中的值都是1，第二个通道中的值都是3. 举两个例子： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;stdio.h&gt;using namespace std;using namespace cv;void scalar_demo1()&#123; Mat M(4,4,CV_32FC2,Scalar(1,3)); cout&lt;&lt;M&lt;&lt;endl;&#125;void scalar_demo2()&#123; Mat M(4,4,CV_32FC3,Scalar(1,2,3)); cout&lt;&lt;M&lt;&lt;endl;&#125;void scalar_demo3()&#123; Mat M(4,4,CV_32FC4,Scalar(1,2,3)); cout&lt;&lt;M&lt;&lt;endl;&#125;int main(void)&#123; //resize_img(); //convert_color_space(); scalar_demo1(); cout&lt;&lt;\"**********************************\"&lt;&lt;endl; scalar_demo2(); cout&lt;&lt;\"**********************************\"&lt;&lt;endl; scalar_demo3(); return 0;&#125; 运行以上代码输出如下，可以发现最后一个矩阵是4通道的，但是我们在初始化的时候只给出了三个通道的值，所以第四个通道的值都默认为0。 123456789101112131415161718192021222324#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;stdio.h&gt;using namespace std;using namespace cv; void scalar_demo4()&#123; Mat blue_m(256,256,CV_8UC3,Scalar(255,0,0)); Mat green_m(256,256,CV_8UC3,Scalar(0,255,0)); Mat red_m(256,256,CV_8UC3,Scalar(0,0,255)); imshow(\"Blue\",blue_m); waitKey(0); imshow(\"Green\",green_m); waitKey(0); imshow(\"Red\",red_m); waitKey(0); &#125;int main(void)&#123; scalar_demo4(); return 0;&#125; 相信读到这你已经明白Scalar是用来干什么的了，它将各个通道的值构成一个整体，赋给具有相同通道数的矩阵元素。至于它开头提到的它为什么叫做标量，就不必再纠结了。","categories":[],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://brillianttt.gitee.io/tags/OpenCV/"}]},{"title":"c++常用函数","slug":"c++常用函数","date":"2020-09-03T08:34:55.000Z","updated":"2020-10-15T16:36:54.559Z","comments":true,"path":"2020/09/03/c++常用函数/","link":"","permalink":"https://brillianttt.gitee.io/2020/09/03/c++%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","excerpt":"","text":"C++: max_element函数和min_element函数1234567891011#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[]=&#123;4,2,3,8,5&#125;; int len=sizeof(a)/sizeof(int); cout&lt;&lt;*max_element(a,a+len)&lt;&lt;endl; //输出集合最大元素 cout&lt;&lt;*min_element(a,a+len)&lt;&lt;endl;//输出集合最小元素 return 0;&#125; 输出： 1282 min_element 返回最小的元素的位置中序列 [first, last)。同理 max_element。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://brillianttt.gitee.io/tags/C-C/"}]},{"title":"常见加密算法","slug":"RSA加密","date":"2020-09-01T00:40:54.000Z","updated":"2020-10-15T16:41:47.670Z","comments":true,"path":"2020/09/01/RSA加密/","link":"","permalink":"https://brillianttt.gitee.io/2020/09/01/RSA%E5%8A%A0%E5%AF%86/","excerpt":"","text":"RSA加密一个链接：RSA加密 仿射密码发一个菜鸡写的源代码，第一次自己写正经的二百行程序~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;cstring&gt;#define mt memsetusing namespace std;char message[50],ciphertext[50],jiemimiwen[50];int lenthofmessage,key,x,y,z;int inverseGCD(int a,int n)//扩展欧几里得定理求逆元&#123; int p=a,q=n; int x=0,y=1; int z=q/p; while(p!=1&amp;&amp;q!=1) &#123; int t=p; p=q%p; q=t; t=y; y=x-y*z; x=t; z=q/p; &#125; y%=n; if(y&lt;0)y+=n; return y;&#125;int gcd(int a, int b) &#123;//辗转相除法的递归实现 (b==0)?a:gcd(b,a%b);&#125;void encrypt(char message[])//加密算法&#123; int a=2,b;//a=2使下面判断gcd(a,26)顺利进行 if(y==0) &#123; cout&lt;&lt;\"请输入要加密的明文：\\n\"; getchar(); gets(message); &#125; lenthofmessage=strlen(message); if(y==1) &#123; cout&lt;&lt;\"明文为:\"&lt;&lt;message&lt;&lt;endl; &#125; cout&lt;&lt;\"请选择是否使用随机密钥（输入1为是，0为否）：\"&lt;&lt;endl; cin&gt;&gt;z; if(z==1) &#123; srand((unsigned)time(NULL)); while(gcd(a,26)!=1) a = rand()%26+1;//用库函数生成1~26的随机数，a、b为密钥 b =rand()%26+1; &#125; else &#123; cout&lt;&lt;\"请输入两个加密密钥a、b（中间有一个空格）:\"&lt;&lt;endl; cin&gt;&gt;a&gt;&gt;b; while(gcd(a,26)!=1) &#123; cout&lt;&lt;\"输入的第一个参数无法求出解密密钥，请重新输入！\\n\"; cin&gt;&gt;a&gt;&gt;b; &#125; &#125; cout&lt;&lt;\"仿射密码的两个参数分别为：\"&lt;&lt;\"a=\"&lt;&lt;a&lt;&lt;' '&lt;&lt;\"b=\"&lt;&lt;b&lt;&lt;endl; int i=0; while (i&lt;lenthofmessage) &#123; if (message[i]&gt;='A'&amp;&amp;message[i]&lt;='Z') ciphertext[i]='A'+(a*(message[i]-'A')+b+26*a)%26; else if (message[i]&gt;='a'&amp;&amp;message[i]&lt;='z') ciphertext[i]='a'+(a*(message[i]-'a')+b+26*a)%26; else if (message[i]==' ') ciphertext[i]=' '; else ciphertext[i]=message[i]; i++; &#125; cout&lt;&lt;\"加密得到的密文为：\"; puts(ciphertext); cout&lt;&lt;endl&lt;&lt;endl; FILE *fpWrite=fopen(\"ciphertext.txt\",\"w\");//文件处理三连，w为从文件头开始写文件，不存在文件则创建一个新文件 fprintf(fpWrite,\"%s\",ciphertext); fclose(fpWrite);&#125;void decrypt(char message[])&#123; cout&lt;&lt;\"y=\"&lt;&lt;y&lt;&lt;endl; int a,b,i; if(y==0) &#123; cout&lt;&lt;\"请输入要解密的文本:\\n\"; getchar(); gets(message); &#125; lenthofmessage=strlen(message); cout&lt;&lt;\"请输入两个解密密钥a、b（中间有一个空格）:\"&lt;&lt;endl; cin&gt;&gt;a&gt;&gt;b; while(gcd(a,26)!=1) &#123; cout&lt;&lt;\"输入的第一个参数无法求出解密密钥，请重新输入！\\n\"; cin&gt;&gt;a&gt;&gt;b; &#125; int ani=inverseGCD(a,26);//求逆元 cout&lt;&lt;\"逆元为：\"&lt;&lt;ani&lt;&lt;endl; i=0; while (i&lt;lenthofmessage) &#123; if (message[i]&gt;='A'&amp;&amp;message[i]&lt;='Z') jiemimiwen[i]='A'+ani*(message[i]-'A'-b+26)%26; else if (message[i]&gt;='a'&amp;&amp;message[i]&lt;='z') jiemimiwen[i]='a'+ani*(message[i]-'a'-b+26)%26; else if (message[i]==' ') jiemimiwen[i]=' '; else jiemimiwen[i]=message[i]; i++; &#125; jiemimiwen[i]='\\0'; cout&lt;&lt;\"解密得到的明文为：\"; cout&lt;&lt;jiemimiwen&lt;&lt;endl&lt;&lt;endl; &#125;int main() &#123; cout&lt;&lt;\"=========== Hill 密码 ===========\\n\"; cout&lt;&lt;\"= =\\n\"; cout&lt;&lt;\"= =\\n\"; cout&lt;&lt;\"= =\\n\"; cout&lt;&lt;\"= =\\n\"; cout&lt;&lt;\"= =\\n\"; cout&lt;&lt;\"= 信安1904 马博宇 =\\n\"; cout&lt;&lt;\"=================================\\n\"; while(1) &#123; mt(message,0,sizeof(message)); mt(ciphertext,0,sizeof(ciphertext)); mt(jiemimiwen,0,sizeof(jiemimiwen)); cout&lt;&lt;\"请选择需要：1、加密 2、解密（输入1为加密，2为解密,-1为退出程序）：\"&lt;&lt;endl; cin&gt;&gt;x; if(x==1) &#123; cout&lt;&lt;\"请选择是否从文件输入（输入1为是，0为否,-1为退出程序）：\"&lt;&lt;endl; cin&gt;&gt;y; if(y==1) &#123; FILE *file1; file1=fopen(\"plaintext.txt\",\"r\"); fgets(message,50,file1); &#125; else if(y==-1) return 0; encrypt(message); &#125; else if(x==2) &#123; cout&lt;&lt;\"请选择是否从文件输入（输入1为是，0为否,-1为退出程序）：\"&lt;&lt;endl; cin&gt;&gt;y; if(y==1) &#123; FILE *file1; file1=fopen(\"ciphertext.txt\",\"r\"); fgets(message,50,file1); &#125; else if(y==-1) return 0; else decrypt(message); &#125; else if(x==-1) return 0; &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://brillianttt.gitee.io/tags/RSA/"},{"name":"仿射密码","slug":"仿射密码","permalink":"https://brillianttt.gitee.io/tags/%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81/"},{"name":"密码学","slug":"密码学","permalink":"https://brillianttt.gitee.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"出去玩拍的一些皂片","slug":"出去玩拍的一些皂片","date":"2020-08-24T10:47:15.000Z","updated":"2020-08-24T10:47:18.090Z","comments":true,"path":"2020/08/24/出去玩拍的一些皂片/","link":"","permalink":"https://brillianttt.gitee.io/2020/08/24/%E5%87%BA%E5%8E%BB%E7%8E%A9%E6%8B%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9A%82%E7%89%87/","excerpt":"","text":"唱K 打球 逛动物园 学习驾驶技能 烧烤！猜猜这个是啥哈哈哈哈哈哈看我找到了什么哈哈哈 打工当然还是要打工的 以及穿这个真的是像六十岁的老大爷风格吗哈哈哈😂","categories":[],"tags":[{"name":"照片","slug":"照片","permalink":"https://brillianttt.gitee.io/tags/%E7%85%A7%E7%89%87/"}]},{"title":"云吸猫系列","slug":"云吸猫系列","date":"2020-08-23T12:10:28.000Z","updated":"2021-09-11T14:50:32.840Z","comments":true,"path":"2020/08/23/云吸猫系列/","link":"","permalink":"https://brillianttt.gitee.io/2020/08/23/%E4%BA%91%E5%90%B8%E7%8C%AB%E7%B3%BB%E5%88%97/","excerpt":"","text":"这个假期都没怎么发辛巴的照片，这里一次发个够好了😎（因为懒得用p图软件把图都拼到一起了所以就一并发了哈哈哈哈哈哈哈） 日常占我的床：最近抓拍的 注意右侧脸颊哈哈哈他太胖了他的眼屎我真的一拍完就给他处理了！是谁的猪猪男孩呀~迄今为止自认为最有气质的几张没想到吧哈哈哈哈哈哈哈哈哈哈哈哈接下来是嫌弃三连哈哈哈哈哈哈哈哈哈再然后是一些很妖娆的姿势👀再来些可可爱爱的😄最后再来一些随拍hiahiahia这个其实是在打呵欠哈哈哈哈，正好被我抓拍到了这仨是视频中截的图，有没有点像哥斯拉哈哈哈 写在最后： 辛巴其实是我养的第三只猫，之前领养的两只猫猫因为特殊原因实在养不了了，最后托付给了能善待他们的新主人。真心对这两只可爱猫猫的主人说一声对不起，我没有将他们一直养下去，他们都是非常非常非常可爱的猫，身体健康，也十分活泼，希望他们能一直快乐的生活。 最后的最后！说了一个假期要来偷猫的人！一个来偷的都没有哼！我都准备好和你们斗智斗勇了哈哈哈 2021-9-11更新","categories":[],"tags":[{"name":"猫","slug":"猫","permalink":"https://brillianttt.gitee.io/tags/%E7%8C%AB/"},{"name":"照片","slug":"照片","permalink":"https://brillianttt.gitee.io/tags/%E7%85%A7%E7%89%87/"}]},{"title":"一份小总结","slug":"一份小总结","date":"2020-08-23T11:44:12.000Z","updated":"2020-08-23T16:08:03.448Z","comments":true,"path":"2020/08/23/一份小总结/","link":"","permalink":"https://brillianttt.gitee.io/2020/08/23/%E4%B8%80%E4%BB%BD%E5%B0%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"这些照片因为我非常特别very poor的技术。。。很多图片内存比较大发上来手机显示不了或者显示速度过慢，要是方便的话可以拿电脑访问，电脑能看所有图片！ 云吸猫系列传送门一号 出去玩拍的一些皂片传送门二号","categories":[],"tags":[{"name":"Summer summary","slug":"Summer-summary","permalink":"https://brillianttt.gitee.io/tags/Summer-summary/"}]},{"title":"简单数学知识","slug":"简单数学知识","date":"2020-07-15T11:30:22.000Z","updated":"2020-10-12T12:50:36.749Z","comments":true,"path":"2020/07/15/简单数学知识/","link":"","permalink":"https://brillianttt.gitee.io/2020/07/15/%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/","excerpt":"","text":"模运算取模运算的三个公式： (a+b)%m=((a%m) + (b%m))%m (a+b)%m=((a%m) + (b%m))%m (a*b)%m=((a%m) * (b%m))%m 快速幂如2^11可以转换为2^1 * 2^2 * 2^8 而指数11转换为二进制为1011，11可表示为2^0+2^1+2^3 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll fast_pow(ll a,ll n)&#123; ll base=a;//是个变量 ll res=1;//答案 while(n&gt;0) &#123; if(n&amp;1) res*=base; base=base*base; n&gt;&gt;=1;//向右移动一位 &#125; return res;&#125;int main()&#123; cout&lt;&lt;fast_pow(2,11)&lt;&lt;endl; &#125; 如果计算大数的幂次的话，可以求它的余数 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;typedef long long ll;ll fast_pow(ll a,ll n,ll M)&#123; ll base=a;//是个变量 ll res=1;//答案 while(n&gt;0) &#123; if(n&amp;1) res=res*base%M; base=base*base%M; n&gt;&gt;=1;//向右移动一位 &#125; return res;&#125;int main()&#123; int M=10; cout&lt;&lt;fast_pow(2,11,M)&lt;&lt;endl; &#125; 埃筛，线性筛(欧拉筛)首先是埃拉托斯特尼筛法： 这是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint prime[20000];int len;int main() &#123; int n; cin&gt;&gt;n; int book[20000]; memset(book,0,sizeof(book)); for(int i=2;i&lt;=n;i++) &#123; if(!book[i]) &#123; prime[len++] = i; for(int j=2*i;j&lt;=n;j+=i) &#123;//每次把这个数的倍数标记 book[j] = 1; &#125; &#125; &#125; /*for(int i=0;i&lt;len;i++) &#123; cout&lt;&lt;prime[i]&lt;&lt;endl; &#125;*/&#125; 埃筛其实还是有一些重复：许多数被重复标记，比如：10既被2标记过，又被5标记过。 接下来是线性筛：线性筛的优化主要在于每个数只被筛过一次 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint prime[20000];int len;int main() &#123; int n; cin&gt;&gt;n; int book[20000]; memset(book,0,sizeof(book)); for(int i=2;i&lt;=n;i++) &#123; if(!book[i]) &#123; prime[len++] = i; &#125; for(int j=0;j&lt;len;j++) &#123; if(i*prime[j]&gt;n) break; book[i*prime[j]] = 1; if(i%prime[j]==0)//使每个合数只被它的最小质因数标记 break; &#125; &#125; /*for(int i=0;i&lt;len;i++) &#123; cout&lt;&lt;prime[i]&lt;&lt;endl; &#125;*/&#125; 附上一个链接,这位大大写的很详细。 唯一分解定理每个大于1的自然数均可写为质数的积，而且这些素因子按大小排列之后，写法仅有一种方式。 当题目有大数相除，求余数且精度要求高时，就要运用唯一分解定律 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;const int maxn=10000+5;int e[maxn]; //用e[]保存每一位素数的系数vector&lt;int&gt; primes;void GetPrime()&#123; int n[10000]=&#123;0&#125;; for(int i=2;i&lt;=sqrt(10000+0.5);i++) if(!n[i]) for(int j=i*i;j&lt;=10000;j+=i) n[j]=1; for(int i=2;i&lt;=10000;i++) if(!n[i]) primes.push_back(i);&#125;void add_int(int n,int d)&#123; for(int i=0;i&lt;primes.size()&amp;&amp;n!=1;i++) while(n%primes[i]==0) &#123; n/=primes[i]; e[i]+=d; &#125;&#125;int main() &#123; GetPrime(); //求出素数 int n, p; cin &gt;&gt; n; add_int(n, 1); //乘以n; p = 0; for (int i = 0; i &lt; primes.size(); i++) if (e[i]) &#123; if (p) cout &lt;&lt; '*'; cout &lt;&lt; primes[i] &lt;&lt; '^' &lt;&lt; e[i]; if (!p) p = 1; &#125; cout &lt;&lt; endl; cin &gt;&gt; n; add_int(n, -1); //除以n; p = 0; for (int i = 0; i &lt; primes.size(); i++) if (e[i]) &#123; if (p) cout &lt;&lt; '+'; cout &lt;&lt; primes[i] &lt;&lt; '^' &lt;&lt; e[i]; if (!p) p = 1; &#125; return 0;&#125;/*运行效果：10002^3*5^352^3+5^2*/ 扩展欧几里得算法扩展欧几里得算法用于求取二元一次方程的整数解。（如：ax+by=cax+by=c，x,yx,y为未知数） 在学习扩展欧几里得算法前要先知道欧几里得算法，也就是辗转相除法 辗转相除法：定义：两个数a,ba,b的最大公因数gcd(a,b) = gcd(b,a \\bmod b)，a &gt; bgcd(a,b)=gcd(b,amodb)，a&gt;b例如：99和1212的最大公因数为33，gcd(12,9)=gcd(9,3)=gcd(3,0)=3gcd(12,9)=gcd(9,3)=gcd(3,0)=3。 1234567int gcd(int a, int b) &#123; //return (b == 0)? a : gcd(b, a % b); if (b == 0) return a; else return gcd(b, a % b);&#125; 扩展欧几里得定理:附上关键代码： 123456789101112int Exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; int d = Exgcd(b, a % b, x, y); int t = x;//以下三行是经过数学推导出的结果 x = y; y = t - (a / b) * y; return d;&#125; 再附上一个例题和讲解的链接。 素数定理素数定理（prime number theorem）是素数分布理论的中心定理，是关于素数个数问题的一个命题： 设x≥1，以π(x)表示不超过x的素数的个数，当x→∞时，π(x)Li(x)或π(x)x/ln(x)。（Li(x)为对数积分） 根据推导即有π(x)~x/ln(x)，利用素数定理，可以解决一些看起来很难的c语言题目，比如说这个。先补充一下c语言对数函数的使用： 123456789#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; printf(\"%f\\n\",log(10)); //以e为底的对数函数 printf(\"%f\\n\",log10(100)); //以10为底的对数函数 printf(\"%f\\n\",log(8)/log(2)); //计算log2^8,运用换底公式 printf(\"%f\\n\",exp(1)); //计算自然常数e return 0;&#125; 要计算素数个数的位数，我们还需要一个计算数字位数的公式：n=lg(x)+1，结合素数定理的结论和位数公式就可推导得出答案。 然后附上题解： 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main() &#123; int n; while(cin&gt;&gt;n) &#123; if(n==1||n==2) &#123; cout&lt;&lt;n&lt;&lt;endl; &#125; else &#123; int m=double(n-log10(n)-log10(log(10)));//经过数学推导得出 cout&lt;&lt;m+1&lt;&lt;endl; &#125; &#125; return 0;&#125; 再举一个栗子有了上一题的思路，这一题可以很快想到利用lg(x)+1的方法去计算，而n!=123···n，带回到lg(x)+1中也可以求解。 但是吧。。。凡是都有例外，这个题就不行，因为用对数函数去求还不是最快的方法，还可以运用斯特林公式求解，具体如下： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define e 2.718281828459045#define pi 3.141592653589793239using namespace std;int main ()&#123; int n; while ( cin&gt;&gt;n;) &#123; ciun&gt;&gt;n; double t = log10(sqrt(2*pi*n)) + n * log10(n/e); printf (\"%d\\n\",(int)t + 1); &#125;return 0;&#125; 斯特林公式：log(n!) = log10(sqrt(2pin)) + n*log10(n/e)","categories":[{"name":"数学","slug":"数学","permalink":"https://brillianttt.gitee.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://brillianttt.gitee.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"0-1背包问题","slug":"0-1背包问题","date":"2020-07-09T14:30:33.000Z","updated":"2020-07-13T01:16:35.842Z","comments":true,"path":"2020/07/09/0-1背包问题/","link":"","permalink":"https://brillianttt.gitee.io/2020/07/09/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"首先两个概念： 背包问题：有某些物品，每个物品有一个重量w[i],价值v[i]，现在有一个容量为t的背包，问这个背包能存放的物品的价值和最大时多少？ 01背包问题：有n个物品，每一个物品有一个重量w[i]，价值v[i],现在有一个容量为t的背包，问这个背包的能存放的物品的价值和最大是多少？ dp实现dp[i][j],前i个物品，容量为j的背包，所能存放的物品的最大价值是多少。 举个栗子： i 1 2 3 4 5 w 2 3 2 4 1 v 3 2 4 6 3 栗子的解释👇 其中i表示物品，j表示背包容量 dp[0][j]=0，因为当没有物品时，无论有多的容量，也没有价值 j&gt;=w[i]: dp[i][j]=max(dp[i][j],dp[i-1][j-w[i]]+v[i]) 背包容量：j-w[i]-&gt;j-w[i]+w[i]-&gt;j 背包价值：dp[i-1][j-w[i]]+v[i] dp[i][j] 0 1 2 3 4 5 6 7 8 i=0 0 0 0 0 0 0 0 0 0 i=1,w=2,v=3 0 0 3 3 3 3 3 3 3 i=2,w=3,v=2 0 0 3 3 3 3+2=5 3 3 3 i=3,w=2,v=4 0 0 4 4 3+4=7 7 7 9 9 i=4,w=4,v=6 0 0 4 4 7 7 4+6=10 10 7+6=13 i=5,w=1,v=3 0 3 3 7 7 7+3=10 10 13 13 例1：采药问题这是题目链接 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e3+5;int main()&#123; int t,m; cin&gt;&gt;t&gt;&gt;m; int w[maxn],v[maxn]; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; int dp[105][1005]=&#123;0&#125;; for(int i=1;i&lt;=m;i++) for(int j=0;j&lt;=t;j++) &#123; dp[i][j]=dp[i-1][j]; if(j&gt;=w[i]) &#123; dp[i][j]=max(dp[i][j],dp[i-1][j-w[i]]+v[i]);//状态转移方程 &#125; &#125; cout&lt;&lt;dp[m][t]; return 0;&#125; 将上面的代码做一个滚动优化： 根据状态转移方程，当前状态只和其前一个状态有关，所以只需使用dp[2][x]。 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e3+5;int main()&#123; int t,m; cin&gt;&gt;t&gt;&gt;m; int w[maxn],v[maxn]; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; int dp[2][1005]=&#123;0&#125;;//占用空间减小了 for(int i=1;i&lt;=m;i++) &#123; int p=i&amp;1;//如果i是奇数p=1，否则p=0 for(int j=0;j&lt;=t;j++) &#123; dp[p][j]=dp[!p][j]; if(j&gt;=w[i]) &#123; dp[p][j]=max(dp[p][j],dp[!p][j-w[i]]+v[i]);//状态转移方程 &#125; &#125; &#125; cout&lt;&lt;dp[m&amp;1][t]; return 0;&#125; 用一维dp再优化下： 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e3+5;int main()&#123; int t,m; cin&gt;&gt;t&gt;&gt;m; int w[maxn],v[maxn]; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; int dp[1005]=&#123;0&#125;;//换成了一维数组 for(int i=1;i&lt;=m;i++) &#123; for(int j=t;j&gt;=0;j+--)//这里的j&gt;=0可以换成j&gt;=w[i],下面的if语句就也可以去掉了 &#123; dp[j]=dp[j]//这句其实没用，就是对照下二维dp的dp[i][j]=dp[i-1][j] if(j&gt;=w[i]) &#123; dp[j]=max(dp[j],dp[j-w[i]]+v[i]); &#125; &#125; &#125; cout&lt;&lt;dp[t]; return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"暑假学习","slug":"暑假学习","permalink":"https://brillianttt.gitee.io/tags/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0/"},{"name":"0-1背包问题","slug":"0-1背包问题","permalink":"https://brillianttt.gitee.io/tags/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"}]},{"title":"阶段小结","slug":"阶段小结","date":"2020-07-07T13:26:27.000Z","updated":"2020-07-07T14:01:56.729Z","comments":true,"path":"2020/07/07/阶段小结/","link":"","permalink":"https://brillianttt.gitee.io/2020/07/07/%E9%98%B6%E6%AE%B5%E5%B0%8F%E7%BB%93/","excerpt":"","text":"明天是高考第二天，也是我加入的acm实验室的第一天暑期集训，想在今天做一个最近的小总结，也希望不留下遗憾，过好这个暑假。这个博客是在今年寒假开始的时候好朋友帮助我搭建的，现在只能在界面以及主题方面做一些细微的修改，主要用来记录学习笔 记，偶尔也分享一些生活小事，就当这里是我的“秘密基地”吧！ 今天实验室的老师在开会时也对我们学习方面的事情做了一些较严厉的批评，也是给我们这群刚考完试的准大二学生敲响了警钟，留给自己努力的时间不多了，马上要来到的暑假培训、补大一没有学的课程、准备12月的六级考试、学习html、考驾照、减掉这个学期和寒假多出来的20斤五花肉、重新巩固（or预习）高数的知识balabala，这些任务很重要，并且都是必须要做的事情，将这些事情都展开了说是希望自己能好好努力，不再浪费这段时间，能踏踏实实的过完这个暑假，在今年九月开学的时候，做个像样的大学生。 最近这段时间收获还是不小的，上一周安排的很紧凑：每天上午学车，下午模拟或者考试，晚上继续复习或者写代码，再加上每天来回30km的遥远路途，也算是被小小的摧残了下~ 结果还是比较不错的，数学、物理、线代的成绩也还算ok，科二补考也过了（虽然第一把没系安全带直接挂了，but问题不大）。 写到这里好像也没有什么其他想说的了，简单感慨下继续努力叭，希望自己能不浪费这个暑假，好好去努力！！ 哦对了！！如果有明天还高考的小伙伴恰好今晚也看到了这个blog，想对你们再说一句加油！理综选择可得认真嗷，六分一个，不能随随便便就扔了嗷。加油加油，晚安早睡😴","categories":[],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"bfs例题","slug":"bfs例题","date":"2020-06-07T03:45:50.462Z","updated":"2020-06-09T15:51:20.561Z","comments":true,"path":"2020/06/07/bfs例题/","link":"","permalink":"https://brillianttt.gitee.io/2020/06/07/bfs%E4%BE%8B%E9%A2%98/","excerpt":"","text":"走迷宫题意：从入口走到出口输入：地图、起始位置、出口位置输出：最少走几步代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;using namespace std;struct note&#123; int x,y;//横、纵坐标 //int f;//父亲在队列中的编号，本题不需要 int s;//步数&#125;;int a[51][51],book[51][51];//用来记录地图和标记地图上的点是否走过int main()&#123; note que[2501];//地图大小不超过50*50，所以扩展大小不超过2500 int next[4][2]=&#123;&#123;0,1&#125;, &#123;1,0&#125;, &#123;0,-1&#125;, &#123;-1,0&#125; &#125;;//方位 int head,tail;队列的头部和尾部 int i,j,k,n,m,startx,starty,p,q,tx,ty,flag; cin&gt;&gt;n&gt;&gt;m;//输入地图大小 for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) cin&gt;&gt;a[i][j];//输入地图 cin&gt;&gt;startx&gt;&gt;starty&gt;&gt;p&gt;&gt;q;//输入起始坐标和终点坐标 //队列初始化 head=1; tail=1; //向队列插入迷宫入口坐标 que[tail].x=startx; que[tail].y=starty; //que[tail].f=0; que[tail].s=0;//在起点时步数为零 tail++;//尾部增加一个扩展 book[startx][starty]=1;//标记现在所处位置已经走过 flag=0;//用来标记是否到达目标点，0表示暂时还没到，1表示已经到达 //当队列不为空的时候循环 while(head&lt;tail) &#123; //枚举四个方向 for(k=0;k&lt;4;k++) &#123; tx=que[head].x+next[k][0]; ty=que[head].y+next[k][1]; if(tx&lt;1||tx&gt;n||ty&lt;1||ty&gt;m)//判断是否越界 &#123; continue; &#125; if(a[tx][ty]==0&amp;&amp;book[tx][ty]==0) &#123; book[tx][ty]=1;//标记已经走过 que[tail].x=tx;//更新现在所处位置 que[tail].y=ty; //que[tail].f=head; que[tail].s=que[head].s+1;//步数加一 tail++; &#125; //如果到了目标点，停止扩展，任务结束，退出循环 if(tx==p&amp;&amp;ty==q) &#123; flag=1; break; &#125; &#125; if(flag==1) break; head++;//不能去掉，当一个点扩展结束后，head++才能对后面的点再扩展 &#125; cout&lt;&lt;que[tail-1].s; return 0;&#125; 又一个走迷宫这里是题目链接。直接上代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;using namespace std;struct note//模拟队列&#123; int x,y; int step=0;//步数&#125;que[10005];char maze[101][101];//迷宫bool vis[101][101];//判断是否走过int main()&#123; int next[4][2]=&#123;0,1,1,0,0,-1,-1,0&#125;;//模拟往四个方向走 int head=1,tail=1,tx,ty,n,m,flag=0; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) &#123; cin&gt;&gt;maze[i][j];//输入地图 if(maze[i][j]=='B')//记录下起点坐标 &#123; que[head].x=i; que[head].y=j; tail++; vis[i][j]=1; &#125; &#125; while(head&lt;tail)//遍历地图 &#123; for(int k=0;k&lt;4;k++) &#123; tx=que[head].x+next[k][0]; ty=que[head].y+next[k][1]; if(tx&gt;=0&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;m&amp;&amp;vis[tx][ty]==0&amp;&amp;maze[tx][ty]=='.')//如果不越界且可以走 &#123; que[tail].x=tx;//将此时的坐标加入队列 que[tail].y=ty; que[tail].step=que[head].step+1;//在当前根节点的步数基础上多走一步 tail++; vis[tx][ty]=1;//标记已经走过 &#125; if(maze[tx][ty]=='C')//如果找到终点 &#123; que[tail].step=que[head].step+1;//步数一 flag=1;//标记找到终点 break;//溜了 &#125; &#125; if(flag==1) break;//继续溜 head++; &#125; cout&lt;&lt;que[tail].step;//输出当前步数 return 0;//溜走了 //注意在没到终点时每一次tail都要加一，找到了就不用加了，只在当前tail下step++即可，最后输出。&#125; 用队列写走迷宫这是一个例题. ac代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;char maze[105][105];int vis[105][105];typedef struct point//用结构体记录当前的点以及移动的步数&#123; int x; int y; int dis=0;&#125;p;queue&lt;point&gt;Q;p start,End,temp,tmp;int main()&#123; int n,m,i,j,ans=0,tx,ty,flag=0; int next[4][2]=&#123;&#123;0,1&#125;, &#123;1,0&#125;, &#123;0,-1&#125;, &#123;-1,0&#125; &#125;; scanf(\"%d %d\",&amp;n,&amp;m); for(i=0;i&lt;n;i++) &#123; scanf(\"%s\",maze[i]); &#125; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; if(maze[i][j]=='B') &#123; start.x=i; start.y=j; start.dis=0;//初始点步数为0 &#125; else if(maze[i][j]=='C') &#123; End.x=i; End.y=j; &#125; &#125; &#125; Q.push(start);//将起点压入队列 vis[start.x][start.y]=1;//标记已经走过 while(!Q.empty()) &#123; temp=Q.front();//获得队首元素 Q.pop();//将队首出队 for(int k=0;k&lt;4;k++) &#123; tx=temp.x+next[k][0]; ty=temp.y+next[k][1]; if(tx&gt;=0&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;m&amp;&amp;maze[tx][ty]=='.'&amp;&amp;!vis[tx][ty]) &#123; tmp.x=tx;tmp.y=ty;tmp.dis=temp.dis+1; Q.push(tmp);//将满足条件的点压入队列 vis[tx][ty]=1;//标记已经走过 &#125; if(tx==End.x&amp;&amp;ty==End.y) &#123; //因为在上一个if语句里没有判断是否走到终点的情况，所以此处若走到了终点， //则步数应该为上一个temp节点（也就是本轮while循环的head节点）的步数加一。 ans=temp.dis+1; flag=1; break; &#125; &#125; if(flag==1) break; &#125; printf(\"%d\",ans); return 0;&#125; 宝岛探险题意：给出一个n*m大小的地图，0表示海，1~9表示小岛，数字越大岛越重要，现在给出起点坐标，问所在岛屿有多大。(视起始坐标上下左右相邻的区域为同一个岛屿)输入：地图大小，起始坐标输出：岛屿大小代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;struct node&#123; int x,y;&#125;que[2501];bool book[51][51]=&#123;0&#125;;int maze[51][51];int main()&#123; int head,tail; int sum=0,n,m,startx,starty,tx,ty; int next[4][2]=&#123;0,1,1,0,0,-1,-1,0&#125;; cin&gt;&gt;n&gt;&gt;m&gt;&gt;startx&gt;&gt;starty; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;maze[i][j]; head=1; tail=1; que[tail].x=startx; que[tail].y=starty; tail++; book[startx][starty]=1; sum=1; while(head&lt;tail) &#123; for(int k=0;k&lt;4;k++) &#123; tx=que[head].x+next[k][0]; ty=que[head].y+next[k][1]; if(tx&lt;1||tx&gt;n||ty&lt;1||ty&gt;n) continue; if(maze[tx][ty]&gt;0&amp;&amp;book[tx][ty]==0) &#123; sum++; book[tx][ty]=1; que[tail].x=tx; que[tail].y=ty; tail++; &#125; &#125; head++; &#125; cout&lt;&lt;sum; return 0;&#125; 宝岛探险也可以用dfs做，理解起来也比较简单，具体实例在“dfs例题”中。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"https://brillianttt.gitee.io/tags/bfs/"}]},{"title":"dfs例题","slug":"dfs例题","date":"2020-06-05T03:34:51.000Z","updated":"2020-09-03T12:04:13.905Z","comments":true,"path":"2020/06/05/dfs例题/","link":"","permalink":"https://brillianttt.gitee.io/2020/06/05/dfs%E4%BE%8B%E9%A2%98/","excerpt":"","text":"输出全排列如何输出全排列呢，可以使用algirithm头文件下的next_permutation()函数偷懒，也可以使用今天我学的dfs实现，据说这种题型是dfs里最简单的一类，不禁让我怀疑自己的脑袋是不是一半水一半面哈哈哈。话不多说，看题！题意：给出一个数n，输出1~n的全排列（1&lt;=n&lt;=9).分析：不咋会分析，兄得们将就看，等我学会了再来补充。代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;int a[10],book[10],n;//因为c语言的全局变量在没有赋值以前默认为0，所以无需再赋初值void dfs(int step)//step表示现在站在第几个盒子里&#123; int i; if(step==n+1) &#123; //输出一种排列（1~n号盒子中的扑克牌编号） for(i=1;i&lt;=n;i++) cout&lt;&lt;a[i]; cout&lt;&lt;endl; return;//返回之前一步，即最近一次调用dfs函数的位置 &#125; //此时在第step个盒子前，按照1、2、3...n的顺序一一尝试 for(i=1;i&lt;=n;i++) &#123; //判断牌i是否在手上 if(book[i]==0)//book[i]等于0表示i号扑克牌在手上 &#123; //开始尝试使用扑克牌 a[step]=i;//将i号扑克牌放入第step个盒子中 book[i]=1;//将book[i]设为1，表示i号扑克牌已经不在手上 //第step个盒子已经放好了牌，接下来要走到下一个盒子面前 dfs(step+1);//进行递归调用，这里需要仔细思考 book[i]=0;//这一步也很重要，是将刚才尝试的牌收回，再进行下一次尝试 &#125; &#125; return;&#125;int main()&#123; cin&gt;&gt;n;//输入要注意n为1~9之间的整数 dfs(1);//开始站在第一个小盒子前 return 0;&#125; 输出组合排列与组合是常用的数学方法，其中组合就是从n个元素中抽出r个元素(不分顺序且r &lt; ＝ n)，我们可以简单地将n个元素理解为自然数1，2，…，n，从中任取r个数。现要求你不用递归的方法输出所有组合。例如n ＝ 5 ，r ＝ 3 ，所有组合为：1 2 31 2 41 2 51 3 41 3 51 4 52 3 42 3 52 4 53 4 5输入：一行两个自然数n、r ( 1 &lt; n &lt; 21，1 &lt; ＝ r &lt; ＝ n )输出：所有的组合，每一个组合占一行且其中的元素按由小到大的顺序排列，所有的组合也按字典顺序。代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;int n,r,a[25];bool vis[25];// 来记录各个数字是否被访问using namespace std;void dfs (int dep)//dep代表搜索的深度，即当前数组a添加了多少个数&#123; for (int i=a[dep-1]+1;i&lt;=n;++i)//从上一个添加的数+1开始搜索数字 &#123; if (!vis[i])//如果这个数字没被访问过 &#123; a[dep]=i;//将这个数字添加到a里面去 if (dep==r)//如果添加的数字达到r个，把他们输出 &#123; int j; for ( j=1;j&lt;r;++j) printf(\"%d \",a[j]); printf(\"%d\\n\",a[j]); &#125; else dfs(dep+1);//如果达不到r个继续添加 vis[i]=0;//回溯，清空当前状态，把vis[i]设为没有访问过。 &#125; &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;r); dfs(1);//写成dfs很巧妙 return 0;&#125;/* Time:12 ms Memory:1696 kb*/ 走迷宫输入：迷宫地图、起点坐标、出口坐标输出：最少走多少步 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;using namespace std;int p,q,m,n,minx=99999999;int book[51][51],a[51][51];void dfs(int x,int y,int step)&#123; int next[4][2]&#123; &#123;0,1&#125;,//向右 &#123;1,0&#125;,//向下 &#123;0,-1&#125;,//向左 &#123;-1,0&#125;//向上 &#125;;//用行列表示，而不是坐标 int tx,ty;//记录当前位置 if(x==p &amp;&amp; y==q) &#123; if(step&lt;minx) minx=step; return; &#125; //枚举四种走法 for(int i=0;i&lt;=3;i++) &#123; //模拟上下左右移动 tx=x+next[i][0]; ty=y+next[i][1]; //判断是否越界 if(tx&lt;1||tx&gt;n||ty&lt;1||ty&gt;m) continue; //判断该点是否为障碍物或者已经在路径中 if(a[tx][ty]==0&amp;&amp;book[tx][ty]==0) &#123; book[tx][ty]=1;//标记这个点已经走过 dfs(tx,ty,step+1);//开始尝试下一个点 book[tx][ty]=0;//尝试结束，取消这个点的标记 &#125; &#125; return;&#125;int main()&#123; int startx,starty; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; cin&gt;&gt;a[i][j];//输入迷宫 &#125; cin&gt;&gt;startx&gt;&gt;starty&gt;&gt;p&gt;&gt;q;//输入起点和终点坐标 //开始搜索 book[startx][starty]=1;//标记起点已经在路径中，防止后面重复走 dfs(startx,starty,0);//最开始步数为0 cout&lt;&lt;minx; return 0; /*例： 5 4 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 输出：7 */&#125; 宝岛探险类型一：题意：给出一个n*m大小的地图，0表示海，1~9表示小岛，数字越大岛越重要，现在给出起点坐标，问所在岛屿有多大。(视起始坐标上下左右相邻的区域为同一个岛屿)输入：地图大小，起始坐标输出：岛屿大小代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;using namespace std;int maze[51][51];bool vis[51][51];int n,m,sum;void dfs(int x,int y)&#123; //定义一个方向数组 int next[4][2]=&#123;0,1,1,0,0,-1,-1,0&#125;; int tx,ty; for(int k=0;k&lt;4;k++) &#123; tx=x+next[k][0]; ty=y+next[k][1]; if(tx&lt;0||tx&gt;=n||ty&lt;0||ty&gt;=m) continue; //判断是否是陆地 if(maze[tx][ty]&gt;0&amp;&amp;vis[tx][ty]==0) &#123; sum++; vis[tx][ty]=1;//标记已经走过 dfs(tx,ty);//开始尝试下一个点 &#125; &#125; return;&#125;int main()&#123; int startx,starty; cin&gt;&gt;n&gt;&gt;m&gt;&gt;startx&gt;&gt;starty; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;maze[i][j]; vis[startx][starty]=1;//标记起点已经走过 sum=1; //从起点开始遍历 dfs(startx,starty); //最后输出所在岛屿大小 cout&lt;&lt;sum; return 0; /* 样例输入： 10 10 6 8 1 2 1 0 0 0 0 0 2 3 1 0 1 0 1 1 1 0 1 1 1 0 1 0 1 1 1 1 0 1 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 1 1 1 0 0 1 1 1 0 1 1 1 1 0 0 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 0 0 0 0 0 1 1 1 1 0 1 2 0 0 0 0 0 0 0 0 1 0 样例输出：38 */ &#125; 在本题中，如果斜着连在一起也算同一个小岛，则在遍历部分的循环则有必要变成这样： 12345678for(int dx=-1;dx&lt;=1;dx++) for(int dy=-1;dy&lt;=1;dy++) &#123; tx=x+dx; ty=y+dy; if(balabala) dfs(tx,ty); &#125; 类型二：题意：地图同上，判断地图中有多少个独立的小岛。思路：对每一个大于零的点进行深度优先搜索，因为等于零的点是海洋，小于零的点已经被标记，我们可以从(0,0)开始，一直枚举到(n,m)，对每个点进行尝试。代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;using namespace std;int maze[51][51];bool vis[51][51];int n,m;void dfs(int x,int y,int color)&#123; //定义一个方向数组 int next[4][2]=&#123;0,1,1,0,0,-1,-1,0&#125;; int tx,ty; maze[x][y]=color; for(int k=0;k&lt;4;k++) &#123; tx=x+next[k][0]; ty=y+next[k][1]; if(tx&lt;0||tx&gt;=n||ty&lt;0||ty&gt;=m) continue; //判断是否是陆地 if(maze[tx][ty]&gt;0&amp;&amp;vis[tx][ty]==0) &#123; vis[tx][ty]=1;//标记已经走过 dfs(tx,ty,color);//开始尝试下一个点 &#125; &#125; return;&#125;int main()&#123; int num=0; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;maze[i][j]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(maze[i][j]&gt;0) &#123; num--;//小岛需要染的颜色的编号 //每发现一个小岛应该染以不同的颜色，因此每次要-1 vis[i][j]=1; dfs(i,j,num); &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=1;j&lt;m;j++) &#123; printf(\"%3d\",maze[i][j]);//输出小岛地图 &#125; cout&lt;&lt;endl; &#125; //最后输出所在岛屿的个数 cout&lt;&lt;-num; return 0; /* 样例输入： 10 10 1 2 1 0 0 0 0 0 2 3 1 0 1 0 1 1 1 0 1 1 1 0 1 0 1 1 1 1 0 1 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 1 1 1 0 0 1 1 1 0 1 1 1 1 0 0 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 0 0 0 0 0 1 1 1 1 0 1 2 0 0 0 0 0 0 0 0 1 0 样例输出： -1 -1 0 0 0 0 0 -2 -2 0 -1 0 -3 -3 -3 0 -2 -2 0 -1 0 -3 -3 -3 -3 0 -2 -1 0 0 0 -3 -3 -3 0 0 0 0 0 0 0 -3 -3 -3 0 -3 -3 -3 0 -3 -3 -3 -3 0 -3 -3 -3 -3 -3 -3 -3 -3 0 0 -3 -3 -3 -3 -3 -3 0 0 0 0 -3 -3 -3 -3 0 -4 -4 0 0 0 0 0 0 0 -4 0 4 */&#125; 最后附一个dfs的模板 12345678910111213141516171819202122232425void dfs()//参数用来表示状态 &#123; if(到达终点状态) &#123; ...//根据题意添加 return; &#125; if(越界或者是不合法状态) return; if(特殊状态)//剪枝 return ; for(扩展方式) &#123; if(扩展方式所达到状态合法) &#123; 修改操作;//根据题意来添加 标记； dfs（）； (还原标记)； //是否还原标记根据题意 //如果加上（还原标记）就是 回溯法 &#125; &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://brillianttt.gitee.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"https://brillianttt.gitee.io/tags/dfs/"}]},{"title":"链表的学习","slug":"链表的学习","date":"2020-06-04T14:19:06.000Z","updated":"2020-06-05T00:12:44.617Z","comments":true,"path":"2020/06/04/链表的学习/","link":"","permalink":"https://brillianttt.gitee.io/2020/06/04/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"果然专业课还是一点也不能水，上学期最后的指针没认真学，现在看书自学还得先补上学期的知识漏洞😑今天复习了指针的知识，还学习了一部分链表的内容，下面记录下今天的学习内容。 在存储一大波数的时候，我们通常使用的是数组，但有时候数组显得不够灵活，比如下面这个例子。有一串已经从小到大排好序的数 2 3 5 8 9 10 18 26 32。现需要往这串数中插入 6 使其得到的新序列仍符合从小到大排列。如我们使用数组来实现这一操作，则需要将8和8后面的数都依次往后挪一位，这样操作显然很耽误时间，如果使用链表则会快很多。 指针的复习先看以下语句： 12int a;int *p; 第一行我们很熟悉了，就是定义一个整型变量 a。第二行你会发现在 p 前面多了一个号，这就表示定义了一个整型指针变量 p。即定义一个指针，只需在变量前面加一个号就OK啦。接下来，指针有什么作用呢？答案是：存储一个地址。确切地说是存储一个内存空间的地址，比如说整型变量 a 的地址。严格地说这里的指针 p 也只能存储“一个存放整数的内存空间”的地址，因为在定义的时候我们已经限制了这一点（即定义的时候*p 的前面是 int）。当然你也可以定义一个只能用来存储“一个存放浮点数的内存空间”的地址，例如： 1double *p; 简单地说，指针就是用来存储地址的。你可能要问：不就是存储地址嘛，地址不都一样吗，为什么还要分不同类型的指针呢？不要着急，待会后面再解释。接下来需要解决的一个问题：整型指针 p 如何才能存储整型变量 a 的地址呢？很简单，如下： 1p=&amp;a; &amp;这个符号很熟悉吧，就是经常在 scanf 函数中用到的&amp;。&amp;叫取地址符。这样整型指针p就获得了（存储了）整型变量a的地址，我们可以形象地理解整型指针p指向了整型变量a。p指向了a之后，有什么用呢？用处就是我们可以用指针p来操作变量a了。比如我们可以通过操作指针p来输出变量a的值，如下： 12345678910#include &lt;stdio.h&gt; int main() &#123; int a=10; int *p; //定义个指针p p=&amp;a; //指针p获取变量a的地址 printf(\"%d\",*p); //输出指针p所指向的内存中的值 return 0; //输出10&#125; 这里 printf 语句里面p 中的号叫做间接运算符，作用是取得指针 p 所指向的内存中的值。在C语言中号有三个用途，分别是：乘号，用做乘法运算，例如 56。申明一个指针，在定义指针变量时使用，例如 int p;。间接运算符，取得指针所指向的内存中的值，例如 printf(“%d”,p);。 到目前为止，你可能还是觉得指针没啥子实际作用，好好的变量 a 想输出是的话直接printf(“%d”,a); 不完了，没事搞个什么指针啊，多此一举。嗯，到目前为止貌似是这样的O(∩_∩)O 哈哈~~不要着急，真枪实弹地来了。回想一下，我们想在程序中存储一个整数 10，除了使用 int a;这种方式在内存中申请一块区域来存储，还有另外一种动态存储方法: 1malloc(4) malloc 函数的作用就是从内存中申请分配指定字节大小的内存空间。上面这行代码就申请了 4 个字节。如果你不知道 int 类型是 4 个字节的，还可以使用 sizeof(int)获取 int 类型所占用的字节数，如下： 1malloc(sizeof(int)); 现在你已经成功地从内存中申请了 4 个字节的空间来准备存放一个整数，可是如何来对这个空间进行操作呢？这里我们就需要用一个指针来指向这个空间，即存储这个空间的首地址。 12int *p; p=(int *)malloc(sizeof(int)); 需要注意，malloc 函数的返回类型是 void * 类型。void * 表示未确定类型的指针。在 C 和 C++中，void * 类型可以强制转换为任何其他类型的指针。上面代码中我们将其强制转化为整型指针，以便告诉计算机这里的 4 个字节作为一个整体用来存放整数。还记得我们之前遗留了一个问题：指针就是用来存储内存地址的，为什么要分不同类型的指针呢？因为指针变量存储的是一个内存空间的首地址（第一个字节的地址），但是这个空间占用了多少个字节，用来存储什么类型的数，则是由指针的类型来标明的。这样系统才知道应该取多少个连续内存作为一个数据。OK，现在我们可以通过指针 p 对刚才申请的 4 个字节的空间进行操作了，例如我们向这个空间中存入整数 10，如下： 1*p=10; 完整代码如下，注意当在程序中使用 malloc 函数时需要用到 stdlib.h 头文件 1234567891011#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() &#123; int *p; //定义一个指针p p=(int *)malloc(sizeof(int)); //指针p获取动态分配的内存空间地址 *p=10; //向指针p所指向的内存空间中存入10 printf(\"%d\",*p); //输出指针p所指向的内存中的值 return 0; //输出10&#125; 链表基础的学习时间有限，直接上代码和注释： 使用链表进行读入123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //这里创建一个结构体用来表示链表的结点类型struct node &#123; int data; //吹村具体数值 struct node *next; //储存下一个节点的地址&#125;; int main() &#123; struct node *head,*p,*q,*t; int i,n,a; scanf(\"%d\",&amp;n); head = NULL;//头指针初始为空,头指针的作用是方便以后从头遍历整个链表 for(i=1;i&lt;=n;i++)//循环读入n个数 &#123; scanf(\"%d\",&amp;a); //动态申请一个空间，用来存放一个结点，并用临时指针p指向这个结点 p=(struct node *)malloc(sizeof(struct node)); p-&gt;data=a;//将数据存储到当前结点的data域中 p-&gt;next=NULL;//设置当前结点的后继指针指向空，也就是当前结点的下一个结点为空 if(head==NULL) head=p;//如果这是第一个创建的结点，则将头指针指向这个结点 else q-&gt;next=p;//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点 q=p;//指针q也指向当前结点 &#125; //输出链表中的所有数 t=head; while(t!=NULL) &#123; printf(\"%d \",t-&gt;data); t=t-&gt;next;//继续下一个结点 &#125; return 0; &#125; 上面的代码中我们发现了一个很奇怪的符号“-&gt;”。-&gt;叫做结构体指针运算符，也是用来访问结构体内部成员的。因为此处 p 是一个指针，所以不能使用.号访问内部成员，而要使用-&gt;。 链表实现数据的插入12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //这里创建一个结构体用来表示链表的结点类型struct node &#123; int data; struct node *next; &#125;; int main() &#123; struct node *head,*p,*q,*t; int i,n,a; scanf(\"%d\",&amp;n); head = NULL;//头指针初始为空 for(i=1;i&lt;=n;i++)//循环读入n个数 &#123; scanf(\"%d\",&amp;a); //动态申请一个空间，用来存放一个结点，并用临时指针p指向这个结点 p=(struct node *)malloc(sizeof(struct node)); p-&gt;data=a;//将数据存储到当前结点的data域中 p-&gt;next=NULL;//设置当前结点的后继指针指向空，也就是当前结点的下一个结点为空 if(head==NULL) head=p;//如果这是第一个创建的结点，则将头指针指向这个结点 else q-&gt;next=p;//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点 q=p;//指针q也指向当前结点 &#125; scanf(\"%d\",&amp;a);//读入待插入的数 t=head;//从链表头部开始遍历 while(t!=NULL)//当没有到达链表尾部的时候循环 &#123; if(t-&gt;next-&gt;data &gt; a)//如果当前结点下一个结点的值大于待插入数，将数插入到中间 &#123; p=(struct node *)malloc(sizeof(struct node));//动态申请一个空间， 用来存放新增结点 p-&gt;data=a; p-&gt;next=t-&gt;next;//新增结点的后继指针指向当前结点的后继指针所指向的结点 t-&gt;next=p;//当前结点的后继指针指向新增结点 break;//插入完毕退出循环 &#125; t=t-&gt;next;//继续下一个结点 &#125; //输出链表中的所有数 t=head; while(t!=NULL) &#123; printf(\"%d \",t-&gt;data); t=t-&gt;next;//继续下一个结点 &#125; return 0; &#125; 模拟链表链表中的每一个结点只有两个部分。我们可以用一个数组 data 来存储每序列中的每一个数。那每一个数右边的数是谁，这一点该怎么解决呢？上一节中是使用指针来解决的，所以只需再用一个数组right来存放序列中每一个数右边的数是谁就可以了：上图的两个数组中，第一个整型数组 data 是用来存放序列中具体数字的，另外一个整型数组right是用来存放当前序列中每一个元素右边的元素在数组data中位置的。例如right[1]的值为2，就表示当前序列中1号元素右边的元素存放在data[2]中；如果是 0，例如 right[9]的值为0，就表示当前序列中9号元素的右边没有元素。现在需要在8前面插入一个6，只需将6直接存放在数组data的末尾即data[10]=6。接下来只需要将right[3]改为10，表示新序列中3号元素右边的元素存放在data[10]中。再将right[10]改为4，表示新序列中10号元素右边的元素存放在data[4]中。这样我们通过right数组就可以从头到尾遍历整个序列了（序列的每个元素的值存放在对应的数组data中），如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt; int main() &#123; int data[101],right[101]; int i,n,t,len; //读入已有的数 scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++) scanf(\"%d\",&amp;data[i]); len=n; //初始化数组right for(i=1;i&lt;=n;i++) &#123; if(i!=n) right[i]=i+1; else right[i]=0; &#125; //直接在数组data的末尾增加一个数 len++; scanf(\"%d\",&amp;data[len]); //从链表的头部开始遍历 t=1; while(t!=0) &#123; if(data[right[t]]&gt;data[len])//如果当前结点下一个结点的值大于待插入数，将数插入到中间 &#123; right[len]=right[t];//新插入数的下一个结点标号等于当前结点的下一个结点编号 right[t]=len;//当前结点的下一个结点编号就是新插入数的编号 break;//插入完成跳出循环 &#125; t=right[t]; &#125; //输出链表中所有的数 t=1; while(t!=0) &#123; printf(\"%d \",data[t]); t=right[t]; &#125; return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://brillianttt.gitee.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"位运算的使用","slug":"位运算的使用","date":"2020-06-03T13:56:43.000Z","updated":"2020-06-09T14:32:30.729Z","comments":true,"path":"2020/06/03/位运算的使用/","link":"","permalink":"https://brillianttt.gitee.io/2020/06/03/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"这是一个关于位运算的链接。 这是一个关于位运算的例题。 这是👆题的题解。 补充： 1、i&lt;32是因为2^32-1的表示数为二进制的32个1，足可使用 2、x &lt;&lt; i 是指将x按照二进制左移i位，例如00000001，左移2位变成了00000100。移动后的数转化为十进制事实上是x*2^i。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://brillianttt.gitee.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"algorithm库的使用","slug":"algorithm库的使用","date":"2020-06-03T00:38:07.000Z","updated":"2020-09-03T08:48:04.786Z","comments":true,"path":"2020/06/03/algorithm库的使用/","link":"","permalink":"https://brillianttt.gitee.io/2020/06/03/algorithm%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"algorithm头文件下的常用函数max()、min()、abs()max(x,y)和min(x,y)分别返回x和y中的最大值和最小值。且参数必须是两个（可以是浮点数）。若想返回三个数x,y,z的最大值，可以使用max（x,max(y,z))的写法。abs(x)返回x的绝对值，此处x为整数，若使用浮点数的绝对值要用math库下的fabs()。 swap()swap()用来交换x和y的值 reverse()reverse(it,it2)可以将数组指针在[it,it2)之间的元素或容器的迭代器在[it,it2)范围内的元素进行反转，举例如下： 12345678910111213#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[10]=&#123;10,11,12,13,14,15&#125;; reverse(a,a+4); for(int i=0;i&lt;6;i++)&#123; printf(\"%d \",a[i]); &#125; return 0; //输出13 12 11 10 14 15&#125; 容器内举例如下： 1234567891011121314#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;int main()&#123; string str=\"hello world\"; reverse(str.begin(),str.end()); for(int i=0;i!=str.length;i++)&#123; printf(\"%c\",str[i]); &#125; return 0; //输出dlrow olleh&#125; next_permutation()next_permutation()给出一个序列在全排列中的下一个序列。例如，当n=3的时候，全排列为123 132 213 231 312 321.这样231的下一个序列就是312. 123456789101112#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[10]=&#123;1,2,3&#125;; do&#123; printf(\"%d%d%d\\n\",a[0],a[1],a[2]); &#125;while(next_permutation(a,a+3)); return 0; //输出123\\n132\\n213\\n231\\n312\\n321\\n&#125; 在上述代码中使用循环是因为next_permutation在已经到达全排列的最后一个时会返回false,这样会方便退出循环。 fill()fill()可以把数组或容器中的某一段区间赋为某个相同的值。和memset不同，这里的赋值可以是数组类型对应范围中的任意值。 1fill(a,a+5,233)//将a[0]~a[4]均赋值为233 sort()如何使用sort排序sort函数的使用必须加上#includeusing namespace std，使用方式如下： 1sort(首元素地址（必填），尾元素的下一个地址（必填），比较函数（非必填）)； 如果不写cmp函数，则默认对前面给出的区间进行递增排序。 实现比较函数cmp基本数据类型数组的排序若不写比较函数，则默认升序排序： 123456789101112#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std; int main()&#123; int a[5]=&#123;3, 1, 4, 2&#125;; sort(a,a + 4) ; for(int i=0;i&lt;4;i++)&#123; printf (\"%d\",a[i]); &#125;//输出1234return 0;&#125; 若想要从大到小排序，则需使用比较函数cmp来“告诉”sort何时要交换元素。 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std; int cmp(int a,int b)&#123; rerturn a&gt;b;//可以理解为当a&gt;b时把a放在b前面&#125;int main()&#123; int a[5]=&#123;3, 1, 4, 2&#125;; sort(a,a + 4，cmp) ; for(int i=0;i&lt;4;i++)&#123; printf (\"%d\",a[i]); &#125;//输出4321return 0;&#125; 结构体数组的排序12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;struct node&#123; int x,y;&#125; ssd[10];bool cmp (node a,node b) &#123; if (a.x!=b.x) return a.x&gt;b.x;//x不等时按x从大到小排序 else return a.y&lt;b.y; //x相等时按y从小到大排序&#125;int main()&#123; ssd[0].x=2; // (2, 2) ssd[0].y=2; ssd[1].x=1; // &#123;1, 3) ssd[1].y=3; ssd[2].x=3; // (3, 1) ssd[2].y=1; sort(ssd,ssd+3,cmp) ; //排序 for(int i=0;i&lt;3;i++) printf(\"%d %d\\n\",ssd[i].x,ssd[i].y); return 0; /*输出 3 1 2 2 1 3 */&#125; 容器的排序在stl标准容器中，只有vector、string、deque可以使用sort。因为像set、map这种容器使用红黑树实现的，元素本身有序，故不可使用sort排序。举例。。。就不举例了，大同小异。 lower_bound()和upper_bound()lower_bound()和upper_bound()需要用在一个有序数组或容器中。lower_bound(first,last,val)用来寻找在数组或容器的［first,last) 范围内第一个值大于等于val的元素的位置，如果是数组，则返回该位置的指针；如果是容器，则返回该位置的选代器。upper_bound(first,last,val) 用来寻找在数组或容器的［first,last) 范围内第一个值大于val的元素的位置，如果是数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器。显然，如果数组或容器中没有需要寻找的元素，则lower_bound()和upper_bound()均返回可以插入该元素的位置的指针或选代器（即假设存在该元素时，该元素应当在的位置）。举例如下： 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+10;const int INF=2*int(1e9)+10;#define LL long longint cmp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; int num[6]=&#123;1,2,4,7,15,34&#125;; sort(num,num+6); //按从小到大排序 int pos1=lower_bound(num,num+6,7)-num; //返回数组中第一个大于或等于被查数的值 int pos2=upper_bound(num,num+6,7)-num; //返回数组中第一个大于被查数的值 cout&lt;&lt;pos1&lt;&lt;\" \"&lt;&lt;num[pos1]&lt;&lt;endl; cout&lt;&lt;pos2&lt;&lt;\" \"&lt;&lt;num[pos2]&lt;&lt;endl; sort(num,num+6,cmp); //按从大到小排序 int pos3=lower_bound(num,num+6,7,greater&lt;int&gt;())-num; //返回数组中第一个小于或等于被查数的值 int pos4=upper_bound(num,num+6,7,greater&lt;int&gt;())-num; //返回数组中第一个小于被查数的值 cout&lt;&lt;pos3&lt;&lt;\" \"&lt;&lt;num[pos3]&lt;&lt;endl; cout&lt;&lt;pos4&lt;&lt;\" \"&lt;&lt;num[pos4]&lt;&lt;endl; return 0; &#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://brillianttt.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"库函数的使用","slug":"库函数的使用","permalink":"https://brillianttt.gitee.io/tags/%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/"}]},{"title":"code::blocks设置调试和主题背景","slug":"codeblocks设置调试和主题背景","date":"2020-06-02T00:48:11.732Z","updated":"2020-06-02T01:59:49.203Z","comments":true,"path":"2020/06/02/codeblocks设置调试和主题背景/","link":"","permalink":"https://brillianttt.gitee.io/2020/06/02/codeblocks%E8%AE%BE%E7%BD%AE%E8%B0%83%E8%AF%95%E5%92%8C%E4%B8%BB%E9%A2%98%E8%83%8C%E6%99%AF/","excerpt":"","text":"设置调试安装好Code::Block后完成编译和运行后却无法调试，弹出Error:You need to specify a debugger program in the debuggers’s settings.无法编译根据提示信息我们需要指定一个debugger program，根据提示我们可以知道指定的菜单栏settings。我们可以看到默认状态下路径是空的，那么我们就需要设置一个路径。 找到code::block的默认安装路径并进入CodeBlocks\\MinGW\\gdb32\\bin选择gdb32.exe。单击OK即可开始进行编译。 设置主题背景首先进入codeblocks官网找到color theme的代码。 紧接着在C盘中找到CodeBlocks/default.conf，注意default.conf文件不再你的安装文件夹下，而是在系统盘下，以win10系统为例，路径为：user/你的用户名/AppData/Roaming/CodeBlocks。 在进行下一步前，要确保codeblocks已经关闭。 下一步是通过记事本打开default.conf文件，把default.conf文件中的代码全部替换为第一步中在codeblocks官网上找到的代码，保存并关闭。注意在替default.conf文件代码时最好做好备份以免出错。 下一步就是感受快乐了！！！ 下下一步，如果想要改变其他风格可以在Settings/Editor/Syntax Highlighting/colour theme中选择想要的风格，也可以自定义各种颜色，还可以在margins and caret–&gt;caret的color中设置光标颜色。","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://brillianttt.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"code::blocks","slug":"code-blocks","permalink":"https://brillianttt.gitee.io/tags/code-blocks/"}]},{"title":"C++STL学习笔记","slug":"C++STL容器的学习","date":"2020-05-13T13:41:57.792Z","updated":"2020-10-15T16:36:55.456Z","comments":true,"path":"2020/05/13/C++STL容器的学习/","link":"","permalink":"https://brillianttt.gitee.io/2020/05/13/C++STL%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"最近开始学习c++的stl容器，下面记录一些学习的笔记。 STL（Standard Template Library）,中文名为标准模板库，其中封装了许多容器，而容器可以理解为能实现很多功能的东西。在写代码时可以快速调用他们，省去了自己书写完整的时间。 vector的常见用法vector本身可以作为数组使用，在元素不确定的场合可以很好的节省空间 vector的定义123456789101112131415#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; name; vector&lt;double&gt; name; vector&lt;char&gt; name; //如果类型名为vector，就为以下定义方式👇(可以理解为二维数组) vector&lt;vector&lt;int&gt;&gt; name; //vector数组的定义： vector&lt;typename&gt; Arrayname[arraySize]; //例如这样定义（这样其中的每一个都是一个vector容器）： vector nb[666]；&#125; vector二维数组的初始化初始化一个6*5的二维数组： 1234567891011121314#include&lt;iostream&gt;using namespace std;int main() &#123; vector&lt;vector&lt;int&gt; &gt;num = &#123; &#123;1,1,1,0,1,1&#125;,&#123;1,0,1,1,1,1&#125;,&#123;1,1,1,0,0,1&#125;,&#123;1,0,1,0,0,1&#125;,&#123;1,1,1,1,1,1&#125; &#125;; //二维数组初始化 //vector&lt;vector&lt;int&gt;&gt; vec(10, vector&lt;int&gt;(10)); vector&lt;vector&lt;int&gt; &gt;right(num.size(), vector&lt;int&gt;(num[0].size())); vector&lt;vector&lt;int&gt; &gt;down(num.size(), vector&lt;int&gt;(num[0].size())); construct(num, right, down); cout &lt;&lt; calculate(num, right, down) &lt;&lt; endl; return 0;&#125; 也可以这么写： 12std::vector &lt;int&gt; vec(10,90); //将10个一维动态数组初始为90std::vector&lt;std::vector&lt;int&gt; &gt; vec(row,vector&lt;int&gt;(col,0)); //初始化row * col二维动态数组，初始化值为0,其实就是每一行初始化为列数个0 vector的访问vector有两种访问方式：通过下标或者迭代器。下标访问即为以前学过的知识，迭代器访问为c++中新的概念，可以理解为类似指针的东西，可以如下定义： 123vector&lt;typename&gt;::iterator it;//这样就可以通过*it来访问vector里的元素//在循环中使用可以如下定义：for(vector&lt;typename&gt;::iterator it=name.begin();it!=name.end();it++)&#123;&#125; 但是这样写比较繁琐，我们可以使用auto关键字简化代码： 123auto i=name.begin();//在循环中使用可以如下定义：for(auto it=name.begin();it!=name.end();it++)&#123;&#125; vector常用函数1234567891011121314vector&lt;int&gt; name;name.push_back(i)//push_back(i)在name的末尾添加元素i，常和循环连用以输入输出数据name.begin()//取name的首元素地址，和迭代器连用auto i=name.begin(),使得i指向这个地址name.end()//取name的尾地址，用法同上name.pop_back()//删除vector的尾元素name.size()//获得vector中元素的个数，返回unsigned类型，可以用%d输出size_row = name.size(); //获取二维数组行数size_col = name[0].size(); //获取二维数组列数name.clear()//清空vector中的所有元素name.insert(it，x)//用来向vector的任意迭代器it处插入一个元素x，例如：name.insert(name.begin()+2,-1);name.erase(it)//删除迭代器it处的元素name.erase(name.begin()+3)//注意删除的是name[4]name.erase(first,last)//删除[first,last)内的所有元素name.erase(name.first(),name.end())//效果同name.clear() set的常见用法set翻译为集合，是一个内部自动有序并且不含有重复元素的容器，在需要重复的时候，可以快捷的使用set实现自动排序（升序排列）并且去重。 set的定义12set&lt;typename&gt; name;//单独定义一个setset&lt;typename&gt; Arrayname[arraySize];//set数组的定义，Arrayname[0]~Arrayname[arraySize-1]中每一个都是一个set容器 set内元素的访问set只能同迭代器访问： 12set&lt;typename&gt;::iterator it;auto it=name.(); 由于除了vector和string之外的stl容器都不支持*(it+i)的访问方式，因此只能使用枚举法： 1234567891011121314#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main()&#123; set&lt;int&gt; nb; for(int i=10;i&gt;2;i--) &#123; nb.insert(i); &#125; for(auto i=nb.begin();i!=nb.end();i++)&#123; printf(\"%d \",*i); &#125; &#125;//输出 3 4 5 6 7 8 9 10（实现了自动从小到大排序） set常用函数 123456789name.insert(x)//将x插入set容器中，并自动实现递增排序和去重name.find(value)//返回set中对应值为value的迭代器，如printf(\"%d\",*(name.find(2)));name.erase()//用法同vector中的函数一样，一般还可与name.find()连用，实现“找到并删除”name.size()//用来获得set内元素个数name.clear()//清空set内所有元素name.empty()//若集合为空，返回truename.count()//返回某个值元素的个数lower_bound()//lover_bound(val)返回值指向大于（或等于）val的第一个元素的迭代器）upper_bound()//返回大于某个值元素的迭代器 string的常见用法 string对字符串常用的功能进行了封装，使得操作更方便。在使用string时需要添加string头文件即#include string的定义 定义string的方式和基本数据类型相同，可以直接定义 12string str;string str=\"abc\"; string内容的访问通过下标访问 1234string str=\"abcd\";for(int i=0;i&lt;str.length();i++)&#123; printf(\"%c\",str[i]);&#125;//输出结果为abcd 若要输入和输出整个字符串可用cin和cout还有c_str() 1234string str;cin&gt;&gt;str;cout&lt;&lt;str&lt;&lt;endl;printf(\"%s\",str.c_str());//将string型转化为字符数组输出 通过迭代器访问1234567string::iterator it;string str=\"abcd\"; -for(auto it=str.begin();it!=str.end();it++)&#123; printf(\"%c\",*it); printf(\"%c\",*(str.begin()+3));&#125; string常用函数拼接： 123string str1=\"abc\",str2=\"xyz\",str3;str3=str1+str2;//直接将str1和2拼接到str3上str1+=str2；//将str2加到str1后面 比较： 1if(str1&gt;str2) printf(\"balabala\");//按照字典序比较 长度： 1printf(\"%d %d\",str.length(),str.size()); 插入元素： 12str.insert(3,str2);//str2插入str[3]位置str.insert(str.begin(+1),str2.begin(),str2.end());//name.insert(x,y,z)x为待插入位置，y、z分别为要插入字符串的首尾迭代器 其他函数： 12345678910str.erase(it)//删除单个元素，it为需要删除的元素迭代器str.erase(first,last)；//first为需要删除的区间的起始迭代器，last为区间末尾迭代器的下一个地址，即为删除[first,last)str.erase(pos,length);//pos为开始删除的起始位置，length为删除字符个数str.clear();//清空string中的数据str.substr(pos,len)//返回从pos位开始，长度为len的子串str.find(str2)//当str2是str的子串时，返回其在str中第一次出现的位置(即str2第一个字符出现的位置)，若str2不是str的子串时返回string::nopsstring::npos//是一个常数，由于是unsigned_int类型，也可认为时ugsigned_int的最大值str.replace(pos,len,str2)//把str从pos位开始，长度为len的子串替换为str2str.replace(it1，it2，str2)//把str的迭代器[it1，it2)范围的子串替换为str2reverse(str.begin(),str.end()-5);//反转指定区域的字符 map的常见用法map翻译为映射，是常用的stl容器之一。map可以将任何基本类型（包括stl容器）映射到任何类型（也包括stl容器）；在使用map的时候还要添加map头文件。在需要建立字符或字符串与整数之间映射的题目，使用map可以减少代码量；判断大整数或者其它类型的数据是否存在的题目，可以把map当bool使用。 map的定义123map&lt;typename1,typename2&gt;mp;//1、2分别代表映射前和映射后的类型，如果两种类型相同，就相当于普通的数组。map&lt;string,int&gt;mp;//若为字符串到整型的映射，必须使用string而不能用char。map&lt;set&lt;int&gt;,string&gt;mp;//将set容器映射到一个字符串 map容器内元素的访问通常有两种访问方式：通过下标和通过迭代器。 通过下标访问12345678910#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['c']=20; mp['c']=30; printf(\"%d\",mp['c']);&#125;//输出30 通过迭代器访问1map&lt;typename1,typename2&gt;::iterator it;//map迭代器的定义，同样可以用auto 因为map的每一个映射都有两个typename，所以访问方式略有不同，map可以使用it-&gt;first来访问第一个参数（键），it-&gt;second来访问第二个参数（值）。下面举个栗子。 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['m']=20; mp['b']=30; mp['y']=40; for(map&lt;char,int&gt;::iterator it=map.begin();it!=map.end();it++)//也可以写为auto it=begin() &#123; printf(\"%c %d\\n\",it-&gt;first,it-&gt;second); &#125;&#125;//输出如下： b 30 m 20 y 40 有没有发现map按“键”对它进行了从小到大的排序这是通过红黑树实现的（set也是），在建立映射的时候会自动实现从小到大的排序功能。（ps：我暂时也不知道红黑树是什么，等之后学到了回来补充。） map常用函数find()函数123456789101112#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['a']=1; mp['b']=2; mp['c']=3; auto i=mp.find('b');//find(key)返回键为key的映射的迭代器 printf(\"%c %d\",it-&gt;first,it-&gt;second);//输出b 2&#125; erase()erase()有两种用法：删除单个元素和删除一个区间内的所有元素 删除单个元素12345678910111213#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['a']=1; mp['b']=2; mp['c']=3; auto it=mp.find('b');//find(key)返回键为key的映射的迭代器 mp.erase(it)l//删除b 2 mp.erase(key)//key为想要删除的映射的键，如mp.erase('a');&#125; 删除多个元素（区间内）mp.erase(first,last)//first为需要删除的区间的起始迭代器，last为需要删除的区间的末尾迭代器的下一个地址，即为删除左闭右开的区间[first,last),举例如下： 123456789101112#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['a']=1; mp['b']=2; mp['c']=3; auto it=mp.find('b');//find(key)返回键为key的映射的迭代器 mp.erase(it，mp.end())；//删除it后的所有映射，即b 2和c 3&#125; 其他函数size()用来获得map中映射的对数。clear()用来情况map中的所有元素。 quese的常见用法quese翻译为队列，在STL中主要是实现先进先出的容器。在实现广度优先搜索时，可以不用自己动手实现一个队列，而是用queue作为代替，以提高程序的准确性。 queue的定义要使用queue，需要先添加头文件#include，并且在头文件下面加上 using namespace std才可以。定义写法和其他容器一样，typename可以说任意基本数据类型或容器。 1queue&lt;typename&gt;name; queue容器内元素的访问由于queue（队列）本就是一种先进先出的限制性数据结构，因此在stl中只能通过front（）来访问队首元素，或是通过back（）来访问队尾元素。举例如下： 12345678910111213#include&lt;stdio.h&gt;#include&lt;queue&gt;using namespace std;int main()&#123; queue&lt;int&gt; q; for(int i=1;i&lt;=5;i++) &#123; q.push(i);//push(i)用以将i压入队列，因此一次入队1 2 3 4 5 &#125; printf(\"%d %d\",q.front(),q.back());//输出1 5 return 0;&#125; queue常用函数12345678910111213#include&lt;stdio.h&gt;#include&lt;queue&gt;using namespace std;int main()&#123; queue&lt;int&gt; q; q.push()//将x压入队列 q.front()//获得队首元素 q.back()//获得队尾元素 q.pop()//令队首元素出队 q.empty()//检测queue是否为空，返回true则空，false则非空 q.size()//返回queue内元素的个数&#125; 特别注意，在使用front()和pop()函数前，必须用empty()判断队列是否为空，否则可能因为队空而出现错误。 priority_queue的常见用法priority_queue又称优先队列，其底层逻辑是用堆来实现的（我也不知道堆是啥，学了回来填坑）。在优先队列中，队首元素一定是当前队列中优先级最高的那个。在任何时候都可以往优先队列里加入(push)元素，而优先队列的的底层数据结构堆（heap）会随时调整，使得每次的队首元素都是优先级最大的。 priority_queue的定义要使用优先队列，应先添加头文件#include，定义写法和其他stl容器一致，typename可以是任意类型或容器。 1priority_queue&lt;typename&gt;name; priority_queue容器内元素的访问和队列不同，优先队列内没有front()和back()函数，而只能通过top()函数来访问队首元素（即堆顶元素），也就是优先级最高的元素。 priority_queue常用函数市离解析12345push()//push(x)将令x入队top()//top()可以获得队首元素pop()//令队首元素出队empty()//检测优先队列是否为空，返回true则为空，false则为非空size()//返回优先队列内元素的个数 priority_queue内元素优先级的设置基本数据类型的优先级设置基本数据类型即为int型、double型、char型等可以直接使用的数据类型，优先队列对他们的优先级设置一般是数字大的优先级搞，因此队首元素就是优先队列内元素最大的那个（char型则为字典序最大的）。对于基本数据类型来说，下面是两种优先队列的定义是等价的（以int型为例，注意最后两个&gt;之间有一个空格）： 12priority_queue&lt;int&gt; q;priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q; 在第二种定义时多了两个参数，其中vector填写的时来承载底层数据结构堆(heap)的容器,若为double或char型只需更改&lt;&gt;内的内容即可；less则是堆第一个参数的比较类，less表示数字大的优先级越大，而greater表示数字小的优先级越大。因此若想让优先队列将最小的元素放在队首只需进行如下定义： 1priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; 举一个栗子： 12345678910111213#include &lt;cstdio&gt;#include&lt;queue&gt;using namespace std;int main()&#123; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; q.push(3); q.push(4); q.push(1); printf(\"%d\",q.top());//输出1 return 0;&#125; 结构体优先级设置没看懂书上咋设置的 看懂了再回来填坑😂 stack的常见用法stack翻译为栈，是stl中实现的一个后进先出的容器。 stack的定义要使用 stack, 应先添加头文件＃include , 并在头文件下面加上“using namespace std; ”， 然后就可以使用了。 其定义的写法和其他STL容器相同，typename 可以任意基本数据类型或容器。 stack容器内元素的访问由于栈本身是一种后进先出的数据结构，在stl的stack中只能通过top()来访问栈顶元素，举例如下： 1234567891011121314#include &lt;cstdio&gt;#include&lt;stack&gt;using namespace std;int main()&#123; stack&lt;int&gt;st; for(int i=0;i&lt;5;i++) &#123; st.push(i); &#125; printf(\"%d\\n\",st.top());//输出4 return 0;&#125; stack常用函数12345push()//push(x)将x入栈top()//获得栈顶元素pop()//弹出栈顶元素empty()//检测stack内是否为空，返回true为空，返回false为非空size()//返回栈内元素个数 stack的常见用途用来模拟实现一些递归，防止程序对栈内存的限制而导致程序运行出错。一般来说，程序的栈内存空间很小，对有些题目来说，如果用普通的函敷来进行递归，一旦递归层数过深（不同机器不同，约几千至几万层）， 则会导致程序运行崩溃。如果用栈来模拟递归算法的实现，则可以避免这一方面的问题（不过这种应用出现较少）。 pair的常见用法pair是一个很实用的“小玩意”， 当想要将两个元素绑在一起作为一个合成元素、又不想要因此定义结构体时，使用 pair 可以很方便地作为一个代替品。也就是说，pair 实际上可以看作一个内部有两个元素的结构体，且这两个元素的类型是可以指定的，如下面的短代码所示： 1234struct pair&#123; typename1 first; typename2 second;&#125; pair的定义要使用 pair, 应先添加头文件＃include , 并在头文件下面加上＂using namespacestd; ”， 然后就可以使用了，注意：由于map的内部实现中涉及pair, 因此添加map头文件时会自动添加 utility 头文件，此时如果需要使用 pair, 就不需要额外再去添加 utility 头文件了。因此，记不住“utility” 拼写的读者可以愉懒地用 map头文件来代替 utility 头文件。pair 有两个参数，分别对应 first 和 second 的数据类型，它们可以是任意基本数据类型或容器。 1pair&lt;typename1,typename2&gt; name; 因此想要定义参数为string和int类型的pair，就可以使用如下写法： 1pair&lt;string,int&gt; p; 如果要顺便进行初始化，可以这样： 1pair&lt;string,int&gt; p(\"haha\",5); pair中元素的访问pair中只有两个元素，分别为first和second，只需按照正常结构体的方法去访问。 12345678910111213141516171819include &lt;iostream&gt;＃include &lt;utility&gt;＃include &lt;string&gt;using namespace std;int main () &#123; pair &lt;string,int&gt; p; p.first=\"haha\"; p.second=5; cout&lt;&lt;p.first &lt;&lt;\" \"&lt;&lt;p.second &lt;&lt;lendl; p=make_pair (\"xixi\", 55) ; cout&lt;&lt;p.first &lt;&lt;\" \"&lt;&lt;p.second &lt;&lt;endl; p=pair&lt;string,int&gt; (\"heihei\",555); cout&lt;&lt;p.first &lt;&lt;\" \"&lt;&lt;p.second &lt;&lt; endl; return 0; //输出： haha 5 // xixi 55 // heihei 555&#125; pair常用函数比较操作数两个pair类型数据可以直接使用==、!=、&lt;、&lt;=、&gt;、&gt;=比较大小，比较规则是先以first 的大小作为标准，只有当first 相等时才去判别second的大小。 12345678910111213141516include &lt;cstdio&gt; ＃include &lt;utility&gt; using namespace std; int main ()&#123; pair&lt;int,int&gt; p1(5,10): pair&lt;int, int&gt; p2(5, 15); pair&lt;int,int&gt; p3 (10, 5) : if(p1&lt;p3) printf(\"pl &lt;p3\\n\"); if(pl&lt;=p3) printf(\"pl&lt;=p3\\n\"); if(p1&lt;p2) printf(\"pl&lt;p2\\n\"); return 0; //输出: // p1&lt;p3 // p1&lt;=p3 // p1&lt;p2 pair的常见用途1、代替二元结构体及其构造函数，节省编码时间。2、作为map的键值对来进行插入，如这个例子 1234567891011121314151617#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;string,int&gt;mp; mp.insert(make_pair(\"haha\",10)); for(map&lt;string,int&gt;::iterator it=mp.begin();it!=mp.end();it++) &#123; cout&lt;&lt;it-&gt;first&lt;&lt;\" \"&lt;&lt;it-&gt;second&lt;&lt;endl; &#125; return 0; //输出： // haha 10 // heihei 5&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://brillianttt.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"STL","slug":"STL","permalink":"https://brillianttt.gitee.io/tags/STL/"},{"name":"C/C++","slug":"C-C","permalink":"https://brillianttt.gitee.io/tags/C-C/"}]},{"title":"动态规划之最长上升子序列","slug":"动态规划之最长上升子序列","date":"2020-04-05T11:30:22.000Z","updated":"2020-06-03T02:06:18.975Z","comments":true,"path":"2020/04/05/动态规划之最长上升子序列/","link":"","permalink":"https://brillianttt.gitee.io/2020/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"动态规划 动态规划指的是将一个繁杂的问题分解成子问题之后，通过求解子问题的最优解，从而求得整体最优解。 最长上升子序列问题如下：输入数据： 输入的第一行是序列的长度N(1&lt;=N&lt;=1000),第一行给出序列的N个整数，这些整数的取值范围在0-10000. 输出要求： 最长上升子序列的长度。 输入样例： 71 7 3 5 9 4 8 输出样例： 4 范例代码： 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int maxlen[100]; int s[100]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s[i]; maxlen[i] = 1; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (s[i] &gt; s[j]) &#123; maxlen[i] = max(maxlen[i], maxlen[j] + 1); &#125; &#125; &#125; cout &lt;&lt; *max_element(maxlen + 1, maxlen + n + 1);&#125; 讲解： 123456789int n; cin &gt;&gt; n; int maxlen[100]; int s[100]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s[i]; maxlen[i] = 1; &#125; 这一部分是输入数据，并且让存储 以当前下标为终点的子序列的个数 的maxlen数组都初始化为1. 12345678910for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (s[i] &gt; s[j]) &#123; maxlen[i] = max(maxlen[i], maxlen[j] + 1); &#125; &#125; &#125; 这一部分是正式求解&ensp;以当前下标为终点的最长上升子序列&ensp;的长度，并且分别存储在maxlen数组内。i每往后循环一次，j就要将i之前的数据都循环一遍。当s[i]&gt;s[j]时就要求maxlen[j]+1与maxlen[i]之间的最大值进行maxlen[i]的更新。注：之所以需要每次都求maxlen[i]和maxlen[j]+1的最大值，而不直接将maxlen[j]+1赋值给maxlen[i]，是因为maxlen[i]之前的更新可能已经使maxlen[i]&gt;maxlen[[j]+1，故 此时maxlen[i]应保持不变。 最后一部分为输出部分，调用max_element函数输出manlen数组内的最大值。 注：max_element函数返回值是一个指针&emsp;&emsp;max_element和max函数需要调用头文件algorithm","categories":[{"name":"算法","slug":"算法","permalink":"https://brillianttt.gitee.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://brillianttt.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"排序算法","slug":"排序算法","date":"2020-04-03T02:19:36.000Z","updated":"2022-05-01T14:24:48.964Z","comments":true,"path":"2020/04/03/排序算法/","link":"","permalink":"https://brillianttt.gitee.io/2020/04/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"这个链接里面有常见的排序算法，并且有各种语言的实现方法。 归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt; using namespace std; void merge(int a[], int s, int m, int e, int tmp[])&#123; int pb = 0; int p1 = s, p2 = m+1; while (p1&lt;=m&amp;&amp;p2&lt;=e) &#123; if (a[p1] &gt; a[p2]) tmp[pb++] = a[p2++]; else tmp[pb++] = a[p1++]; &#125; while (p1&lt;=m) &#123; tmp[pb++] = a[p1++]; &#125; while (p2&lt;=e) &#123; tmp[pb++] = a[p2++]; &#125; for (int j = 0; j &lt;= e-s; ++j) &#123; a[s+j] = tmp[j]; &#125;&#125;void mergesort(int a[], int s, int e, int tmp[])&#123; if (s &lt; e) &#123; int m = s + (e - s) / 2; mergesort(a, s, m, tmp); mergesort(a, m + 1, e, tmp); merge(a, s, m, e, tmp); &#125;&#125;int a[9] = &#123; 1,2,3,6,5,4,7,8,9 &#125;;int b[9];int main()&#123; mergesort(a, 0, 8, b); for (int i = 0; i &lt; 9; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; return 0;&#125; 快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt; int a[101],n;//定义全局变量，这两个变量需要在子函数中使用 void quicksort(int left,int right) &#123; int i,j,t,temp; if(left&gt;right) return; temp=a[left]; //temp中存的就是基准数 i=left; j=right; while(i!=j) &#123; //顺序很重要，要先从右往左找 while(a[j]&gt;=temp &amp;&amp; i&lt;j) j--; //再从左往右找 while(a[i]&lt;=temp &amp;&amp; i&lt;j) i++; //交换两个数在数组中的位置 if(i&lt;j)//当哨兵i和哨兵j没有相遇时 &#123; t=a[i]; a[i]=a[j]; a[j]=t; &#125; &#125; //最终将基准数归位 a[left]=a[i]; a[i]=temp; quicksort(left,i-1);//继续处理左边的，这里是一个递归的过程 quicksort(i+1,right);//继续处理右边的，这里是一个递归的过程 &#125; int main() &#123; int i,j,t; //读入数据 scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); quicksort(1,n); //快速排序调用 //输出排序后的结果 for(i=1;i&lt;=n;i++) printf(\"%d \",a[i]); getchar();getchar(); return 0; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://brillianttt.gitee.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://brillianttt.gitee.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"markdown语法的使用教程","slug":"markdown语法的使用教程","date":"2020-03-28T02:22:46.000Z","updated":"2020-06-03T14:03:28.650Z","comments":true,"path":"2020/03/28/markdown语法的使用教程/","link":"","permalink":"https://brillianttt.gitee.io/2020/03/28/markdown%E8%AF%AD%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"这是一个关于markdown语法的链接这是关于markdown插入链接的语法的链接","categories":[{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/categories/markdown%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/tags/markdown%E8%AF%AD%E6%B3%95/"},{"name":"链接","slug":"链接","permalink":"https://brillianttt.gitee.io/tags/%E9%93%BE%E6%8E%A5/"}]},{"title":"markdown插入代码语言类型","slug":"markdown插入代码语言类型","date":"2020-03-27T03:20:21.000Z","updated":"2020-06-03T14:03:27.581Z","comments":true,"path":"2020/03/27/markdown插入代码语言类型/","link":"","permalink":"https://brillianttt.gitee.io/2020/03/27/markdown%E6%8F%92%E5%85%A5%E4%BB%A3%E7%A0%81%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"markdown插入代码语言类型 在使用markdown进行写文章时有时需要插入代码块，但是对于新手来说并不太清楚各种语言是怎样标记的，本文总结出来，如下：","categories":[{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/categories/markdown%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/tags/markdown%E8%AF%AD%E6%B3%95/"}]},{"title":"0号测试","slug":"今晚做一丢丢更新","date":"2020-03-26T13:50:33.000Z","updated":"2020-05-15T14:46:59.978Z","comments":true,"path":"2020/03/26/今晚做一丢丢更新/","link":"","permalink":"https://brillianttt.gitee.io/2020/03/26/%E4%BB%8A%E6%99%9A%E5%81%9A%E4%B8%80%E4%B8%A2%E4%B8%A2%E6%9B%B4%E6%96%B0/","excerpt":"","text":"可能会更改一下界面，以后经常更新设置，也经常记录学习的经历和经验。 123456#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;\"hello world\";&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://brillianttt.gitee.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"过生日","slug":"过生日","date":"2020-01-21T02:17:24.692Z","updated":"2020-01-21T02:25:31.946Z","comments":true,"path":"2020/01/21/过生日/","link":"","permalink":"https://brillianttt.gitee.io/2020/01/21/%E8%BF%87%E7%94%9F%E6%97%A5/","excerpt":"","text":"今天小马过十九岁生日了！今天似乎确凿是在世的6986天","categories":[],"tags":[]},{"title":"小马的2019年度总结","slug":"小马的2019年度总结","date":"2020-01-20T04:09:29.478Z","updated":"2020-05-26T10:05:41.907Z","comments":true,"path":"2020/01/20/小马的2019年度总结/","link":"","permalink":"https://brillianttt.gitee.io/2020/01/20/%E5%B0%8F%E9%A9%AC%E7%9A%842019%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","excerpt":"","text":"2019，注定是不平凡的一年，从年初还在班里埋头学习，到年末在大学广场里high歌， 这一年或者这几年的辛酸苦辣，仿佛都在今天 结束了。三年前，带着中考失利的辛酸来到了高中。从那年的暑假励志高考要弯道超车，要证明自己可以好好学习，也可以优秀，也不负张老师的希望。这三年，好像一直都没有融进8班或11班的大家庭，老实说，仿佛对大环境有着天然的排斥。现在看来，自己的想法是很愚蠢的，所有的路都是自己一步一步走过来的，结果自然也要自己接受。 高中三年，是痛苦并快乐着的，痛苦是因为开始适应环境，快乐是因为自己在慢慢成长。因为自己的凉薄和冷漠，也有年少无知的轻狂，在高二那年的夏天，经历了自己人生的一个低谷，两件事情，双重打击，很长一段时间都活在愧疚中。 快乐是因为自己的学习在不断的进步，印象很清楚，进入18中排名是248，高一第一次月考就考了32名，虽然自己在之后考试中都在1、2考场徘徊着，但那时我知道，自己很努力了，三四月做的事情，在八九月自有答案。没有见过凌晨四点的洛杉矶，但三年来天天见凌晨四点半的呼和浩特。在颓废和打鸡血的交织中，高中三年，终于在今年夏天落下了帷幕。大学嘛，时间如白驹过隙，一不小心就过了八分之一啦。凡此过往，皆为序章，辛辛苦苦 熬了三年，大学的生活，不正是当年梦寐以求的吗，希望自己像高中一样，记住自己的初心，好好努力，不负自己的芳华。 谢谢所有在我最痛苦最难受的时候给予我帮助的人，谢谢自己的家人，在高中三年给予了我最无微不至的照顾，谢谢小姐姐的暖心，也谢谢自己的好兄弟和好伙伴们，陪我一起度过了高中三年。所有快乐，所有争执，所有幸福，都化为生活的碎片，留存在记忆当中。","categories":[],"tags":[]}],"categories":[{"name":"实习笔记","slug":"实习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"笔记","slug":"笔记","permalink":"https://brillianttt.gitee.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"学习","slug":"学习","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"项目","slug":"项目","permalink":"https://brillianttt.gitee.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"随笔","slug":"随笔","permalink":"https://brillianttt.gitee.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"博客开发","slug":"博客开发","permalink":"https://brillianttt.gitee.io/categories/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91/"},{"name":"数学","slug":"数学","permalink":"https://brillianttt.gitee.io/categories/%E6%95%B0%E5%AD%A6/"},{"name":"算法","slug":"算法","permalink":"https://brillianttt.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/categories/markdown%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"实习","slug":"实习","permalink":"https://brillianttt.gitee.io/tags/%E5%AE%9E%E4%B9%A0/"},{"name":"MyBatisPlus","slug":"MyBatisPlus","permalink":"https://brillianttt.gitee.io/tags/MyBatisPlus/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://brillianttt.gitee.io/tags/SpringBoot/"},{"name":"Java","slug":"Java","permalink":"https://brillianttt.gitee.io/tags/Java/"},{"name":"面试","slug":"面试","permalink":"https://brillianttt.gitee.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Spring","slug":"Spring","permalink":"https://brillianttt.gitee.io/tags/Spring/"},{"name":"数字取证技术","slug":"数字取证技术","permalink":"https://brillianttt.gitee.io/tags/%E6%95%B0%E5%AD%97%E5%8F%96%E8%AF%81%E6%8A%80%E6%9C%AF/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brillianttt.gitee.io/tags/SpringMVC/"},{"name":"ssm","slug":"ssm","permalink":"https://brillianttt.gitee.io/tags/ssm/"},{"name":"排序","slug":"排序","permalink":"https://brillianttt.gitee.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"复杂度","slug":"复杂度","permalink":"https://brillianttt.gitee.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"name":"MySQL","slug":"MySQL","permalink":"https://brillianttt.gitee.io/tags/MySQL/"},{"name":"注解和反射","slug":"注解和反射","permalink":"https://brillianttt.gitee.io/tags/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"},{"name":"JDBC","slug":"JDBC","permalink":"https://brillianttt.gitee.io/tags/JDBC/"},{"name":"Java - 集合","slug":"Java-集合","permalink":"https://brillianttt.gitee.io/tags/Java-%E9%9B%86%E5%90%88/"},{"name":"IO流","slug":"IO流","permalink":"https://brillianttt.gitee.io/tags/IO%E6%B5%81/"},{"name":"SVG","slug":"SVG","permalink":"https://brillianttt.gitee.io/tags/SVG/"},{"name":"D3","slug":"D3","permalink":"https://brillianttt.gitee.io/tags/D3/"},{"name":"笔记","slug":"笔记","permalink":"https://brillianttt.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"学习 - 深度学习","slug":"学习-深度学习","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"项目","slug":"项目","permalink":"https://brillianttt.gitee.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"随笔","slug":"随笔","permalink":"https://brillianttt.gitee.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"QT","slug":"QT","permalink":"https://brillianttt.gitee.io/tags/QT/"},{"name":"学习","slug":"学习","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"BUG解决","slug":"BUG解决","permalink":"https://brillianttt.gitee.io/tags/BUG%E8%A7%A3%E5%86%B3/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://brillianttt.gitee.io/tags/OpenCV/"},{"name":"C/C++","slug":"C-C","permalink":"https://brillianttt.gitee.io/tags/C-C/"},{"name":"RSA","slug":"RSA","permalink":"https://brillianttt.gitee.io/tags/RSA/"},{"name":"仿射密码","slug":"仿射密码","permalink":"https://brillianttt.gitee.io/tags/%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81/"},{"name":"密码学","slug":"密码学","permalink":"https://brillianttt.gitee.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"照片","slug":"照片","permalink":"https://brillianttt.gitee.io/tags/%E7%85%A7%E7%89%87/"},{"name":"猫","slug":"猫","permalink":"https://brillianttt.gitee.io/tags/%E7%8C%AB/"},{"name":"Summer summary","slug":"Summer-summary","permalink":"https://brillianttt.gitee.io/tags/Summer-summary/"},{"name":"数学","slug":"数学","permalink":"https://brillianttt.gitee.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"暑假学习","slug":"暑假学习","permalink":"https://brillianttt.gitee.io/tags/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0/"},{"name":"0-1背包问题","slug":"0-1背包问题","permalink":"https://brillianttt.gitee.io/tags/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"学习总结","slug":"学习总结","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"bfs","slug":"bfs","permalink":"https://brillianttt.gitee.io/tags/bfs/"},{"name":"dfs","slug":"dfs","permalink":"https://brillianttt.gitee.io/tags/dfs/"},{"name":"链表","slug":"链表","permalink":"https://brillianttt.gitee.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"位运算","slug":"位运算","permalink":"https://brillianttt.gitee.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"库函数的使用","slug":"库函数的使用","permalink":"https://brillianttt.gitee.io/tags/%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"name":"code::blocks","slug":"code-blocks","permalink":"https://brillianttt.gitee.io/tags/code-blocks/"},{"name":"STL","slug":"STL","permalink":"https://brillianttt.gitee.io/tags/STL/"},{"name":"动态规划","slug":"动态规划","permalink":"https://brillianttt.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/tags/markdown%E8%AF%AD%E6%B3%95/"},{"name":"链接","slug":"链接","permalink":"https://brillianttt.gitee.io/tags/%E9%93%BE%E6%8E%A5/"},{"name":"测试","slug":"测试","permalink":"https://brillianttt.gitee.io/tags/%E6%B5%8B%E8%AF%95/"}]}