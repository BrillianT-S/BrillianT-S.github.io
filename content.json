{"meta":{"title":"马小跳的秘密基地","subtitle":"能受天磨真好汉 不遭人嫉是庸才","description":"博客,移动开发,blog","author":"马小跳","url":"https://brillianttt.gitee.io","root":"/"},"pages":[{"title":"about","date":"2020-01-22T05:07:11.000Z","updated":"2020-01-22T05:08:27.240Z","comments":true,"path":"about/index.html","permalink":"https://brillianttt.gitee.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-04-04T02:42:50.000Z","updated":"2020-04-04T02:42:26.313Z","comments":true,"path":"categories/index.html","permalink":"https://brillianttt.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-01-22T05:10:19.000Z","updated":"2020-01-22T05:11:00.789Z","comments":true,"path":"contact/index.html","permalink":"https://brillianttt.gitee.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-20T06:06:52.000Z","updated":"2020-01-20T06:10:10.726Z","comments":true,"path":"tags/index.html","permalink":"https://brillianttt.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"QT下载与安装","slug":"QT下载与安装","date":"2020-12-15T13:51:26.000Z","updated":"2020-12-15T14:50:31.581Z","comments":true,"path":"2020/12/15/QT下载与安装/","link":"","permalink":"https://brillianttt.gitee.io/2020/12/15/QT%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85/","excerpt":"","text":"QT下载与安装除了官网可以下载，还可以在国内镜像源下载qt，比如清华大学镜像源也可以下载。 版本我选择的是5.12，在镜像源里选择qt/archive/qt/5.12/5.12.0/qt-opensource-windows-x86-5.12.0.exe,之后下载即可。 之后教程见这里。安装后试运行可能会出一个bug：无法打开 源 文件 “ui_QtGuiApplicationx.h”，这个错误的解决见这里。","categories":[],"tags":[{"name":"QT","slug":"QT","permalink":"https://brillianttt.gitee.io/tags/QT/"}]},{"title":"博客的音乐功能设置","slug":"博客的音乐功能设置","date":"2020-12-11T12:09:27.504Z","updated":"2020-12-11T12:11:10.647Z","comments":true,"path":"2020/12/11/博客的音乐功能设置/","link":"","permalink":"https://brillianttt.gitee.io/2020/12/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%9F%B3%E4%B9%90%E5%8A%9F%E8%83%BD%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"今天刚开始设置博客的音乐组件，留下一点小笔记备用😁首先，音乐的获取可以通过这两个方式：1、可以在网易云音乐上直接搜索喜欢的歌曲，找到外部链接2、自己创建网易云歌单，添加喜欢的歌曲，再找到自己歌单的外部链接之后再主题在文件夹下搜索music，找到music.ejs文件,在其中将”iframe”处替换成刚找到链接。最后将主题的yml文件中的#music部分做修改，更改http链接与音乐id就大功告成啦！(ps：在代码中修改各项参数可以更改音乐播放器的大小，将宽度和高度改为0或1可以隐藏音乐播放器，做到完完全全的“背景音乐”)","categories":[{"name":"博客开发","slug":"博客开发","permalink":"https://brillianttt.gitee.io/categories/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"敲代码时遇到的常见bug及解决方法","slug":"敲代码时遇到的常见bug及解决方法","date":"2020-11-22T09:21:19.000Z","updated":"2020-11-26T13:41:27.102Z","comments":true,"path":"2020/11/22/敲代码时遇到的常见bug及解决方法/","link":"","permalink":"https://brillianttt.gitee.io/2020/11/22/%E6%95%B2%E4%BB%A3%E7%A0%81%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%B8%B8%E8%A7%81bug%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"Android Studio类错误ndk配置清戳这里 配置NDK遇到的错误在下载ndk成功后如果没有配置环境，会报如下错误： 1Caused by: org.gradle.api.InvalidUserDataException: NDK not configured 这里是解决办法","categories":[],"tags":[{"name":"BUG解决","slug":"BUG解决","permalink":"https://brillianttt.gitee.io/tags/BUG%E8%A7%A3%E5%86%B3/"}]},{"title":"OpenCV学习中的参考博客","slug":"OpenCV学习中的参考博客","date":"2020-11-19T13:07:16.000Z","updated":"2020-11-26T13:41:27.673Z","comments":true,"path":"2020/11/19/OpenCV学习中的参考博客/","link":"","permalink":"https://brillianttt.gitee.io/2020/11/19/OpenCV%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"下面是一些个人认为讲的很好的一些博客，对自己在OpenCV学习上有很大的帮助 图片边缘填充","categories":[],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://brillianttt.gitee.io/tags/OpenCV/"}]},{"title":"图像处理作业","slug":"图像处理作业","date":"2020-11-06T15:00:43.000Z","updated":"2020-11-08T11:46:07.462Z","comments":true,"path":"2020/11/06/图像处理作业/","link":"","permalink":"https://brillianttt.gitee.io/2020/11/06/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"第一次作业内容如图：在刚留这个作业时学长给了一些解题的思路，快到作业截止提交的时间才做出来。。。 言归正传，这道题的思路比较简单，就是把图片先进行灰度化和二值化的处理，然后再将二值图中的黑色部分找到，将原图中的蓝色部分变为黑色，最后裁剪就可以了，但中间有一些小坑，在最开始做的时候出现并困扰了我挺长时间，之前得到的图片是这个样子的：这是因为在处理时没有将图片进行二值化处理，而图片本身像素不够高，很多地方的颜色都有细微的差别，因而在直接暴力将背景中的蓝色修改为黑色是不可行的，会出现“其岸势犬牙差互”的情况。 经过学长提醒，我后来的思路是这样子的： 1、对图片进行灰度化、二值化处理，并将处理后的图片保存到另一个变量part中。 2、对二值图part进行遍历，找到图片🐕的四个边缘值（最上、下、左、右）的坐标，然后用rect这个函数对二值图和原图进行裁剪。 3、对二值图再次进行遍历，在二值图的某像素点为黑色时，将原图上的对应像素点也变为黑色 经过这几个步骤，即可得到想要答案。 源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include&lt;iostream&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include \"opencv2/imgproc/imgproc.hpp\" #include &lt;opencv2/core/core.hpp&gt; using namespace std;using namespace cv; int main()&#123; Mat img,part1,part,src=imread(\"D:/code/dog.png\"); cvtColor(src,part1, COLOR_BGR2GRAY);//灰度化 threshold(part1, part, 175, 255, THRESH_BINARY);//二值化 imshow(\"二值图\",part); imwrite(\"D:/code/doggle.png\", part); part = imread(\"D:/code/doggle.png\"); int i, j, x1 = part.rows/2, x2 = part.rows / 2, y1 = part.cols / 2, y2=part.cols / 2;//给四个极值赋初值，其中.row和.cols分别返回图片的宽和长 int cPointB,cPointb;//currentPoint; //cout &lt;&lt; part.rows &lt;&lt; ' ' &lt;&lt; part.cols &lt;&lt; endl;调试用 for (i = 0; i &lt; part.rows; i++)//遍历图片找极值 for (j = 0; j &lt; part.cols; j++) &#123; cPointb = part.at&lt;Vec3b&gt;(i,j)[0]; if (0!=cPointb )//也可以把rgb三个颜色都判断下是否为零（全为0即为黑色），不过没有意义 &#123; if (i &lt; x1)x1 = i; else if (i &gt; x2)x2 = i; if (j &lt; y1)y1 = j; else if (j &gt; y2)y2 = j; &#125; &#125; cout &lt;&lt; x1 &lt;&lt; ' ' &lt;&lt; y1 &lt;&lt; ' ' &lt;&lt; x2 &lt;&lt; ' ' &lt;&lt; y2 &lt;&lt; endl; Rect m_select; m_select = Rect(y1, x1 ,y2 - y1,x2 - x1);//进行裁剪,注意此处x、y的坐标是相反的！ Mat roi = part(m_select); imshow(\"ans\", roi); imwrite(\"D:/code/dogcaijian.png\", roi); src=src(m_select);//对原图进行裁剪 cout &lt;&lt; src.rows &lt;&lt; ' ' &lt;&lt; src.cols &lt;&lt; endl; for(i=0;i&lt; src.rows;i++) for(j=0;j&lt; src.cols;j++) &#123; if(roi.at&lt;Vec3b&gt;(i,j)[0]==0) &#123; //cout &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt; ' ' &lt;&lt; \"j=\" &lt;&lt; j &lt;&lt; endl; src.at&lt;Vec3b&gt;(i,j)[0]=0;//&lt;Vec3b&gt;(i,j)[0]为蓝色值 src.at&lt;Vec3b&gt;(i,j)[1]=0;//&lt;Vec3b&gt;(i,j)[1]为绿色值 src.at&lt;Vec3b&gt;(i,j)[2]=0;//&lt;Vec3b&gt;(i,j)[2]为红色值 //对R、G、B三个值都赋值为0，得到黑色像素点 &#125; &#125; imshow(\"doggle\",src); waitKey(0); return 0;&#125; 最终结果： 附一个颜色表，在最后遍历的时候可以换成不同的颜色玩~ 第二次作业内容如图：分析：本题需要注意除了要把苹果部分抠出来，还需要将苹果缩小，放到背景图中的“上层”。 思路可以是这样的： 1、先对苹果的logo进行灰度化和二值化的处理。 2、然后将图二裁剪到和图一一样大，将图一再次缩小，放到背景图片中，将其余部分变黑。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include&lt;iostream&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include \"opencv2/imgproc/imgproc.hpp\" #include &lt;opencv2/core/core.hpp&gt; using namespace std;using namespace cv; //opencv 的命名空间int main()&#123; Mat pingguo, beijing,temp,pg; temp=imread(\"D:\\\\code\\\\opencv\\\\resources\\\\apple.jpg\"); beijing = imread(\"D:\\\\code\\\\opencv\\\\resources\\\\background.jpg\"); Rect r = Rect(0, 0, temp.rows, temp.cols); putText(temp, \"Apple\", Point(temp.rows/2-80, temp.cols-30),FONT_HERSHEY_SIMPLEX, 2, Scalar(0, 0, 0), 5, LINE_AA, false); cvtColor(temp,pg, COLOR_BGR2GRAY);//灰度化 //imshow(\"灰度图\", pg); threshold(pg,pg ,100, 255, THRESH_BINARY);//二值化 //imshow(\"二值图\", pg); vector&lt;int&gt; a; a.push_back(IMWRITE_JPEG_QUALITY); //选择jpeg a.push_back(255); //在这个填入你要的图片质量（255为无损保存，一定要进行255，否则图像失真） imwrite(\"D:\\\\code\\\\opencv\\\\resources\\\\x.jpg\", pg, a); //imwrite(\"D:\\\\code\\\\opencv\\\\resources\\\\x.jpg\", pg); pingguo = imread(\"D:\\\\code\\\\opencv\\\\resources\\\\x.jpg\");//,IMREAD_UNCHANGED); pingguo = imread(\"d:\\\\code\\\\opencv\\\\resources\\\\x.jpg\"); //imshow(\"apple\",pingguo); beijing = beijing(r); //imshow(\"background\", beijing); imwrite(\"d:\\\\code\\\\opencv\\\\resources\\\\caijian.jpg\", beijing); for(int i=0;i&lt;pingguo.rows ;i++) for(int j=0;j&lt; pingguo.cols;j++) &#123; if ((int)pingguo.at&lt;Vec3b&gt;(i, j)[0] &gt;= 240 &amp;&amp; (int)pingguo.at&lt;Vec3b&gt;(i, j)[0] &lt;= 255 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i, j)[1] &gt;= 240 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i, j)[1] &lt;= 255 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i, j)[2] &gt;= 240 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i, j)[2] &lt;= 255) &#123; //cout &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt; ' ' &lt;&lt; \"j=\" &lt;&lt; j &lt;&lt; endl; beijing.at&lt;Vec3b&gt;(i,j)[0]=0; beijing.at&lt;Vec3b&gt;(i,j)[1]=0; beijing.at&lt;Vec3b&gt;(i,j)[2]=0; &#125; &#125; imshow(\"beijing\", beijing); waitKey(0); return 0;&#125; 但是这种方法在实现的过程中出现了许多问题： 1、没有将苹果logo缩小。 2、苹果的处理不精细，在嵌套的for循环中本应该有判断语句中0（蓝色值）为255，而这个代码中判断如果大于240即可，这是因为在图片的二值化处理过程中，经过二值化处理的图片本应该是单通道输入和输出的，但是输入后再读取这个图片的时候是三通道读取，就会出现问题。在上面的给出的代码是经过了处理，保存的是单通道图片，但是我在遍历图片的rgb三个值时还能发现除了0和255外其他的值（如1、2、3、254、253）百度了下这是会经常出现的失真问题，我就将这部分代码由直接判断是否为255（白色）变为了判断一个范围值。 困难总比办法多，但是不慌，还有机会，现在有第二种思路： 1、还是先按照苹果logo图片的大小截取一部分背景，以此作为最终背景。 2、将“apple”插入苹果图，然后进行图片的灰度化和二值化，再利用resize()函数将图片缩小为原来的0.5倍并保存。 3、制作苹果图的掩膜。 4、与背景图进行与运算，得出最终图片。 先放一个铁憨憨的代码（还是没用上掩膜操作）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include&lt;iostream&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include \"opencv2/imgproc/imgproc.hpp\" #include &lt;opencv2/core/core.hpp&gt; using namespace std;using namespace cv;int main()&#123; Mat pingguo, beijing,temp,pg,mask,xpg; temp=imread(\"D:\\\\code\\\\opencv\\\\resources\\\\apple.jpg\"); beijing = imread(\"D:\\\\code\\\\opencv\\\\resources\\\\background.jpg\"); Rect r = Rect(200, 200, temp.rows, temp.cols); putText(temp, \"Apple\", Point(temp.rows/2-80, temp.cols-30),FONT_HERSHEY_SIMPLEX, 2, Scalar(0, 0, 0), 5, LINE_AA, false);//将字母插入，后续补充 cvtColor(temp,pg, COLOR_BGR2GRAY);//灰度化 //imshow(\"灰度图\", pg); threshold(pg,pg ,100, 255, THRESH_BINARY);//二值化 //imshow(\"二值图\", pg); vector&lt;int&gt; a;//开始无失真保存 a.push_back(IMWRITE_JPEG_QUALITY); //选择jpeg a.push_back(255); //在这个填入需要的图片质量（255为无损保存，一定要进行255，否则图像失真） resize(pg, pingguo, Size(), 0.5, 0.5);//缩放为原来的0.5倍，并存储在pingguo里 imwrite(\"D:\\\\code\\\\opencv\\\\resources\\\\x.jpg\", pingguo, a); //imwrite(\"D:\\\\code\\\\opencv\\\\resources\\\\x.jpg\", pg); imshow(\"temp\", pingguo); pingguo = imread(\"d:\\\\code\\\\opencv\\\\resources\\\\x.jpg\"); //imshow(\"apple\",pingguo); beijing = beijing(r); //imshow(\"background\", beijing); imwrite(\"d:\\\\code\\\\opencv\\\\resources\\\\caijian.jpg\", beijing); for(int i= 0;i&lt; beijing.rows ;i++) for(int j= 0;j&lt; beijing.cols;j++) &#123; if (!(i - pingguo.rows / 2 &gt;= 0 &amp;&amp; j - pingguo.cols / 2 &gt;= 0 &amp;&amp; i - pingguo.rows / 2 &lt; pingguo.rows &amp;&amp; j - pingguo.cols / 2 &lt; pingguo.cols &amp;&amp; (int)pingguo.at&lt;Vec3b&gt;(i - pingguo.rows / 2, j - pingguo.cols / 2)[0] &gt;= 0 &amp;&amp; (int)pingguo.at&lt;Vec3b&gt;(i - pingguo.rows / 2, j - pingguo.cols / 2)[0] &lt;= 5 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i - pingguo.rows / 2, j - pingguo.cols/2)[1] &gt;= 0 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i - pingguo.rows / 2, j - pingguo.cols/2)[1] &lt;= 10 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i - pingguo.rows / 2, j - pingguo.cols/2)[2] &gt;= 0 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i - pingguo.rows / 2, j - pingguo.cols/2)[2] &lt;= 10)) &#123;//这个判断条件是通过推导得出的，可能与题目需要的做题方法不同 beijing.at&lt;Vec3b&gt;(i,j)[0]=0; beijing.at&lt;Vec3b&gt;(i, j)[1]=0; beijing.at&lt;Vec3b&gt;(i, j)[2]=0; &#125; &#125; imwrite(\"D:\\\\code\\\\opencv\\\\resources\\\\ans2.jpg\",beijing); imshow(\"beijing\", beijing); waitKey(0); return 0;&#125; 中间用到的部分函数介绍： 12345678910111213resize(pg, pingguo, Size(), 0.5, 0.5);//五个参数分别为要做缩放的图片，缩放后的图片，size函数，长的缩放倍数，宽的缩放倍数putText(temp, \"Apple\", Point(temp.rows/2-80, temp.cols-30),FONT_HERSHEY_SIMPLEX, 2, Scalar(0, 0, 0), 5, LINE_AA, false);函数原型为： void putText( Mat&amp; img, const string&amp; text, Point org, int fontFace,double fontScale， Scalar color, int thickness=1, int lineType=8 );参数1：， Mat&amp; img，待写字的图片，我们写在img图上参数2：，const string&amp; text，待写入的字参数3：， Point org， 第一个字符左下角坐标参数4：，int fontFace，字体类型，FONT_HERSHEY_SIMPLEX ，FONT_HERSHEY_PLAIN ， FONT_HERSHEY_DUPLEX 等等等。参数5：，double fontScale，字体大小参数6：，Scalar color，字体颜色，颜色用Scalar（）表示参数7：， int thickness，字体粗细参数8：， int lineType，线型 CV_8UC1的介绍：见链接 最终效果：","categories":[],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://brillianttt.gitee.io/tags/OpenCV/"}]},{"title":"c语言基础之文件操作","slug":"c语言基础之文件操作","date":"2020-10-15T16:33:21.000Z","updated":"2020-10-15T16:36:52.151Z","comments":true,"path":"2020/10/16/c语言基础之文件操作/","link":"","permalink":"https://brillianttt.gitee.io/2020/10/16/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"","text":"关于文件处理，暂时先借鉴这位博主的博客。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://brillianttt.gitee.io/tags/C-C/"}]},{"title":"OpenCV学习","slug":"OpenCV的学习","date":"2020-10-13T13:15:49.000Z","updated":"2020-11-26T13:41:25.856Z","comments":true,"path":"2020/10/13/OpenCV的学习/","link":"","permalink":"https://brillianttt.gitee.io/2020/10/13/OpenCV%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"今天突然发奋学习之学习OpenCV 安装教程见这里或者这里,文章中没有提到，配置完环境变量以后还需要重启vs2019~ 图像读取与显示12345678910111213141516171819202122232425#include&lt;opencv2/opencv.hpp&gt;#include&lt;iostream&gt;using namespace cv;using namespace std;int main(int argc, char** argv)&#123; //Mat img = imread(\"D:/25.jpg\",0);//imrean()功能为载入一张图片；第二个参数为灰度，为0时为灰色,为1时为原图 Mat src = imread(\"D:/15.jpg\",IMREAD_GRAYSCALE);//注意这里的路径和直接ctrl+v过来的路径不同，是用“/”而不是“\\” 其次，IMREAD_GRAYSCALE是使图片变为灰色 //Mat src = imread(\"D:/25.jpg\"); if (src.empty()) &#123; printf(\"could not load image...\\n\"); return -1; //return 0：一般用在主函数结束时，按照程序开发的一般惯例，表示成功完成本函数。 //return -1：:表示返回一个代数值，一般用在子函数结尾。按照程序开发的一般惯例，表示该函数失败； &#125;//判断是否能找到图片，如果找不到则输出balabala namedWindow(\"输入窗口\",WINDOW_FREERATIO);//引号内内容为提取出的图片右上角的名称，如果没有添加该语句则名称默认为图片大小，WINDOW_FREERATIO函数可以使得图像自由变化大小 imshow(\"输入窗口\", src);//imshow()功能为把刚才的图片显示出来 imwrite(\"hhhh.jpg\", src);//输出一张图片到工程目录下，第一个参数为图片名称 waitKey(0);//等待按键时间:0ms，等待后退出 destroyAllWindows();//结束程序，并释放之前分配的与窗口有关的所有内存空间 return 0;&#125; 其中有 cv.IMREAD_COLOR： 加载彩色图像。任何图像的透明度都会被忽视。它是默认标志。 cv.IMREAD_GRAYSCALE：以灰度模式加载图像 cv.IMREAD_UNCHANGED：加载图像，包括alpha通道 使用MatplotlibMatplotlib是Python的绘图库，可为你提供多种绘图方法。你将在接下来的文章中看到它们。在这里，你将学习如何使用Matplotlib显示图像。你可以使用Matplotlib缩放图像，保存图像等。 1234567import numpy as npimport cv2 as cvfrom matplotlib import pyplot as pltimg = cv.imread('messi5.jpg',0)plt.imshow(img, cmap = 'gray', interpolation = 'bicubic')plt.xticks([]), plt.yticks([]) # 隐藏 x 轴和 y 轴上的刻度值plt.show() 读取和保存视频文件读取要捕获视频，你需要创建一个 VideoCapture 对象。它的参数可以是设备索引或视频文件的名称。设备索引就是指定哪个摄像头的数字。正常情况下，一个摄像头会被连接(就像我的情况一样)。所以我简单地传0(或-1)。你可以通过传递1来选择第二个相机，以此类推。在此之后，你可以逐帧捕获。但是在最后，不要忘记释放俘虏。 12345678910111213141516171819202122import numpy as npimport cv2 as cvcap = cv.VideoCapture(0)#如果要读取文件，只需将0变为文件的路径if not cap.isOpened(): print(\"Cannot open camera\") exit()while True: # 逐帧捕获 ret, frame = cap.read() # 如果正确读取帧，ret为True if not ret: print(\"Can't receive frame (stream end?). Exiting ...\") break # 我们在框架上的操作到这里 gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) # 显示结果帧e cv.imshow('frame', gray) if cv.waitKey(1) == ord('q'): break# 完成所有操作后，释放捕获器cap.release()cv.destroyAllWindows() 保存所以我们捕捉一个视频，一帧一帧地处理，我们想要保存这个视频。对于图像，它非常简单，只需使用 cv.imwrite()。这里还需要做一些工作。这次我们创建一个 VideoWriter 对象。我们应该指定输出文件名(例如: output.avi)。然后我们应该指定 FourCC 代码(详见下一段)。然后传递帧率的数量和帧大小。最后一个是颜色标志。如果为True ，编码器期望颜色帧，否则它与灰度帧一起工作。FourCC：http://en.wikipedia.org/wiki/FourCC 是用于指定视频编解码器的4字节代码。可用代码列表可在fourcc.org中:http://www.fourcc.org/codecs.php 找到。它取决于平台。遵循编解码器对我来说效果很好 123456789101112131415161718192021import numpy as npimport cv2 as cvcap = cv.VideoCapture(0)# 定义编解码器并创建VideoWriter对象fourcc = cv.VideoWriter_fourcc(*'XVID')out = cv.VideoWriter('output.avi', fourcc, 20.0, (640, 480))while cap.isOpened(): ret, frame = cap.read() if not ret: print(\"Can't receive frame (stream end?). Exiting ...\") break frame = cv.flip(frame, 0) # 写翻转的框架 out.write(frame) cv.imshow('frame', frame) if cv.waitKey(1) == ord('q'): break# 完成工作后释放所有内容cap.release()out.release()cv.destroyAllWindows() opencv的绘图功能在上述所有功能中，您将看到一些常见的参数，如下所示： img：您要绘制形状的图像 color：形状的颜色。对于BGR，将其作为元组传递，例如：(255,0,0)对于蓝色。对于灰度，只需传递标量值即可。厚度：线或圆等的粗细。如果对闭合图形（如圆）传递 -1 ，它将填充形状。默认厚度= 1 lineType：线的类型，是否为8连接线，抗锯齿线等。默认情况下，为8连接线。 cv.LINE_AA给出了抗锯齿的线条，看起来非常适合曲线。 1234567先创建黑色的图像：img &#x3D; np.zeros((512,512,3), np.uint8)绘制直线：cv.line(img,(0,0),(511,511),(255,0,0),5)绘制矩形：cv.rectangle(img,(384,0),(510,128),(0,255,0),3) 分别给出了矩形的左上角和右下角坐标画圆：cv.circle(img,(447,63), 63, (0,0,255), -1)，需要中心坐标和半径 ##向图片中添加文本：要将文本放入图像中，需要指定以下内容。 - 您要写入的文字数据 - 您要放置它的位置坐标（即数据开始的左下角）。 - 字体类型（检查cv.putText文档以获取受支持的字体） - 字体比例（指定字体大小） - 常规的内容，例如颜色，厚度，线条类型等。为了获得更好的外观，建议使用lineType = cv.LINE_AA。 12font = cv.FONT_HERSHEY_SIMPLEXcv.putText(img,'OpenCV',(10,500), font, 4,(255,255,255),2,cv.LINE_AA) 图像拼接123456789101112131415161718192021222324252627#include&lt;opencv2\\opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace cv;using namespace std;int main() &#123; Mat image = imread(\"D:/25.jpg\"); Mat logo = imread(\"D:/16.jpg\"); Mat imageROI = image(Rect(image.cols - logo.cols, image.rows - logo.rows, logo.cols, logo.rows)); //Mat imageROI = image(Range(350,350+logo.rows),Range(800,800+logo.rows)); //效果同上 //将logo加到原图上 addWeighted(imageROI, 1.0, logo, 1, 0., imageROI); //使用掩模,效果同上 /* Mat mask = imread(\"C:\\\\Users\\\\Nelsoner\\\\Desktop\\\\Camera Roll\\\\001.jpg\"); logo.copyTo(imageROI, mask);*/ namedWindow(\"hah\"); imshow(\"hah\", image); imwrite(\"hhh.jpg\", image); waitKey(0); destroyAllWindows; return 0;&#125; ROI关于ROI(region of interest——感兴趣区域)的定义，可以看这里 addWeighted第一个参数：InputArray src1，表示需要加权的第一个数组，常常填一个Mat 第二个参数：double alpha，表示第一个数组的权重 第三个参数：InputArray src2，表示第二个数组，需要和第一个数组拥有相同的尺寸和通道数 第四个参数：double beta，第二个数组的权重值，值为1-alpha 第五个参数：double gamma，一个加到权重总和上的标量值。 第六个参数：OutputArray dst，输出的数组，和输入的两个数组拥有相同的尺寸和通道数 dst = src1[I] * alpha + src2[I] * beta + gamma 第七个参数：int dtype，输出阵列的可选深度，有默认值-1。当两个输入数组具有相同深度时，这个参数设置为-1（默认值），即等同于src1.depth()。 下边是一个使用addWeighted()函数实现线性混合操作的例子： 123456789101112131415161718192021222324252627282930313233 #include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;iostream&gt; using namespace cv;using namespace std; void main()&#123; //【0】定义一些局部变量 double alphaValue = 0.5; double betaValue; Mat srcImage1, srcImage2, dstImage; // 【1】读取图像 ( 两幅图片需为同样的类型和尺寸 ) srcImage1 = imread(\"mogu.jpg\"); srcImage2 = imread(\"rain.jpg\"); if (!srcImage1.data) cout &lt;&lt; \"读取srcImage1错误！ \\n\" &lt;&lt; endl; imshow(\"1图原始图\", srcImage1); if (!srcImage2.data) cout &lt;&lt; \"读取srcImage2错误！ \\n\" &lt;&lt; endl; imshow(\"2图原始图\", srcImage2); // 【2】进行图像混合加权操作 betaValue = (1.0 - alphaValue); addWeighted(srcImage1, alphaValue, srcImage2, betaValue, 0.0, dstImage); // 【3】显示效果图 imshow(\"&lt;3&gt;线性混合示例窗口【效果图】\", dstImage); waitKey();&#125; Canny边缘识别函数123456789101112131415161718192021222324#include&lt;opencv2\\highgui\\highgui.hpp&gt;#include&lt;opencv2\\imgproc\\imgproc.hpp&gt;using namespace cv;using namespace std;int main() &#123; //载入原图 Mat srcImage = imread(\"D:/17.jpg\"); //显示原图 imshow(\"【原图】Canny边缘检测\", srcImage); Mat dstImage, edge, grayImage; //【1】创建于src同类型和大小的矩阵dst dstImage.create(srcImage.size(), srcImage.type()); //【2】将原图像转换成灰度图像 cvtColor(srcImage, grayImage, COLOR_BGR2GRAY); //【3】先使用3*3内核来降噪 blur(grayImage, edge, Size(3, 3)); //【4】运行Canny算子 Canny(edge, edge, 3, 9, 3); //显示效果图 imshow(\"【效果图】Canny边缘检测\", edge); waitKey(0); return 0;&#125; 图像的二值化见链接。 颜色反转、图片边缘扩展、这里","categories":[],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://brillianttt.gitee.io/tags/OpenCV/"}]},{"title":"c++常用函数","slug":"c++常用函数","date":"2020-09-03T08:34:55.000Z","updated":"2020-10-15T16:36:54.559Z","comments":true,"path":"2020/09/03/c++常用函数/","link":"","permalink":"https://brillianttt.gitee.io/2020/09/03/c++%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","excerpt":"","text":"C++: max_element函数和min_element函数1234567891011#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[]=&#123;4,2,3,8,5&#125;; int len=sizeof(a)/sizeof(int); cout&lt;&lt;*max_element(a,a+len)&lt;&lt;endl; //输出集合最大元素 cout&lt;&lt;*min_element(a,a+len)&lt;&lt;endl;//输出集合最小元素 return 0;&#125; 输出： 1282 min_element 返回最小的元素的位置中序列 [first, last)。同理 max_element。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://brillianttt.gitee.io/tags/C-C/"}]},{"title":"常见加密算法","slug":"RSA加密","date":"2020-09-01T00:40:54.000Z","updated":"2020-10-15T16:41:47.670Z","comments":true,"path":"2020/09/01/RSA加密/","link":"","permalink":"https://brillianttt.gitee.io/2020/09/01/RSA%E5%8A%A0%E5%AF%86/","excerpt":"","text":"RSA加密一个链接：RSA加密 仿射密码发一个菜鸡写的源代码，第一次自己写正经的二百行程序~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;cstring&gt;#define mt memsetusing namespace std;char message[50],ciphertext[50],jiemimiwen[50];int lenthofmessage,key,x,y,z;int inverseGCD(int a,int n)//扩展欧几里得定理求逆元&#123; int p=a,q=n; int x=0,y=1; int z=q/p; while(p!=1&amp;&amp;q!=1) &#123; int t=p; p=q%p; q=t; t=y; y=x-y*z; x=t; z=q/p; &#125; y%=n; if(y&lt;0)y+=n; return y;&#125;int gcd(int a, int b) &#123;//辗转相除法的递归实现 (b==0)?a:gcd(b,a%b);&#125;void encrypt(char message[])//加密算法&#123; int a=2,b;//a=2使下面判断gcd(a,26)顺利进行 if(y==0) &#123; cout&lt;&lt;\"请输入要加密的明文：\\n\"; getchar(); gets(message); &#125; lenthofmessage=strlen(message); if(y==1) &#123; cout&lt;&lt;\"明文为:\"&lt;&lt;message&lt;&lt;endl; &#125; cout&lt;&lt;\"请选择是否使用随机密钥（输入1为是，0为否）：\"&lt;&lt;endl; cin&gt;&gt;z; if(z==1) &#123; srand((unsigned)time(NULL)); while(gcd(a,26)!=1) a = rand()%26+1;//用库函数生成1~26的随机数，a、b为密钥 b =rand()%26+1; &#125; else &#123; cout&lt;&lt;\"请输入两个加密密钥a、b（中间有一个空格）:\"&lt;&lt;endl; cin&gt;&gt;a&gt;&gt;b; while(gcd(a,26)!=1) &#123; cout&lt;&lt;\"输入的第一个参数无法求出解密密钥，请重新输入！\\n\"; cin&gt;&gt;a&gt;&gt;b; &#125; &#125; cout&lt;&lt;\"仿射密码的两个参数分别为：\"&lt;&lt;\"a=\"&lt;&lt;a&lt;&lt;' '&lt;&lt;\"b=\"&lt;&lt;b&lt;&lt;endl; int i=0; while (i&lt;lenthofmessage) &#123; if (message[i]&gt;='A'&amp;&amp;message[i]&lt;='Z') ciphertext[i]='A'+(a*(message[i]-'A')+b+26*a)%26; else if (message[i]&gt;='a'&amp;&amp;message[i]&lt;='z') ciphertext[i]='a'+(a*(message[i]-'a')+b+26*a)%26; else if (message[i]==' ') ciphertext[i]=' '; else ciphertext[i]=message[i]; i++; &#125; cout&lt;&lt;\"加密得到的密文为：\"; puts(ciphertext); cout&lt;&lt;endl&lt;&lt;endl; FILE *fpWrite=fopen(\"ciphertext.txt\",\"w\");//文件处理三连，w为从文件头开始写文件，不存在文件则创建一个新文件 fprintf(fpWrite,\"%s\",ciphertext); fclose(fpWrite);&#125;void decrypt(char message[])&#123; cout&lt;&lt;\"y=\"&lt;&lt;y&lt;&lt;endl; int a,b,i; if(y==0) &#123; cout&lt;&lt;\"请输入要解密的文本:\\n\"; getchar(); gets(message); &#125; lenthofmessage=strlen(message); cout&lt;&lt;\"请输入两个解密密钥a、b（中间有一个空格）:\"&lt;&lt;endl; cin&gt;&gt;a&gt;&gt;b; while(gcd(a,26)!=1) &#123; cout&lt;&lt;\"输入的第一个参数无法求出解密密钥，请重新输入！\\n\"; cin&gt;&gt;a&gt;&gt;b; &#125; int ani=inverseGCD(a,26);//求逆元 cout&lt;&lt;\"逆元为：\"&lt;&lt;ani&lt;&lt;endl; i=0; while (i&lt;lenthofmessage) &#123; if (message[i]&gt;='A'&amp;&amp;message[i]&lt;='Z') jiemimiwen[i]='A'+ani*(message[i]-'A'-b+26)%26; else if (message[i]&gt;='a'&amp;&amp;message[i]&lt;='z') jiemimiwen[i]='a'+ani*(message[i]-'a'-b+26)%26; else if (message[i]==' ') jiemimiwen[i]=' '; else jiemimiwen[i]=message[i]; i++; &#125; jiemimiwen[i]='\\0'; cout&lt;&lt;\"解密得到的明文为：\"; cout&lt;&lt;jiemimiwen&lt;&lt;endl&lt;&lt;endl; &#125;int main() &#123; cout&lt;&lt;\"=========== Hill 密码 ===========\\n\"; cout&lt;&lt;\"= =\\n\"; cout&lt;&lt;\"= =\\n\"; cout&lt;&lt;\"= =\\n\"; cout&lt;&lt;\"= =\\n\"; cout&lt;&lt;\"= =\\n\"; cout&lt;&lt;\"= 信安1904 马博宇 =\\n\"; cout&lt;&lt;\"=================================\\n\"; while(1) &#123; mt(message,0,sizeof(message)); mt(ciphertext,0,sizeof(ciphertext)); mt(jiemimiwen,0,sizeof(jiemimiwen)); cout&lt;&lt;\"请选择需要：1、加密 2、解密（输入1为加密，2为解密,-1为退出程序）：\"&lt;&lt;endl; cin&gt;&gt;x; if(x==1) &#123; cout&lt;&lt;\"请选择是否从文件输入（输入1为是，0为否,-1为退出程序）：\"&lt;&lt;endl; cin&gt;&gt;y; if(y==1) &#123; FILE *file1; file1=fopen(\"plaintext.txt\",\"r\"); fgets(message,50,file1); &#125; else if(y==-1) return 0; encrypt(message); &#125; else if(x==2) &#123; cout&lt;&lt;\"请选择是否从文件输入（输入1为是，0为否,-1为退出程序）：\"&lt;&lt;endl; cin&gt;&gt;y; if(y==1) &#123; FILE *file1; file1=fopen(\"ciphertext.txt\",\"r\"); fgets(message,50,file1); &#125; else if(y==-1) return 0; else decrypt(message); &#125; else if(x==-1) return 0; &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://brillianttt.gitee.io/tags/RSA/"},{"name":"仿射密码","slug":"仿射密码","permalink":"https://brillianttt.gitee.io/tags/%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81/"},{"name":"密码学","slug":"密码学","permalink":"https://brillianttt.gitee.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"出去玩拍的一些皂片","slug":"出去玩拍的一些皂片","date":"2020-08-24T10:47:15.000Z","updated":"2020-08-24T10:47:18.090Z","comments":true,"path":"2020/08/24/出去玩拍的一些皂片/","link":"","permalink":"https://brillianttt.gitee.io/2020/08/24/%E5%87%BA%E5%8E%BB%E7%8E%A9%E6%8B%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9A%82%E7%89%87/","excerpt":"","text":"唱K 打球 逛动物园 学习驾驶技能 烧烤！猜猜这个是啥哈哈哈哈哈哈看我找到了什么哈哈哈 打工当然还是要打工的 以及穿这个真的是像六十岁的老大爷风格吗哈哈哈😂","categories":[],"tags":[{"name":"照片","slug":"照片","permalink":"https://brillianttt.gitee.io/tags/%E7%85%A7%E7%89%87/"}]},{"title":"云吸猫系列","slug":"云吸猫系列","date":"2020-08-23T12:10:28.000Z","updated":"2020-08-23T15:48:45.391Z","comments":true,"path":"2020/08/23/云吸猫系列/","link":"","permalink":"https://brillianttt.gitee.io/2020/08/23/%E4%BA%91%E5%90%B8%E7%8C%AB%E7%B3%BB%E5%88%97/","excerpt":"","text":"这个假期都没怎么发辛巴的照片，这里一次发个够好了😎（因为懒得用p图软件把图都拼到一起了所以就一并发了哈哈哈哈哈哈哈） 日常占我的床：最近抓拍的 注意右侧脸颊哈哈哈他太胖了他的眼屎我真的一拍完就给他处理了！是谁的猪猪男孩呀~迄今为止自认为最有气质的几张没想到吧哈哈哈哈哈哈哈哈哈哈哈哈接下来是嫌弃三连哈哈哈哈哈哈哈哈哈再然后是一些很妖娆的姿势👀再来些可可爱爱的😄最后再来一些随拍hiahiahia这个其实是在打呵欠哈哈哈哈，正好被我抓拍到了这仨是视频中截的图，有没有点像哥斯拉哈哈哈 写在最后： 辛巴其实是我养的第三只猫，之前领养的两只猫猫因为特殊原因实在养不了了，最后托付给了能善待他们的新主人。真心对这两只可爱猫猫的主人说一声对不起，我没有将他们一直养下去，他们都是非常非常非常可爱的猫，身体健康，也十分活泼，希望他们能一直快乐的生活。 最后的最后！说了一个假期要来偷猫的人！一个来偷的都没有哼！我都准备好和你们斗智斗勇了哈哈哈","categories":[],"tags":[{"name":"猫","slug":"猫","permalink":"https://brillianttt.gitee.io/tags/%E7%8C%AB/"},{"name":"照片","slug":"照片","permalink":"https://brillianttt.gitee.io/tags/%E7%85%A7%E7%89%87/"}]},{"title":"一份小总结","slug":"一份小总结","date":"2020-08-23T11:44:12.000Z","updated":"2020-08-23T16:08:03.448Z","comments":true,"path":"2020/08/23/一份小总结/","link":"","permalink":"https://brillianttt.gitee.io/2020/08/23/%E4%B8%80%E4%BB%BD%E5%B0%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"这些照片因为我非常特别very poor的技术。。。很多图片内存比较大发上来手机显示不了或者显示速度过慢，要是方便的话可以拿电脑访问，电脑能看所有图片！ 云吸猫系列传送门一号 出去玩拍的一些皂片传送门二号","categories":[],"tags":[{"name":"Summer summary","slug":"Summer-summary","permalink":"https://brillianttt.gitee.io/tags/Summer-summary/"}]},{"title":"简单数学知识","slug":"简单数学知识","date":"2020-07-15T11:30:22.000Z","updated":"2020-10-12T12:50:36.749Z","comments":true,"path":"2020/07/15/简单数学知识/","link":"","permalink":"https://brillianttt.gitee.io/2020/07/15/%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/","excerpt":"","text":"模运算取模运算的三个公式： (a+b)%m=((a%m) + (b%m))%m (a+b)%m=((a%m) + (b%m))%m (a*b)%m=((a%m) * (b%m))%m 快速幂如2^11可以转换为2^1 * 2^2 * 2^8 而指数11转换为二进制为1011，11可表示为2^0+2^1+2^3 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll fast_pow(ll a,ll n)&#123; ll base=a;//是个变量 ll res=1;//答案 while(n&gt;0) &#123; if(n&amp;1) res*=base; base=base*base; n&gt;&gt;=1;//向右移动一位 &#125; return res;&#125;int main()&#123; cout&lt;&lt;fast_pow(2,11)&lt;&lt;endl; &#125; 如果计算大数的幂次的话，可以求它的余数 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;typedef long long ll;ll fast_pow(ll a,ll n,ll M)&#123; ll base=a;//是个变量 ll res=1;//答案 while(n&gt;0) &#123; if(n&amp;1) res=res*base%M; base=base*base%M; n&gt;&gt;=1;//向右移动一位 &#125; return res;&#125;int main()&#123; int M=10; cout&lt;&lt;fast_pow(2,11,M)&lt;&lt;endl; &#125; 埃筛，线性筛(欧拉筛)首先是埃拉托斯特尼筛法： 这是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint prime[20000];int len;int main() &#123; int n; cin&gt;&gt;n; int book[20000]; memset(book,0,sizeof(book)); for(int i=2;i&lt;=n;i++) &#123; if(!book[i]) &#123; prime[len++] = i; for(int j=2*i;j&lt;=n;j+=i) &#123;//每次把这个数的倍数标记 book[j] = 1; &#125; &#125; &#125; /*for(int i=0;i&lt;len;i++) &#123; cout&lt;&lt;prime[i]&lt;&lt;endl; &#125;*/&#125; 埃筛其实还是有一些重复：许多数被重复标记，比如：10既被2标记过，又被5标记过。 接下来是线性筛：线性筛的优化主要在于每个数只被筛过一次 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint prime[20000];int len;int main() &#123; int n; cin&gt;&gt;n; int book[20000]; memset(book,0,sizeof(book)); for(int i=2;i&lt;=n;i++) &#123; if(!book[i]) &#123; prime[len++] = i; &#125; for(int j=0;j&lt;len;j++) &#123; if(i*prime[j]&gt;n) break; book[i*prime[j]] = 1; if(i%prime[j]==0)//使每个合数只被它的最小质因数标记 break; &#125; &#125; /*for(int i=0;i&lt;len;i++) &#123; cout&lt;&lt;prime[i]&lt;&lt;endl; &#125;*/&#125; 附上一个链接,这位大大写的很详细。 唯一分解定理每个大于1的自然数均可写为质数的积，而且这些素因子按大小排列之后，写法仅有一种方式。 当题目有大数相除，求余数且精度要求高时，就要运用唯一分解定律 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;const int maxn=10000+5;int e[maxn]; //用e[]保存每一位素数的系数vector&lt;int&gt; primes;void GetPrime()&#123; int n[10000]=&#123;0&#125;; for(int i=2;i&lt;=sqrt(10000+0.5);i++) if(!n[i]) for(int j=i*i;j&lt;=10000;j+=i) n[j]=1; for(int i=2;i&lt;=10000;i++) if(!n[i]) primes.push_back(i);&#125;void add_int(int n,int d)&#123; for(int i=0;i&lt;primes.size()&amp;&amp;n!=1;i++) while(n%primes[i]==0) &#123; n/=primes[i]; e[i]+=d; &#125;&#125;int main() &#123; GetPrime(); //求出素数 int n, p; cin &gt;&gt; n; add_int(n, 1); //乘以n; p = 0; for (int i = 0; i &lt; primes.size(); i++) if (e[i]) &#123; if (p) cout &lt;&lt; '*'; cout &lt;&lt; primes[i] &lt;&lt; '^' &lt;&lt; e[i]; if (!p) p = 1; &#125; cout &lt;&lt; endl; cin &gt;&gt; n; add_int(n, -1); //除以n; p = 0; for (int i = 0; i &lt; primes.size(); i++) if (e[i]) &#123; if (p) cout &lt;&lt; '+'; cout &lt;&lt; primes[i] &lt;&lt; '^' &lt;&lt; e[i]; if (!p) p = 1; &#125; return 0;&#125;/*运行效果：10002^3*5^352^3+5^2*/ 扩展欧几里得算法扩展欧几里得算法用于求取二元一次方程的整数解。（如：ax+by=cax+by=c，x,yx,y为未知数） 在学习扩展欧几里得算法前要先知道欧几里得算法，也就是辗转相除法 辗转相除法：定义：两个数a,ba,b的最大公因数gcd(a,b) = gcd(b,a \\bmod b)，a &gt; bgcd(a,b)=gcd(b,amodb)，a&gt;b例如：99和1212的最大公因数为33，gcd(12,9)=gcd(9,3)=gcd(3,0)=3gcd(12,9)=gcd(9,3)=gcd(3,0)=3。 1234567int gcd(int a, int b) &#123; //return (b == 0)? a : gcd(b, a % b); if (b == 0) return a; else return gcd(b, a % b);&#125; 扩展欧几里得定理:附上关键代码： 123456789101112int Exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; int d = Exgcd(b, a % b, x, y); int t = x;//以下三行是经过数学推导出的结果 x = y; y = t - (a / b) * y; return d;&#125; 再附上一个例题和讲解的链接。 素数定理素数定理（prime number theorem）是素数分布理论的中心定理，是关于素数个数问题的一个命题： 设x≥1，以π(x)表示不超过x的素数的个数，当x→∞时，π(x)Li(x)或π(x)x/ln(x)。（Li(x)为对数积分） 根据推导即有π(x)~x/ln(x)，利用素数定理，可以解决一些看起来很难的c语言题目，比如说这个。先补充一下c语言对数函数的使用： 123456789#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; printf(\"%f\\n\",log(10)); //以e为底的对数函数 printf(\"%f\\n\",log10(100)); //以10为底的对数函数 printf(\"%f\\n\",log(8)/log(2)); //计算log2^8,运用换底公式 printf(\"%f\\n\",exp(1)); //计算自然常数e return 0;&#125; 要计算素数个数的位数，我们还需要一个计算数字位数的公式：n=lg(x)+1，结合素数定理的结论和位数公式就可推导得出答案。 然后附上题解： 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main() &#123; int n; while(cin&gt;&gt;n) &#123; if(n==1||n==2) &#123; cout&lt;&lt;n&lt;&lt;endl; &#125; else &#123; int m=double(n-log10(n)-log10(log(10)));//经过数学推导得出 cout&lt;&lt;m+1&lt;&lt;endl; &#125; &#125; return 0;&#125; 再举一个栗子有了上一题的思路，这一题可以很快想到利用lg(x)+1的方法去计算，而n!=123···n，带回到lg(x)+1中也可以求解。 但是吧。。。凡是都有例外，这个题就不行，因为用对数函数去求还不是最快的方法，还可以运用斯特林公式求解，具体如下： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define e 2.718281828459045#define pi 3.141592653589793239using namespace std;int main ()&#123; int n; while ( cin&gt;&gt;n;) &#123; ciun&gt;&gt;n; double t = log10(sqrt(2*pi*n)) + n * log10(n/e); printf (\"%d\\n\",(int)t + 1); &#125;return 0;&#125; 斯特林公式：log(n!) = log10(sqrt(2pin)) + n*log10(n/e)","categories":[{"name":"数学","slug":"数学","permalink":"https://brillianttt.gitee.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://brillianttt.gitee.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"0-1背包问题","slug":"0-1背包问题","date":"2020-07-09T14:30:33.000Z","updated":"2020-07-13T01:16:35.842Z","comments":true,"path":"2020/07/09/0-1背包问题/","link":"","permalink":"https://brillianttt.gitee.io/2020/07/09/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"首先两个概念： 背包问题：有某些物品，每个物品有一个重量w[i],价值v[i]，现在有一个容量为t的背包，问这个背包能存放的物品的价值和最大时多少？ 01背包问题：有n个物品，每一个物品有一个重量w[i]，价值v[i],现在有一个容量为t的背包，问这个背包的能存放的物品的价值和最大是多少？ dp实现dp[i][j],前i个物品，容量为j的背包，所能存放的物品的最大价值是多少。 举个栗子： i 1 2 3 4 5 w 2 3 2 4 1 v 3 2 4 6 3 栗子的解释👇 其中i表示物品，j表示背包容量 dp[0][j]=0，因为当没有物品时，无论有多的容量，也没有价值 j&gt;=w[i]: dp[i][j]=max(dp[i][j],dp[i-1][j-w[i]]+v[i]) 背包容量：j-w[i]-&gt;j-w[i]+w[i]-&gt;j 背包价值：dp[i-1][j-w[i]]+v[i] dp[i][j] 0 1 2 3 4 5 6 7 8 i=0 0 0 0 0 0 0 0 0 0 i=1,w=2,v=3 0 0 3 3 3 3 3 3 3 i=2,w=3,v=2 0 0 3 3 3 3+2=5 3 3 3 i=3,w=2,v=4 0 0 4 4 3+4=7 7 7 9 9 i=4,w=4,v=6 0 0 4 4 7 7 4+6=10 10 7+6=13 i=5,w=1,v=3 0 3 3 7 7 7+3=10 10 13 13 例1：采药问题这是题目链接 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e3+5;int main()&#123; int t,m; cin&gt;&gt;t&gt;&gt;m; int w[maxn],v[maxn]; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; int dp[105][1005]=&#123;0&#125;; for(int i=1;i&lt;=m;i++) for(int j=0;j&lt;=t;j++) &#123; dp[i][j]=dp[i-1][j]; if(j&gt;=w[i]) &#123; dp[i][j]=max(dp[i][j],dp[i-1][j-w[i]]+v[i]);//状态转移方程 &#125; &#125; cout&lt;&lt;dp[m][t]; return 0;&#125; 将上面的代码做一个滚动优化： 根据状态转移方程，当前状态只和其前一个状态有关，所以只需使用dp[2][x]。 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e3+5;int main()&#123; int t,m; cin&gt;&gt;t&gt;&gt;m; int w[maxn],v[maxn]; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; int dp[2][1005]=&#123;0&#125;;//占用空间减小了 for(int i=1;i&lt;=m;i++) &#123; int p=i&amp;1;//如果i是奇数p=1，否则p=0 for(int j=0;j&lt;=t;j++) &#123; dp[p][j]=dp[!p][j]; if(j&gt;=w[i]) &#123; dp[p][j]=max(dp[p][j],dp[!p][j-w[i]]+v[i]);//状态转移方程 &#125; &#125; &#125; cout&lt;&lt;dp[m&amp;1][t]; return 0;&#125; 用一维dp再优化下： 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e3+5;int main()&#123; int t,m; cin&gt;&gt;t&gt;&gt;m; int w[maxn],v[maxn]; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; int dp[1005]=&#123;0&#125;;//换成了一维数组 for(int i=1;i&lt;=m;i++) &#123; for(int j=t;j&gt;=0;j+--)//这里的j&gt;=0可以换成j&gt;=w[i],下面的if语句就也可以去掉了 &#123; dp[j]=dp[j]//这句其实没用，就是对照下二维dp的dp[i][j]=dp[i-1][j] if(j&gt;=w[i]) &#123; dp[j]=max(dp[j],dp[j-w[i]]+v[i]); &#125; &#125; &#125; cout&lt;&lt;dp[t]; return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"暑假学习","slug":"暑假学习","permalink":"https://brillianttt.gitee.io/tags/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0/"},{"name":"0-1背包问题","slug":"0-1背包问题","permalink":"https://brillianttt.gitee.io/tags/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"}]},{"title":"阶段小结","slug":"阶段小结","date":"2020-07-07T13:26:27.000Z","updated":"2020-07-07T14:01:56.729Z","comments":true,"path":"2020/07/07/阶段小结/","link":"","permalink":"https://brillianttt.gitee.io/2020/07/07/%E9%98%B6%E6%AE%B5%E5%B0%8F%E7%BB%93/","excerpt":"","text":"明天是高考第二天，也是我加入的acm实验室的第一天暑期集训，想在今天做一个最近的小总结，也希望不留下遗憾，过好这个暑假。这个博客是在今年寒假开始的时候好朋友帮助我搭建的，现在只能在界面以及主题方面做一些细微的修改，主要用来记录学习笔 记，偶尔也分享一些生活小事，就当这里是我的“秘密基地”吧！ 今天实验室的老师在开会时也对我们学习方面的事情做了一些较严厉的批评，也是给我们这群刚考完试的准大二学生敲响了警钟，留给自己努力的时间不多了，马上要来到的暑假培训、补大一没有学的课程、准备12月的六级考试、学习html、考驾照、减掉这个学期和寒假多出来的20斤五花肉、重新巩固（or预习）高数的知识balabala，这些任务很重要，并且都是必须要做的事情，将这些事情都展开了说是希望自己能好好努力，不再浪费这段时间，能踏踏实实的过完这个暑假，在今年九月开学的时候，做个像样的大学生。 最近这段时间收获还是不小的，上一周安排的很紧凑：每天上午学车，下午模拟或者考试，晚上继续复习或者写代码，再加上每天来回30km的遥远路途，也算是被小小的摧残了下~ 结果还是比较不错的，数学、物理、线代的成绩也还算ok，科二补考也过了（虽然第一把没系安全带直接挂了，but问题不大）。 写到这里好像也没有什么其他想说的了，简单感慨下继续努力叭，希望自己能不浪费这个暑假，好好去努力！！ 哦对了！！如果有明天还高考的小伙伴恰好今晚也看到了这个blog，想对你们再说一句加油！理综选择可得认真嗷，六分一个，不能随随便便就扔了嗷。加油加油，晚安早睡😴","categories":[],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"bfs例题","slug":"bfs例题","date":"2020-06-07T03:45:50.462Z","updated":"2020-06-09T15:51:20.561Z","comments":true,"path":"2020/06/07/bfs例题/","link":"","permalink":"https://brillianttt.gitee.io/2020/06/07/bfs%E4%BE%8B%E9%A2%98/","excerpt":"","text":"走迷宫题意：从入口走到出口输入：地图、起始位置、出口位置输出：最少走几步代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;using namespace std;struct note&#123; int x,y;//横、纵坐标 //int f;//父亲在队列中的编号，本题不需要 int s;//步数&#125;;int a[51][51],book[51][51];//用来记录地图和标记地图上的点是否走过int main()&#123; note que[2501];//地图大小不超过50*50，所以扩展大小不超过2500 int next[4][2]=&#123;&#123;0,1&#125;, &#123;1,0&#125;, &#123;0,-1&#125;, &#123;-1,0&#125; &#125;;//方位 int head,tail;队列的头部和尾部 int i,j,k,n,m,startx,starty,p,q,tx,ty,flag; cin&gt;&gt;n&gt;&gt;m;//输入地图大小 for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) cin&gt;&gt;a[i][j];//输入地图 cin&gt;&gt;startx&gt;&gt;starty&gt;&gt;p&gt;&gt;q;//输入起始坐标和终点坐标 //队列初始化 head=1; tail=1; //向队列插入迷宫入口坐标 que[tail].x=startx; que[tail].y=starty; //que[tail].f=0; que[tail].s=0;//在起点时步数为零 tail++;//尾部增加一个扩展 book[startx][starty]=1;//标记现在所处位置已经走过 flag=0;//用来标记是否到达目标点，0表示暂时还没到，1表示已经到达 //当队列不为空的时候循环 while(head&lt;tail) &#123; //枚举四个方向 for(k=0;k&lt;4;k++) &#123; tx=que[head].x+next[k][0]; ty=que[head].y+next[k][1]; if(tx&lt;1||tx&gt;n||ty&lt;1||ty&gt;m)//判断是否越界 &#123; continue; &#125; if(a[tx][ty]==0&amp;&amp;book[tx][ty]==0) &#123; book[tx][ty]=1;//标记已经走过 que[tail].x=tx;//更新现在所处位置 que[tail].y=ty; //que[tail].f=head; que[tail].s=que[head].s+1;//步数加一 tail++; &#125; //如果到了目标点，停止扩展，任务结束，退出循环 if(tx==p&amp;&amp;ty==q) &#123; flag=1; break; &#125; &#125; if(flag==1) break; head++;//不能去掉，当一个点扩展结束后，head++才能对后面的点再扩展 &#125; cout&lt;&lt;que[tail-1].s; return 0;&#125; 又一个走迷宫这里是题目链接。直接上代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;using namespace std;struct note//模拟队列&#123; int x,y; int step=0;//步数&#125;que[10005];char maze[101][101];//迷宫bool vis[101][101];//判断是否走过int main()&#123; int next[4][2]=&#123;0,1,1,0,0,-1,-1,0&#125;;//模拟往四个方向走 int head=1,tail=1,tx,ty,n,m,flag=0; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) &#123; cin&gt;&gt;maze[i][j];//输入地图 if(maze[i][j]=='B')//记录下起点坐标 &#123; que[head].x=i; que[head].y=j; tail++; vis[i][j]=1; &#125; &#125; while(head&lt;tail)//遍历地图 &#123; for(int k=0;k&lt;4;k++) &#123; tx=que[head].x+next[k][0]; ty=que[head].y+next[k][1]; if(tx&gt;=0&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;m&amp;&amp;vis[tx][ty]==0&amp;&amp;maze[tx][ty]=='.')//如果不越界且可以走 &#123; que[tail].x=tx;//将此时的坐标加入队列 que[tail].y=ty; que[tail].step=que[head].step+1;//在当前根节点的步数基础上多走一步 tail++; vis[tx][ty]=1;//标记已经走过 &#125; if(maze[tx][ty]=='C')//如果找到终点 &#123; que[tail].step=que[head].step+1;//步数一 flag=1;//标记找到终点 break;//溜了 &#125; &#125; if(flag==1) break;//继续溜 head++; &#125; cout&lt;&lt;que[tail].step;//输出当前步数 return 0;//溜走了 //注意在没到终点时每一次tail都要加一，找到了就不用加了，只在当前tail下step++即可，最后输出。&#125; 用队列写走迷宫这是一个例题. ac代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;char maze[105][105];int vis[105][105];typedef struct point//用结构体记录当前的点以及移动的步数&#123; int x; int y; int dis=0;&#125;p;queue&lt;point&gt;Q;p start,End,temp,tmp;int main()&#123; int n,m,i,j,ans=0,tx,ty,flag=0; int next[4][2]=&#123;&#123;0,1&#125;, &#123;1,0&#125;, &#123;0,-1&#125;, &#123;-1,0&#125; &#125;; scanf(\"%d %d\",&amp;n,&amp;m); for(i=0;i&lt;n;i++) &#123; scanf(\"%s\",maze[i]); &#125; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; if(maze[i][j]=='B') &#123; start.x=i; start.y=j; start.dis=0;//初始点步数为0 &#125; else if(maze[i][j]=='C') &#123; End.x=i; End.y=j; &#125; &#125; &#125; Q.push(start);//将起点压入队列 vis[start.x][start.y]=1;//标记已经走过 while(!Q.empty()) &#123; temp=Q.front();//获得队首元素 Q.pop();//将队首出队 for(int k=0;k&lt;4;k++) &#123; tx=temp.x+next[k][0]; ty=temp.y+next[k][1]; if(tx&gt;=0&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;m&amp;&amp;maze[tx][ty]=='.'&amp;&amp;!vis[tx][ty]) &#123; tmp.x=tx;tmp.y=ty;tmp.dis=temp.dis+1; Q.push(tmp);//将满足条件的点压入队列 vis[tx][ty]=1;//标记已经走过 &#125; if(tx==End.x&amp;&amp;ty==End.y) &#123; //因为在上一个if语句里没有判断是否走到终点的情况，所以此处若走到了终点， //则步数应该为上一个temp节点（也就是本轮while循环的head节点）的步数加一。 ans=temp.dis+1; flag=1; break; &#125; &#125; if(flag==1) break; &#125; printf(\"%d\",ans); return 0;&#125; 宝岛探险题意：给出一个n*m大小的地图，0表示海，1~9表示小岛，数字越大岛越重要，现在给出起点坐标，问所在岛屿有多大。(视起始坐标上下左右相邻的区域为同一个岛屿)输入：地图大小，起始坐标输出：岛屿大小代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;struct node&#123; int x,y;&#125;que[2501];bool book[51][51]=&#123;0&#125;;int maze[51][51];int main()&#123; int head,tail; int sum=0,n,m,startx,starty,tx,ty; int next[4][2]=&#123;0,1,1,0,0,-1,-1,0&#125;; cin&gt;&gt;n&gt;&gt;m&gt;&gt;startx&gt;&gt;starty; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;maze[i][j]; head=1; tail=1; que[tail].x=startx; que[tail].y=starty; tail++; book[startx][starty]=1; sum=1; while(head&lt;tail) &#123; for(int k=0;k&lt;4;k++) &#123; tx=que[head].x+next[k][0]; ty=que[head].y+next[k][1]; if(tx&lt;1||tx&gt;n||ty&lt;1||ty&gt;n) continue; if(maze[tx][ty]&gt;0&amp;&amp;book[tx][ty]==0) &#123; sum++; book[tx][ty]=1; que[tail].x=tx; que[tail].y=ty; tail++; &#125; &#125; head++; &#125; cout&lt;&lt;sum; return 0;&#125; 宝岛探险也可以用dfs做，理解起来也比较简单，具体实例在“dfs例题”中。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"https://brillianttt.gitee.io/tags/bfs/"}]},{"title":"dfs例题","slug":"dfs例题","date":"2020-06-05T03:34:51.000Z","updated":"2020-09-03T12:04:13.905Z","comments":true,"path":"2020/06/05/dfs例题/","link":"","permalink":"https://brillianttt.gitee.io/2020/06/05/dfs%E4%BE%8B%E9%A2%98/","excerpt":"","text":"输出全排列如何输出全排列呢，可以使用algirithm头文件下的next_permutation()函数偷懒，也可以使用今天我学的dfs实现，据说这种题型是dfs里最简单的一类，不禁让我怀疑自己的脑袋是不是一半水一半面哈哈哈。话不多说，看题！题意：给出一个数n，输出1~n的全排列（1&lt;=n&lt;=9).分析：不咋会分析，兄得们将就看，等我学会了再来补充。代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;int a[10],book[10],n;//因为c语言的全局变量在没有赋值以前默认为0，所以无需再赋初值void dfs(int step)//step表示现在站在第几个盒子里&#123; int i; if(step==n+1) &#123; //输出一种排列（1~n号盒子中的扑克牌编号） for(i=1;i&lt;=n;i++) cout&lt;&lt;a[i]; cout&lt;&lt;endl; return;//返回之前一步，即最近一次调用dfs函数的位置 &#125; //此时在第step个盒子前，按照1、2、3...n的顺序一一尝试 for(i=1;i&lt;=n;i++) &#123; //判断牌i是否在手上 if(book[i]==0)//book[i]等于0表示i号扑克牌在手上 &#123; //开始尝试使用扑克牌 a[step]=i;//将i号扑克牌放入第step个盒子中 book[i]=1;//将book[i]设为1，表示i号扑克牌已经不在手上 //第step个盒子已经放好了牌，接下来要走到下一个盒子面前 dfs(step+1);//进行递归调用，这里需要仔细思考 book[i]=0;//这一步也很重要，是将刚才尝试的牌收回，再进行下一次尝试 &#125; &#125; return;&#125;int main()&#123; cin&gt;&gt;n;//输入要注意n为1~9之间的整数 dfs(1);//开始站在第一个小盒子前 return 0;&#125; 输出组合排列与组合是常用的数学方法，其中组合就是从n个元素中抽出r个元素(不分顺序且r &lt; ＝ n)，我们可以简单地将n个元素理解为自然数1，2，…，n，从中任取r个数。现要求你不用递归的方法输出所有组合。例如n ＝ 5 ，r ＝ 3 ，所有组合为：1 2 31 2 41 2 51 3 41 3 51 4 52 3 42 3 52 4 53 4 5输入：一行两个自然数n、r ( 1 &lt; n &lt; 21，1 &lt; ＝ r &lt; ＝ n )输出：所有的组合，每一个组合占一行且其中的元素按由小到大的顺序排列，所有的组合也按字典顺序。代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;int n,r,a[25];bool vis[25];// 来记录各个数字是否被访问using namespace std;void dfs (int dep)//dep代表搜索的深度，即当前数组a添加了多少个数&#123; for (int i=a[dep-1]+1;i&lt;=n;++i)//从上一个添加的数+1开始搜索数字 &#123; if (!vis[i])//如果这个数字没被访问过 &#123; a[dep]=i;//将这个数字添加到a里面去 if (dep==r)//如果添加的数字达到r个，把他们输出 &#123; int j; for ( j=1;j&lt;r;++j) printf(\"%d \",a[j]); printf(\"%d\\n\",a[j]); &#125; else dfs(dep+1);//如果达不到r个继续添加 vis[i]=0;//回溯，清空当前状态，把vis[i]设为没有访问过。 &#125; &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;r); dfs(1);//写成dfs很巧妙 return 0;&#125;/* Time:12 ms Memory:1696 kb*/ 走迷宫输入：迷宫地图、起点坐标、出口坐标输出：最少走多少步 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;using namespace std;int p,q,m,n,minx=99999999;int book[51][51],a[51][51];void dfs(int x,int y,int step)&#123; int next[4][2]&#123; &#123;0,1&#125;,//向右 &#123;1,0&#125;,//向下 &#123;0,-1&#125;,//向左 &#123;-1,0&#125;//向上 &#125;;//用行列表示，而不是坐标 int tx,ty;//记录当前位置 if(x==p &amp;&amp; y==q) &#123; if(step&lt;minx) minx=step; return; &#125; //枚举四种走法 for(int i=0;i&lt;=3;i++) &#123; //模拟上下左右移动 tx=x+next[i][0]; ty=y+next[i][1]; //判断是否越界 if(tx&lt;1||tx&gt;n||ty&lt;1||ty&gt;m) continue; //判断该点是否为障碍物或者已经在路径中 if(a[tx][ty]==0&amp;&amp;book[tx][ty]==0) &#123; book[tx][ty]=1;//标记这个点已经走过 dfs(tx,ty,step+1);//开始尝试下一个点 book[tx][ty]=0;//尝试结束，取消这个点的标记 &#125; &#125; return;&#125;int main()&#123; int startx,starty; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; cin&gt;&gt;a[i][j];//输入迷宫 &#125; cin&gt;&gt;startx&gt;&gt;starty&gt;&gt;p&gt;&gt;q;//输入起点和终点坐标 //开始搜索 book[startx][starty]=1;//标记起点已经在路径中，防止后面重复走 dfs(startx,starty,0);//最开始步数为0 cout&lt;&lt;minx; return 0; /*例： 5 4 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 输出：7 */&#125; 宝岛探险类型一：题意：给出一个n*m大小的地图，0表示海，1~9表示小岛，数字越大岛越重要，现在给出起点坐标，问所在岛屿有多大。(视起始坐标上下左右相邻的区域为同一个岛屿)输入：地图大小，起始坐标输出：岛屿大小代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;using namespace std;int maze[51][51];bool vis[51][51];int n,m,sum;void dfs(int x,int y)&#123; //定义一个方向数组 int next[4][2]=&#123;0,1,1,0,0,-1,-1,0&#125;; int tx,ty; for(int k=0;k&lt;4;k++) &#123; tx=x+next[k][0]; ty=y+next[k][1]; if(tx&lt;0||tx&gt;=n||ty&lt;0||ty&gt;=m) continue; //判断是否是陆地 if(maze[tx][ty]&gt;0&amp;&amp;vis[tx][ty]==0) &#123; sum++; vis[tx][ty]=1;//标记已经走过 dfs(tx,ty);//开始尝试下一个点 &#125; &#125; return;&#125;int main()&#123; int startx,starty; cin&gt;&gt;n&gt;&gt;m&gt;&gt;startx&gt;&gt;starty; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;maze[i][j]; vis[startx][starty]=1;//标记起点已经走过 sum=1; //从起点开始遍历 dfs(startx,starty); //最后输出所在岛屿大小 cout&lt;&lt;sum; return 0; /* 样例输入： 10 10 6 8 1 2 1 0 0 0 0 0 2 3 1 0 1 0 1 1 1 0 1 1 1 0 1 0 1 1 1 1 0 1 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 1 1 1 0 0 1 1 1 0 1 1 1 1 0 0 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 0 0 0 0 0 1 1 1 1 0 1 2 0 0 0 0 0 0 0 0 1 0 样例输出：38 */ &#125; 在本题中，如果斜着连在一起也算同一个小岛，则在遍历部分的循环则有必要变成这样： 12345678for(int dx=-1;dx&lt;=1;dx++) for(int dy=-1;dy&lt;=1;dy++) &#123; tx=x+dx; ty=y+dy; if(balabala) dfs(tx,ty); &#125; 类型二：题意：地图同上，判断地图中有多少个独立的小岛。思路：对每一个大于零的点进行深度优先搜索，因为等于零的点是海洋，小于零的点已经被标记，我们可以从(0,0)开始，一直枚举到(n,m)，对每个点进行尝试。代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;using namespace std;int maze[51][51];bool vis[51][51];int n,m;void dfs(int x,int y,int color)&#123; //定义一个方向数组 int next[4][2]=&#123;0,1,1,0,0,-1,-1,0&#125;; int tx,ty; maze[x][y]=color; for(int k=0;k&lt;4;k++) &#123; tx=x+next[k][0]; ty=y+next[k][1]; if(tx&lt;0||tx&gt;=n||ty&lt;0||ty&gt;=m) continue; //判断是否是陆地 if(maze[tx][ty]&gt;0&amp;&amp;vis[tx][ty]==0) &#123; vis[tx][ty]=1;//标记已经走过 dfs(tx,ty,color);//开始尝试下一个点 &#125; &#125; return;&#125;int main()&#123; int num=0; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;maze[i][j]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(maze[i][j]&gt;0) &#123; num--;//小岛需要染的颜色的编号 //每发现一个小岛应该染以不同的颜色，因此每次要-1 vis[i][j]=1; dfs(i,j,num); &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=1;j&lt;m;j++) &#123; printf(\"%3d\",maze[i][j]);//输出小岛地图 &#125; cout&lt;&lt;endl; &#125; //最后输出所在岛屿的个数 cout&lt;&lt;-num; return 0; /* 样例输入： 10 10 1 2 1 0 0 0 0 0 2 3 1 0 1 0 1 1 1 0 1 1 1 0 1 0 1 1 1 1 0 1 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 1 1 1 0 0 1 1 1 0 1 1 1 1 0 0 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 0 0 0 0 0 1 1 1 1 0 1 2 0 0 0 0 0 0 0 0 1 0 样例输出： -1 -1 0 0 0 0 0 -2 -2 0 -1 0 -3 -3 -3 0 -2 -2 0 -1 0 -3 -3 -3 -3 0 -2 -1 0 0 0 -3 -3 -3 0 0 0 0 0 0 0 -3 -3 -3 0 -3 -3 -3 0 -3 -3 -3 -3 0 -3 -3 -3 -3 -3 -3 -3 -3 0 0 -3 -3 -3 -3 -3 -3 0 0 0 0 -3 -3 -3 -3 0 -4 -4 0 0 0 0 0 0 0 -4 0 4 */&#125; 最后附一个dfs的模板 12345678910111213141516171819202122232425void dfs()//参数用来表示状态 &#123; if(到达终点状态) &#123; ...//根据题意添加 return; &#125; if(越界或者是不合法状态) return; if(特殊状态)//剪枝 return ; for(扩展方式) &#123; if(扩展方式所达到状态合法) &#123; 修改操作;//根据题意来添加 标记； dfs（）； (还原标记)； //是否还原标记根据题意 //如果加上（还原标记）就是 回溯法 &#125; &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://brillianttt.gitee.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"https://brillianttt.gitee.io/tags/dfs/"}]},{"title":"链表的学习","slug":"链表的学习","date":"2020-06-04T14:19:06.000Z","updated":"2020-06-05T00:12:44.617Z","comments":true,"path":"2020/06/04/链表的学习/","link":"","permalink":"https://brillianttt.gitee.io/2020/06/04/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"果然专业课还是一点也不能水，上学期最后的指针没认真学，现在看书自学还得先补上学期的知识漏洞😑今天复习了指针的知识，还学习了一部分链表的内容，下面记录下今天的学习内容。 在存储一大波数的时候，我们通常使用的是数组，但有时候数组显得不够灵活，比如下面这个例子。有一串已经从小到大排好序的数 2 3 5 8 9 10 18 26 32。现需要往这串数中插入 6 使其得到的新序列仍符合从小到大排列。如我们使用数组来实现这一操作，则需要将8和8后面的数都依次往后挪一位，这样操作显然很耽误时间，如果使用链表则会快很多。 指针的复习先看以下语句： 12int a;int *p; 第一行我们很熟悉了，就是定义一个整型变量 a。第二行你会发现在 p 前面多了一个号，这就表示定义了一个整型指针变量 p。即定义一个指针，只需在变量前面加一个号就OK啦。接下来，指针有什么作用呢？答案是：存储一个地址。确切地说是存储一个内存空间的地址，比如说整型变量 a 的地址。严格地说这里的指针 p 也只能存储“一个存放整数的内存空间”的地址，因为在定义的时候我们已经限制了这一点（即定义的时候*p 的前面是 int）。当然你也可以定义一个只能用来存储“一个存放浮点数的内存空间”的地址，例如： 1double *p; 简单地说，指针就是用来存储地址的。你可能要问：不就是存储地址嘛，地址不都一样吗，为什么还要分不同类型的指针呢？不要着急，待会后面再解释。接下来需要解决的一个问题：整型指针 p 如何才能存储整型变量 a 的地址呢？很简单，如下： 1p=&amp;a; &amp;这个符号很熟悉吧，就是经常在 scanf 函数中用到的&amp;。&amp;叫取地址符。这样整型指针p就获得了（存储了）整型变量a的地址，我们可以形象地理解整型指针p指向了整型变量a。p指向了a之后，有什么用呢？用处就是我们可以用指针p来操作变量a了。比如我们可以通过操作指针p来输出变量a的值，如下： 12345678910#include &lt;stdio.h&gt; int main() &#123; int a=10; int *p; //定义个指针p p=&amp;a; //指针p获取变量a的地址 printf(\"%d\",*p); //输出指针p所指向的内存中的值 return 0; //输出10&#125; 这里 printf 语句里面p 中的号叫做间接运算符，作用是取得指针 p 所指向的内存中的值。在C语言中号有三个用途，分别是：乘号，用做乘法运算，例如 56。申明一个指针，在定义指针变量时使用，例如 int p;。间接运算符，取得指针所指向的内存中的值，例如 printf(“%d”,p);。 到目前为止，你可能还是觉得指针没啥子实际作用，好好的变量 a 想输出是的话直接printf(“%d”,a); 不完了，没事搞个什么指针啊，多此一举。嗯，到目前为止貌似是这样的O(∩_∩)O 哈哈~~不要着急，真枪实弹地来了。回想一下，我们想在程序中存储一个整数 10，除了使用 int a;这种方式在内存中申请一块区域来存储，还有另外一种动态存储方法: 1malloc(4) malloc 函数的作用就是从内存中申请分配指定字节大小的内存空间。上面这行代码就申请了 4 个字节。如果你不知道 int 类型是 4 个字节的，还可以使用 sizeof(int)获取 int 类型所占用的字节数，如下： 1malloc(sizeof(int)); 现在你已经成功地从内存中申请了 4 个字节的空间来准备存放一个整数，可是如何来对这个空间进行操作呢？这里我们就需要用一个指针来指向这个空间，即存储这个空间的首地址。 12int *p; p=(int *)malloc(sizeof(int)); 需要注意，malloc 函数的返回类型是 void * 类型。void * 表示未确定类型的指针。在 C 和 C++中，void * 类型可以强制转换为任何其他类型的指针。上面代码中我们将其强制转化为整型指针，以便告诉计算机这里的 4 个字节作为一个整体用来存放整数。还记得我们之前遗留了一个问题：指针就是用来存储内存地址的，为什么要分不同类型的指针呢？因为指针变量存储的是一个内存空间的首地址（第一个字节的地址），但是这个空间占用了多少个字节，用来存储什么类型的数，则是由指针的类型来标明的。这样系统才知道应该取多少个连续内存作为一个数据。OK，现在我们可以通过指针 p 对刚才申请的 4 个字节的空间进行操作了，例如我们向这个空间中存入整数 10，如下： 1*p=10; 完整代码如下，注意当在程序中使用 malloc 函数时需要用到 stdlib.h 头文件 1234567891011#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() &#123; int *p; //定义一个指针p p=(int *)malloc(sizeof(int)); //指针p获取动态分配的内存空间地址 *p=10; //向指针p所指向的内存空间中存入10 printf(\"%d\",*p); //输出指针p所指向的内存中的值 return 0; //输出10&#125; 链表基础的学习时间有限，直接上代码和注释： 使用链表进行读入123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //这里创建一个结构体用来表示链表的结点类型struct node &#123; int data; //吹村具体数值 struct node *next; //储存下一个节点的地址&#125;; int main() &#123; struct node *head,*p,*q,*t; int i,n,a; scanf(\"%d\",&amp;n); head = NULL;//头指针初始为空,头指针的作用是方便以后从头遍历整个链表 for(i=1;i&lt;=n;i++)//循环读入n个数 &#123; scanf(\"%d\",&amp;a); //动态申请一个空间，用来存放一个结点，并用临时指针p指向这个结点 p=(struct node *)malloc(sizeof(struct node)); p-&gt;data=a;//将数据存储到当前结点的data域中 p-&gt;next=NULL;//设置当前结点的后继指针指向空，也就是当前结点的下一个结点为空 if(head==NULL) head=p;//如果这是第一个创建的结点，则将头指针指向这个结点 else q-&gt;next=p;//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点 q=p;//指针q也指向当前结点 &#125; //输出链表中的所有数 t=head; while(t!=NULL) &#123; printf(\"%d \",t-&gt;data); t=t-&gt;next;//继续下一个结点 &#125; return 0; &#125; 上面的代码中我们发现了一个很奇怪的符号“-&gt;”。-&gt;叫做结构体指针运算符，也是用来访问结构体内部成员的。因为此处 p 是一个指针，所以不能使用.号访问内部成员，而要使用-&gt;。 链表实现数据的插入12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //这里创建一个结构体用来表示链表的结点类型struct node &#123; int data; struct node *next; &#125;; int main() &#123; struct node *head,*p,*q,*t; int i,n,a; scanf(\"%d\",&amp;n); head = NULL;//头指针初始为空 for(i=1;i&lt;=n;i++)//循环读入n个数 &#123; scanf(\"%d\",&amp;a); //动态申请一个空间，用来存放一个结点，并用临时指针p指向这个结点 p=(struct node *)malloc(sizeof(struct node)); p-&gt;data=a;//将数据存储到当前结点的data域中 p-&gt;next=NULL;//设置当前结点的后继指针指向空，也就是当前结点的下一个结点为空 if(head==NULL) head=p;//如果这是第一个创建的结点，则将头指针指向这个结点 else q-&gt;next=p;//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点 q=p;//指针q也指向当前结点 &#125; scanf(\"%d\",&amp;a);//读入待插入的数 t=head;//从链表头部开始遍历 while(t!=NULL)//当没有到达链表尾部的时候循环 &#123; if(t-&gt;next-&gt;data &gt; a)//如果当前结点下一个结点的值大于待插入数，将数插入到中间 &#123; p=(struct node *)malloc(sizeof(struct node));//动态申请一个空间， 用来存放新增结点 p-&gt;data=a; p-&gt;next=t-&gt;next;//新增结点的后继指针指向当前结点的后继指针所指向的结点 t-&gt;next=p;//当前结点的后继指针指向新增结点 break;//插入完毕退出循环 &#125; t=t-&gt;next;//继续下一个结点 &#125; //输出链表中的所有数 t=head; while(t!=NULL) &#123; printf(\"%d \",t-&gt;data); t=t-&gt;next;//继续下一个结点 &#125; return 0; &#125; 模拟链表链表中的每一个结点只有两个部分。我们可以用一个数组 data 来存储每序列中的每一个数。那每一个数右边的数是谁，这一点该怎么解决呢？上一节中是使用指针来解决的，所以只需再用一个数组right来存放序列中每一个数右边的数是谁就可以了：上图的两个数组中，第一个整型数组 data 是用来存放序列中具体数字的，另外一个整型数组right是用来存放当前序列中每一个元素右边的元素在数组data中位置的。例如right[1]的值为2，就表示当前序列中1号元素右边的元素存放在data[2]中；如果是 0，例如 right[9]的值为0，就表示当前序列中9号元素的右边没有元素。现在需要在8前面插入一个6，只需将6直接存放在数组data的末尾即data[10]=6。接下来只需要将right[3]改为10，表示新序列中3号元素右边的元素存放在data[10]中。再将right[10]改为4，表示新序列中10号元素右边的元素存放在data[4]中。这样我们通过right数组就可以从头到尾遍历整个序列了（序列的每个元素的值存放在对应的数组data中），如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt; int main() &#123; int data[101],right[101]; int i,n,t,len; //读入已有的数 scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++) scanf(\"%d\",&amp;data[i]); len=n; //初始化数组right for(i=1;i&lt;=n;i++) &#123; if(i!=n) right[i]=i+1; else right[i]=0; &#125; //直接在数组data的末尾增加一个数 len++; scanf(\"%d\",&amp;data[len]); //从链表的头部开始遍历 t=1; while(t!=0) &#123; if(data[right[t]]&gt;data[len])//如果当前结点下一个结点的值大于待插入数，将数插入到中间 &#123; right[len]=right[t];//新插入数的下一个结点标号等于当前结点的下一个结点编号 right[t]=len;//当前结点的下一个结点编号就是新插入数的编号 break;//插入完成跳出循环 &#125; t=right[t]; &#125; //输出链表中所有的数 t=1; while(t!=0) &#123; printf(\"%d \",data[t]); t=right[t]; &#125; return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://brillianttt.gitee.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"位运算的使用","slug":"位运算的使用","date":"2020-06-03T13:56:43.000Z","updated":"2020-06-09T14:32:30.729Z","comments":true,"path":"2020/06/03/位运算的使用/","link":"","permalink":"https://brillianttt.gitee.io/2020/06/03/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"这是一个关于位运算的链接。 这是一个关于位运算的例题。 这是👆题的题解。 补充： 1、i&lt;32是因为2^32-1的表示数为二进制的32个1，足可使用 2、x &lt;&lt; i 是指将x按照二进制左移i位，例如00000001，左移2位变成了00000100。移动后的数转化为十进制事实上是x*2^i。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://brillianttt.gitee.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"algorithm库的使用","slug":"algorithm库的使用","date":"2020-06-03T00:38:07.000Z","updated":"2020-09-03T08:48:04.786Z","comments":true,"path":"2020/06/03/algorithm库的使用/","link":"","permalink":"https://brillianttt.gitee.io/2020/06/03/algorithm%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"algorithm头文件下的常用函数max()、min()、abs()max(x,y)和min(x,y)分别返回x和y中的最大值和最小值。且参数必须是两个（可以是浮点数）。若想返回三个数x,y,z的最大值，可以使用max（x,max(y,z))的写法。abs(x)返回x的绝对值，此处x为整数，若使用浮点数的绝对值要用math库下的fabs()。 swap()swap()用来交换x和y的值 reverse()reverse(it,it2)可以将数组指针在[it,it2)之间的元素或容器的迭代器在[it,it2)范围内的元素进行反转，举例如下： 12345678910111213#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[10]=&#123;10,11,12,13,14,15&#125;; reverse(a,a+4); for(int i=0;i&lt;6;i++)&#123; printf(\"%d \",a[i]); &#125; return 0; //输出13 12 11 10 14 15&#125; 容器内举例如下： 1234567891011121314#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;int main()&#123; string str=\"hello world\"; reverse(str.begin(),str.end()); for(int i=0;i!=str.length;i++)&#123; printf(\"%c\",str[i]); &#125; return 0; //输出dlrow olleh&#125; next_permutation()next_permutation()给出一个序列在全排列中的下一个序列。例如，当n=3的时候，全排列为123 132 213 231 312 321.这样231的下一个序列就是312. 123456789101112#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[10]=&#123;1,2,3&#125;; do&#123; printf(\"%d%d%d\\n\",a[0],a[1],a[2]); &#125;while(next_permutation(a,a+3)); return 0; //输出123\\n132\\n213\\n231\\n312\\n321\\n&#125; 在上述代码中使用循环是因为next_permutation在已经到达全排列的最后一个时会返回false,这样会方便退出循环。 fill()fill()可以把数组或容器中的某一段区间赋为某个相同的值。和memset不同，这里的赋值可以是数组类型对应范围中的任意值。 1fill(a,a+5,233)//将a[0]~a[4]均赋值为233 sort()如何使用sort排序sort函数的使用必须加上#includeusing namespace std，使用方式如下： 1sort(首元素地址（必填），尾元素的下一个地址（必填），比较函数（非必填）)； 如果不写cmp函数，则默认对前面给出的区间进行递增排序。 实现比较函数cmp基本数据类型数组的排序若不写比较函数，则默认升序排序： 123456789101112#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std; int main()&#123; int a[5]=&#123;3, 1, 4, 2&#125;; sort(a,a + 4) ; for(int i=0;i&lt;4;i++)&#123; printf (\"%d\",a[i]); &#125;//输出1234return 0;&#125; 若想要从大到小排序，则需使用比较函数cmp来“告诉”sort何时要交换元素。 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std; int cmp(int a,int b)&#123; rerturn a&gt;b;//可以理解为当a&gt;b时把a放在b前面&#125;int main()&#123; int a[5]=&#123;3, 1, 4, 2&#125;; sort(a,a + 4，cmp) ; for(int i=0;i&lt;4;i++)&#123; printf (\"%d\",a[i]); &#125;//输出4321return 0;&#125; 结构体数组的排序12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;struct node&#123; int x,y;&#125; ssd[10];bool cmp (node a,node b) &#123; if (a.x!=b.x) return a.x&gt;b.x;//x不等时按x从大到小排序 else return a.y&lt;b.y; //x相等时按y从小到大排序&#125;int main()&#123; ssd[0].x=2; // (2, 2) ssd[0].y=2; ssd[1].x=1; // &#123;1, 3) ssd[1].y=3; ssd[2].x=3; // (3, 1) ssd[2].y=1; sort(ssd,ssd+3,cmp) ; //排序 for(int i=0;i&lt;3;i++) printf(\"%d %d\\n\",ssd[i].x,ssd[i].y); return 0; /*输出 3 1 2 2 1 3 */&#125; 容器的排序在stl标准容器中，只有vector、string、deque可以使用sort。因为像set、map这种容器使用红黑树实现的，元素本身有序，故不可使用sort排序。举例。。。就不举例了，大同小异。 lower_bound()和upper_bound()lower_bound()和upper_bound()需要用在一个有序数组或容器中。lower_bound(first,last,val)用来寻找在数组或容器的［first,last) 范围内第一个值大于等于val的元素的位置，如果是数组，则返回该位置的指针；如果是容器，则返回该位置的选代器。upper_bound(first,last,val) 用来寻找在数组或容器的［first,last) 范围内第一个值大于val的元素的位置，如果是数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器。显然，如果数组或容器中没有需要寻找的元素，则lower_bound()和upper_bound()均返回可以插入该元素的位置的指针或选代器（即假设存在该元素时，该元素应当在的位置）。举例如下： 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+10;const int INF=2*int(1e9)+10;#define LL long longint cmp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; int num[6]=&#123;1,2,4,7,15,34&#125;; sort(num,num+6); //按从小到大排序 int pos1=lower_bound(num,num+6,7)-num; //返回数组中第一个大于或等于被查数的值 int pos2=upper_bound(num,num+6,7)-num; //返回数组中第一个大于被查数的值 cout&lt;&lt;pos1&lt;&lt;\" \"&lt;&lt;num[pos1]&lt;&lt;endl; cout&lt;&lt;pos2&lt;&lt;\" \"&lt;&lt;num[pos2]&lt;&lt;endl; sort(num,num+6,cmp); //按从大到小排序 int pos3=lower_bound(num,num+6,7,greater&lt;int&gt;())-num; //返回数组中第一个小于或等于被查数的值 int pos4=upper_bound(num,num+6,7,greater&lt;int&gt;())-num; //返回数组中第一个小于被查数的值 cout&lt;&lt;pos3&lt;&lt;\" \"&lt;&lt;num[pos3]&lt;&lt;endl; cout&lt;&lt;pos4&lt;&lt;\" \"&lt;&lt;num[pos4]&lt;&lt;endl; return 0; &#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://brillianttt.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"库函数的使用","slug":"库函数的使用","permalink":"https://brillianttt.gitee.io/tags/%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/"}]},{"title":"code::blocks设置调试和主题背景","slug":"codeblocks设置调试和主题背景","date":"2020-06-02T00:48:11.732Z","updated":"2020-06-02T01:59:49.203Z","comments":true,"path":"2020/06/02/codeblocks设置调试和主题背景/","link":"","permalink":"https://brillianttt.gitee.io/2020/06/02/codeblocks%E8%AE%BE%E7%BD%AE%E8%B0%83%E8%AF%95%E5%92%8C%E4%B8%BB%E9%A2%98%E8%83%8C%E6%99%AF/","excerpt":"","text":"设置调试安装好Code::Block后完成编译和运行后却无法调试，弹出Error:You need to specify a debugger program in the debuggers’s settings.无法编译根据提示信息我们需要指定一个debugger program，根据提示我们可以知道指定的菜单栏settings。我们可以看到默认状态下路径是空的，那么我们就需要设置一个路径。 找到code::block的默认安装路径并进入CodeBlocks\\MinGW\\gdb32\\bin选择gdb32.exe。单击OK即可开始进行编译。 设置主题背景首先进入codeblocks官网找到color theme的代码。 紧接着在C盘中找到CodeBlocks/default.conf，注意default.conf文件不再你的安装文件夹下，而是在系统盘下，以win10系统为例，路径为：user/你的用户名/AppData/Roaming/CodeBlocks。 在进行下一步前，要确保codeblocks已经关闭。 下一步是通过记事本打开default.conf文件，把default.conf文件中的代码全部替换为第一步中在codeblocks官网上找到的代码，保存并关闭。注意在替default.conf文件代码时最好做好备份以免出错。 下一步就是感受快乐了！！！ 下下一步，如果想要改变其他风格可以在Settings/Editor/Syntax Highlighting/colour theme中选择想要的风格，也可以自定义各种颜色，还可以在margins and caret–&gt;caret的color中设置光标颜色。","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://brillianttt.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"code::blocks","slug":"code-blocks","permalink":"https://brillianttt.gitee.io/tags/code-blocks/"}]},{"title":"C++STL学习笔记","slug":"C++STL容器的学习","date":"2020-05-13T13:41:57.792Z","updated":"2020-10-15T16:36:55.456Z","comments":true,"path":"2020/05/13/C++STL容器的学习/","link":"","permalink":"https://brillianttt.gitee.io/2020/05/13/C++STL%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"最近开始学习c++的stl容器，下面记录一些学习的笔记。 STL（Standard Template Library）,中文名为标准模板库，其中封装了许多容器，而容器可以理解为能实现很多功能的东西。在写代码时可以快速调用他们，省去了自己书写完整的时间。 vector的常见用法vector本身可以作为数组使用，在元素不确定的场合可以很好的节省空间 vector的定义123456789101112131415#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; name; vector&lt;double&gt; name; vector&lt;char&gt; name; //如果类型名为vector，就为以下定义方式👇(可以理解为二维数组) vector&lt;vector&lt;int&gt;&gt; name; //vector数组的定义： vector&lt;typename&gt; Arrayname[arraySize]; //例如这样定义（这样其中的每一个都是一个vector容器）： vector nb[666]；&#125; vector二维数组的初始化初始化一个6*5的二维数组： 1234567891011121314#include&lt;iostream&gt;using namespace std;int main() &#123; vector&lt;vector&lt;int&gt; &gt;num = &#123; &#123;1,1,1,0,1,1&#125;,&#123;1,0,1,1,1,1&#125;,&#123;1,1,1,0,0,1&#125;,&#123;1,0,1,0,0,1&#125;,&#123;1,1,1,1,1,1&#125; &#125;; //二维数组初始化 //vector&lt;vector&lt;int&gt;&gt; vec(10, vector&lt;int&gt;(10)); vector&lt;vector&lt;int&gt; &gt;right(num.size(), vector&lt;int&gt;(num[0].size())); vector&lt;vector&lt;int&gt; &gt;down(num.size(), vector&lt;int&gt;(num[0].size())); construct(num, right, down); cout &lt;&lt; calculate(num, right, down) &lt;&lt; endl; return 0;&#125; 也可以这么写： 12std::vector &lt;int&gt; vec(10,90); //将10个一维动态数组初始为90std::vector&lt;std::vector&lt;int&gt; &gt; vec(row,vector&lt;int&gt;(col,0)); //初始化row * col二维动态数组，初始化值为0,其实就是每一行初始化为列数个0 vector的访问vector有两种访问方式：通过下标或者迭代器。下标访问即为以前学过的知识，迭代器访问为c++中新的概念，可以理解为类似指针的东西，可以如下定义： 123vector&lt;typename&gt;::iterator it;//这样就可以通过*it来访问vector里的元素//在循环中使用可以如下定义：for(vector&lt;typename&gt;::iterator it=name.begin();it!=name.end();it++)&#123;&#125; 但是这样写比较繁琐，我们可以使用auto关键字简化代码： 123auto i=name.begin();//在循环中使用可以如下定义：for(auto it=name.begin();it!=name.end();it++)&#123;&#125; vector常用函数1234567891011121314vector&lt;int&gt; name;name.push_back(i)//push_back(i)在name的末尾添加元素i，常和循环连用以输入输出数据name.begin()//取name的首元素地址，和迭代器连用auto i=name.begin(),使得i指向这个地址name.end()//取name的尾地址，用法同上name.pop_back()//删除vector的尾元素name.size()//获得vector中元素的个数，返回unsigned类型，可以用%d输出size_row = name.size(); //获取二维数组行数size_col = name[0].size(); //获取二维数组列数name.clear()//清空vector中的所有元素name.insert(it，x)//用来向vector的任意迭代器it处插入一个元素x，例如：name.insert(name.begin()+2,-1);name.erase(it)//删除迭代器it处的元素name.erase(name.begin()+3)//注意删除的是name[4]name.erase(first,last)//删除[first,last)内的所有元素name.erase(name.first(),name.end())//效果同name.clear() set的常见用法set翻译为集合，是一个内部自动有序并且不含有重复元素的容器，在需要重复的时候，可以快捷的使用set实现自动排序（升序排列）并且去重。 set的定义12set&lt;typename&gt; name;//单独定义一个setset&lt;typename&gt; Arrayname[arraySize];//set数组的定义，Arrayname[0]~Arrayname[arraySize-1]中每一个都是一个set容器 set内元素的访问set只能同迭代器访问： 12set&lt;typename&gt;::iterator it;auto it=name.(); 由于除了vector和string之外的stl容器都不支持*(it+i)的访问方式，因此只能使用枚举法： 1234567891011121314#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main()&#123; set&lt;int&gt; nb; for(int i=10;i&gt;2;i--) &#123; nb.insert(i); &#125; for(auto i=nb.begin();i!=nb.end();i++)&#123; printf(\"%d \",*i); &#125; &#125;//输出 3 4 5 6 7 8 9 10（实现了自动从小到大排序） set常用函数 123456789name.insert(x)//将x插入set容器中，并自动实现递增排序和去重name.find(value)//返回set中对应值为value的迭代器，如printf(\"%d\",*(name.find(2)));name.erase()//用法同vector中的函数一样，一般还可与name.find()连用，实现“找到并删除”name.size()//用来获得set内元素个数name.clear()//清空set内所有元素name.empty()//若集合为空，返回truename.count()//返回某个值元素的个数lower_bound()//lover_bound(val)返回值指向大于（或等于）val的第一个元素的迭代器）upper_bound()//返回大于某个值元素的迭代器 string的常见用法 string对字符串常用的功能进行了封装，使得操作更方便。在使用string时需要添加string头文件即#include string的定义 定义string的方式和基本数据类型相同，可以直接定义 12string str;string str=\"abc\"; string内容的访问通过下标访问 1234string str=\"abcd\";for(int i=0;i&lt;str.length();i++)&#123; printf(\"%c\",str[i]);&#125;//输出结果为abcd 若要输入和输出整个字符串可用cin和cout还有c_str() 1234string str;cin&gt;&gt;str;cout&lt;&lt;str&lt;&lt;endl;printf(\"%s\",str.c_str());//将string型转化为字符数组输出 通过迭代器访问1234567string::iterator it;string str=\"abcd\"; -for(auto it=str.begin();it!=str.end();it++)&#123; printf(\"%c\",*it); printf(\"%c\",*(str.begin()+3));&#125; string常用函数拼接： 123string str1=\"abc\",str2=\"xyz\",str3;str3=str1+str2;//直接将str1和2拼接到str3上str1+=str2；//将str2加到str1后面 比较： 1if(str1&gt;str2) printf(\"balabala\");//按照字典序比较 长度： 1printf(\"%d %d\",str.length(),str.size()); 插入元素： 12str.insert(3,str2);//str2插入str[3]位置str.insert(str.begin(+1),str2.begin(),str2.end());//name.insert(x,y,z)x为待插入位置，y、z分别为要插入字符串的首尾迭代器 其他函数： 12345678910str.erase(it)//删除单个元素，it为需要删除的元素迭代器str.erase(first,last)；//first为需要删除的区间的起始迭代器，last为区间末尾迭代器的下一个地址，即为删除[first,last)str.erase(pos,length);//pos为开始删除的起始位置，length为删除字符个数str.clear();//清空string中的数据str.substr(pos,len)//返回从pos位开始，长度为len的子串str.find(str2)//当str2是str的子串时，返回其在str中第一次出现的位置(即str2第一个字符出现的位置)，若str2不是str的子串时返回string::nopsstring::npos//是一个常数，由于是unsigned_int类型，也可认为时ugsigned_int的最大值str.replace(pos,len,str2)//把str从pos位开始，长度为len的子串替换为str2str.replace(it1，it2，str2)//把str的迭代器[it1，it2)范围的子串替换为str2reverse(str.begin(),str.end()-5);//反转指定区域的字符 map的常见用法map翻译为映射，是常用的stl容器之一。map可以将任何基本类型（包括stl容器）映射到任何类型（也包括stl容器）；在使用map的时候还要添加map头文件。在需要建立字符或字符串与整数之间映射的题目，使用map可以减少代码量；判断大整数或者其它类型的数据是否存在的题目，可以把map当bool使用。 map的定义123map&lt;typename1,typename2&gt;mp;//1、2分别代表映射前和映射后的类型，如果两种类型相同，就相当于普通的数组。map&lt;string,int&gt;mp;//若为字符串到整型的映射，必须使用string而不能用char。map&lt;set&lt;int&gt;,string&gt;mp;//将set容器映射到一个字符串 map容器内元素的访问通常有两种访问方式：通过下标和通过迭代器。 通过下标访问12345678910#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['c']=20; mp['c']=30; printf(\"%d\",mp['c']);&#125;//输出30 通过迭代器访问1map&lt;typename1,typename2&gt;::iterator it;//map迭代器的定义，同样可以用auto 因为map的每一个映射都有两个typename，所以访问方式略有不同，map可以使用it-&gt;first来访问第一个参数（键），it-&gt;second来访问第二个参数（值）。下面举个栗子。 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['m']=20; mp['b']=30; mp['y']=40; for(map&lt;char,int&gt;::iterator it=map.begin();it!=map.end();it++)//也可以写为auto it=begin() &#123; printf(\"%c %d\\n\",it-&gt;first,it-&gt;second); &#125;&#125;//输出如下： b 30 m 20 y 40 有没有发现map按“键”对它进行了从小到大的排序这是通过红黑树实现的（set也是），在建立映射的时候会自动实现从小到大的排序功能。（ps：我暂时也不知道红黑树是什么，等之后学到了回来补充。） map常用函数find()函数123456789101112#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['a']=1; mp['b']=2; mp['c']=3; auto i=mp.find('b');//find(key)返回键为key的映射的迭代器 printf(\"%c %d\",it-&gt;first,it-&gt;second);//输出b 2&#125; erase()erase()有两种用法：删除单个元素和删除一个区间内的所有元素 删除单个元素12345678910111213#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['a']=1; mp['b']=2; mp['c']=3; auto it=mp.find('b');//find(key)返回键为key的映射的迭代器 mp.erase(it)l//删除b 2 mp.erase(key)//key为想要删除的映射的键，如mp.erase('a');&#125; 删除多个元素（区间内）mp.erase(first,last)//first为需要删除的区间的起始迭代器，last为需要删除的区间的末尾迭代器的下一个地址，即为删除左闭右开的区间[first,last),举例如下： 123456789101112#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['a']=1; mp['b']=2; mp['c']=3; auto it=mp.find('b');//find(key)返回键为key的映射的迭代器 mp.erase(it，mp.end())；//删除it后的所有映射，即b 2和c 3&#125; 其他函数size()用来获得map中映射的对数。clear()用来情况map中的所有元素。 quese的常见用法quese翻译为队列，在STL中主要是实现先进先出的容器。在实现广度优先搜索时，可以不用自己动手实现一个队列，而是用queue作为代替，以提高程序的准确性。 queue的定义要使用queue，需要先添加头文件#include，并且在头文件下面加上 using namespace std才可以。定义写法和其他容器一样，typename可以说任意基本数据类型或容器。 1queue&lt;typename&gt;name; queue容器内元素的访问由于queue（队列）本就是一种先进先出的限制性数据结构，因此在stl中只能通过front（）来访问队首元素，或是通过back（）来访问队尾元素。举例如下： 12345678910111213#include&lt;stdio.h&gt;#include&lt;queue&gt;using namespace std;int main()&#123; queue&lt;int&gt; q; for(int i=1;i&lt;=5;i++) &#123; q.push(i);//push(i)用以将i压入队列，因此一次入队1 2 3 4 5 &#125; printf(\"%d %d\",q.front(),q.back());//输出1 5 return 0;&#125; queue常用函数12345678910111213#include&lt;stdio.h&gt;#include&lt;queue&gt;using namespace std;int main()&#123; queue&lt;int&gt; q; q.push()//将x压入队列 q.front()//获得队首元素 q.back()//获得队尾元素 q.pop()//令队首元素出队 q.empty()//检测queue是否为空，返回true则空，false则非空 q.size()//返回queue内元素的个数&#125; 特别注意，在使用front()和pop()函数前，必须用empty()判断队列是否为空，否则可能因为队空而出现错误。 priority_queue的常见用法priority_queue又称优先队列，其底层逻辑是用堆来实现的（我也不知道堆是啥，学了回来填坑）。在优先队列中，队首元素一定是当前队列中优先级最高的那个。在任何时候都可以往优先队列里加入(push)元素，而优先队列的的底层数据结构堆（heap）会随时调整，使得每次的队首元素都是优先级最大的。 priority_queue的定义要使用优先队列，应先添加头文件#include，定义写法和其他stl容器一致，typename可以是任意类型或容器。 1priority_queue&lt;typename&gt;name; priority_queue容器内元素的访问和队列不同，优先队列内没有front()和back()函数，而只能通过top()函数来访问队首元素（即堆顶元素），也就是优先级最高的元素。 priority_queue常用函数市离解析12345push()//push(x)将令x入队top()//top()可以获得队首元素pop()//令队首元素出队empty()//检测优先队列是否为空，返回true则为空，false则为非空size()//返回优先队列内元素的个数 priority_queue内元素优先级的设置基本数据类型的优先级设置基本数据类型即为int型、double型、char型等可以直接使用的数据类型，优先队列对他们的优先级设置一般是数字大的优先级搞，因此队首元素就是优先队列内元素最大的那个（char型则为字典序最大的）。对于基本数据类型来说，下面是两种优先队列的定义是等价的（以int型为例，注意最后两个&gt;之间有一个空格）： 12priority_queue&lt;int&gt; q;priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q; 在第二种定义时多了两个参数，其中vector填写的时来承载底层数据结构堆(heap)的容器,若为double或char型只需更改&lt;&gt;内的内容即可；less则是堆第一个参数的比较类，less表示数字大的优先级越大，而greater表示数字小的优先级越大。因此若想让优先队列将最小的元素放在队首只需进行如下定义： 1priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; 举一个栗子： 12345678910111213#include &lt;cstdio&gt;#include&lt;queue&gt;using namespace std;int main()&#123; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; q.push(3); q.push(4); q.push(1); printf(\"%d\",q.top());//输出1 return 0;&#125; 结构体优先级设置没看懂书上咋设置的 看懂了再回来填坑😂 stack的常见用法stack翻译为栈，是stl中实现的一个后进先出的容器。 stack的定义要使用 stack, 应先添加头文件＃include , 并在头文件下面加上“using namespace std; ”， 然后就可以使用了。 其定义的写法和其他STL容器相同，typename 可以任意基本数据类型或容器。 stack容器内元素的访问由于栈本身是一种后进先出的数据结构，在stl的stack中只能通过top()来访问栈顶元素，举例如下： 1234567891011121314#include &lt;cstdio&gt;#include&lt;stack&gt;using namespace std;int main()&#123; stack&lt;int&gt;st; for(int i=0;i&lt;5;i++) &#123; st.push(i); &#125; printf(\"%d\\n\",st.top());//输出4 return 0;&#125; stack常用函数12345push()//push(x)将x入栈top()//获得栈顶元素pop()//弹出栈顶元素empty()//检测stack内是否为空，返回true为空，返回false为非空size()//返回栈内元素个数 stack的常见用途用来模拟实现一些递归，防止程序对栈内存的限制而导致程序运行出错。一般来说，程序的栈内存空间很小，对有些题目来说，如果用普通的函敷来进行递归，一旦递归层数过深（不同机器不同，约几千至几万层）， 则会导致程序运行崩溃。如果用栈来模拟递归算法的实现，则可以避免这一方面的问题（不过这种应用出现较少）。 pair的常见用法pair是一个很实用的“小玩意”， 当想要将两个元素绑在一起作为一个合成元素、又不想要因此定义结构体时，使用 pair 可以很方便地作为一个代替品。也就是说，pair 实际上可以看作一个内部有两个元素的结构体，且这两个元素的类型是可以指定的，如下面的短代码所示： 1234struct pair&#123; typename1 first; typename2 second;&#125; pair的定义要使用 pair, 应先添加头文件＃include , 并在头文件下面加上＂using namespacestd; ”， 然后就可以使用了，注意：由于map的内部实现中涉及pair, 因此添加map头文件时会自动添加 utility 头文件，此时如果需要使用 pair, 就不需要额外再去添加 utility 头文件了。因此，记不住“utility” 拼写的读者可以愉懒地用 map头文件来代替 utility 头文件。pair 有两个参数，分别对应 first 和 second 的数据类型，它们可以是任意基本数据类型或容器。 1pair&lt;typename1,typename2&gt; name; 因此想要定义参数为string和int类型的pair，就可以使用如下写法： 1pair&lt;string,int&gt; p; 如果要顺便进行初始化，可以这样： 1pair&lt;string,int&gt; p(\"haha\",5); pair中元素的访问pair中只有两个元素，分别为first和second，只需按照正常结构体的方法去访问。 12345678910111213141516171819include &lt;iostream&gt;＃include &lt;utility&gt;＃include &lt;string&gt;using namespace std;int main () &#123; pair &lt;string,int&gt; p; p.first=\"haha\"; p.second=5; cout&lt;&lt;p.first &lt;&lt;\" \"&lt;&lt;p.second &lt;&lt;lendl; p=make_pair (\"xixi\", 55) ; cout&lt;&lt;p.first &lt;&lt;\" \"&lt;&lt;p.second &lt;&lt;endl; p=pair&lt;string,int&gt; (\"heihei\",555); cout&lt;&lt;p.first &lt;&lt;\" \"&lt;&lt;p.second &lt;&lt; endl; return 0; //输出： haha 5 // xixi 55 // heihei 555&#125; pair常用函数比较操作数两个pair类型数据可以直接使用==、!=、&lt;、&lt;=、&gt;、&gt;=比较大小，比较规则是先以first 的大小作为标准，只有当first 相等时才去判别second的大小。 12345678910111213141516include &lt;cstdio&gt; ＃include &lt;utility&gt; using namespace std; int main ()&#123; pair&lt;int,int&gt; p1(5,10): pair&lt;int, int&gt; p2(5, 15); pair&lt;int,int&gt; p3 (10, 5) : if(p1&lt;p3) printf(\"pl &lt;p3\\n\"); if(pl&lt;=p3) printf(\"pl&lt;=p3\\n\"); if(p1&lt;p2) printf(\"pl&lt;p2\\n\"); return 0; //输出: // p1&lt;p3 // p1&lt;=p3 // p1&lt;p2 pair的常见用途1、代替二元结构体及其构造函数，节省编码时间。2、作为map的键值对来进行插入，如这个例子 1234567891011121314151617#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;string,int&gt;mp; mp.insert(make_pair(\"haha\",10)); for(map&lt;string,int&gt;::iterator it=mp.begin();it!=mp.end();it++) &#123; cout&lt;&lt;it-&gt;first&lt;&lt;\" \"&lt;&lt;it-&gt;second&lt;&lt;endl; &#125; return 0; //输出： // haha 10 // heihei 5&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://brillianttt.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"STL","slug":"STL","permalink":"https://brillianttt.gitee.io/tags/STL/"},{"name":"C/C++","slug":"C-C","permalink":"https://brillianttt.gitee.io/tags/C-C/"}]},{"title":"动态规划之最长上升子序列","slug":"动态规划之最长上升子序列","date":"2020-04-05T11:30:22.000Z","updated":"2020-06-03T02:06:18.975Z","comments":true,"path":"2020/04/05/动态规划之最长上升子序列/","link":"","permalink":"https://brillianttt.gitee.io/2020/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"动态规划 动态规划指的是将一个繁杂的问题分解成子问题之后，通过求解子问题的最优解，从而求得整体最优解。 最长上升子序列问题如下：输入数据： 输入的第一行是序列的长度N(1&lt;=N&lt;=1000),第一行给出序列的N个整数，这些整数的取值范围在0-10000. 输出要求： 最长上升子序列的长度。 输入样例： 71 7 3 5 9 4 8 输出样例： 4 范例代码： 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int maxlen[100]; int s[100]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s[i]; maxlen[i] = 1; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (s[i] &gt; s[j]) &#123; maxlen[i] = max(maxlen[i], maxlen[j] + 1); &#125; &#125; &#125; cout &lt;&lt; *max_element(maxlen + 1, maxlen + n + 1);&#125; 讲解： 123456789int n; cin &gt;&gt; n; int maxlen[100]; int s[100]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s[i]; maxlen[i] = 1; &#125; 这一部分是输入数据，并且让存储 以当前下标为终点的子序列的个数 的maxlen数组都初始化为1. 12345678910for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (s[i] &gt; s[j]) &#123; maxlen[i] = max(maxlen[i], maxlen[j] + 1); &#125; &#125; &#125; 这一部分是正式求解&ensp;以当前下标为终点的最长上升子序列&ensp;的长度，并且分别存储在maxlen数组内。i每往后循环一次，j就要将i之前的数据都循环一遍。当s[i]&gt;s[j]时就要求maxlen[j]+1与maxlen[i]之间的最大值进行maxlen[i]的更新。注：之所以需要每次都求maxlen[i]和maxlen[j]+1的最大值，而不直接将maxlen[j]+1赋值给maxlen[i]，是因为maxlen[i]之前的更新可能已经使maxlen[i]&gt;maxlen[[j]+1，故 此时maxlen[i]应保持不变。 最后一部分为输出部分，调用max_element函数输出manlen数组内的最大值。 注：max_element函数返回值是一个指针&emsp;&emsp;max_element和max函数需要调用头文件algorithm","categories":[{"name":"算法","slug":"算法","permalink":"https://brillianttt.gitee.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://brillianttt.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"排序算法","slug":"排序算法","date":"2020-04-03T02:19:36.000Z","updated":"2020-06-04T01:44:14.640Z","comments":true,"path":"2020/04/03/排序算法/","link":"","permalink":"https://brillianttt.gitee.io/2020/04/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt; using namespace std; void merge(int a[], int s, int m, int e, int tmp[])&#123; int pb = 0; int p1 = s, p2 = m+1; while (p1&lt;=m&amp;&amp;p2&lt;=e) &#123; if (a[p1] &gt; a[p2]) tmp[pb++] = a[p2++]; else tmp[pb++] = a[p1++]; &#125; while (p1&lt;=m) &#123; tmp[pb++] = a[p1++]; &#125; while (p2&lt;=e) &#123; tmp[pb++] = a[p2++]; &#125; for (int j = 0; j &lt;= e-s; ++j) &#123; a[s+j] = tmp[j]; &#125;&#125;void mergesort(int a[], int s, int e, int tmp[])&#123; if (s &lt; e) &#123; int m = s + (e - s) / 2; mergesort(a, s, m, tmp); mergesort(a, m + 1, e, tmp); merge(a, s, m, e, tmp); &#125;&#125;int a[9] = &#123; 1,2,3,6,5,4,7,8,9 &#125;;int b[9];int main()&#123; mergesort(a, 0, 8, b); for (int i = 0; i &lt; 9; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; return 0;&#125; 快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt; int a[101],n;//定义全局变量，这两个变量需要在子函数中使用 void quicksort(int left,int right) &#123; int i,j,t,temp; if(left&gt;right) return; temp=a[left]; //temp中存的就是基准数 i=left; j=right; while(i!=j) &#123; //顺序很重要，要先从右往左找 while(a[j]&gt;=temp &amp;&amp; i&lt;j) j--; //再从左往右找 while(a[i]&lt;=temp &amp;&amp; i&lt;j) i++; //交换两个数在数组中的位置 if(i&lt;j)//当哨兵i和哨兵j没有相遇时 &#123; t=a[i]; a[i]=a[j]; a[j]=t; &#125; &#125; //最终将基准数归位 a[left]=a[i]; a[i]=temp; quicksort(left,i-1);//继续处理左边的，这里是一个递归的过程 quicksort(i+1,right);//继续处理右边的，这里是一个递归的过程 &#125; int main() &#123; int i,j,t; //读入数据 scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); quicksort(1,n); //快速排序调用 //输出排序后的结果 for(i=1;i&lt;=n;i++) printf(\"%d \",a[i]); getchar();getchar(); return 0; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://brillianttt.gitee.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://brillianttt.gitee.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"markdown语法的使用教程","slug":"markdown语法的使用教程","date":"2020-03-28T02:22:46.000Z","updated":"2020-06-03T14:03:28.650Z","comments":true,"path":"2020/03/28/markdown语法的使用教程/","link":"","permalink":"https://brillianttt.gitee.io/2020/03/28/markdown%E8%AF%AD%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"这是一个关于markdown语法的链接这是关于markdown插入链接的语法的链接","categories":[{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/categories/markdown%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/tags/markdown%E8%AF%AD%E6%B3%95/"},{"name":"链接","slug":"链接","permalink":"https://brillianttt.gitee.io/tags/%E9%93%BE%E6%8E%A5/"}]},{"title":"markdown插入代码语言类型","slug":"markdown插入代码语言类型","date":"2020-03-27T03:20:21.000Z","updated":"2020-06-03T14:03:27.581Z","comments":true,"path":"2020/03/27/markdown插入代码语言类型/","link":"","permalink":"https://brillianttt.gitee.io/2020/03/27/markdown%E6%8F%92%E5%85%A5%E4%BB%A3%E7%A0%81%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"markdown插入代码语言类型 在使用markdown进行写文章时有时需要插入代码块，但是对于新手来说并不太清楚各种语言是怎样标记的，本文总结出来，如下：","categories":[{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/categories/markdown%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/tags/markdown%E8%AF%AD%E6%B3%95/"}]},{"title":"0号测试","slug":"今晚做一丢丢更新","date":"2020-03-26T13:50:33.000Z","updated":"2020-05-15T14:46:59.978Z","comments":true,"path":"2020/03/26/今晚做一丢丢更新/","link":"","permalink":"https://brillianttt.gitee.io/2020/03/26/%E4%BB%8A%E6%99%9A%E5%81%9A%E4%B8%80%E4%B8%A2%E4%B8%A2%E6%9B%B4%E6%96%B0/","excerpt":"","text":"可能会更改一下界面，以后经常更新设置，也经常记录学习的经历和经验。 123456#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;\"hello world\";&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://brillianttt.gitee.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"过生日","slug":"过生日","date":"2020-01-21T02:17:24.692Z","updated":"2020-01-21T02:25:31.946Z","comments":true,"path":"2020/01/21/过生日/","link":"","permalink":"https://brillianttt.gitee.io/2020/01/21/%E8%BF%87%E7%94%9F%E6%97%A5/","excerpt":"","text":"今天小马过十九岁生日了！今天似乎确凿是在世的6986天","categories":[],"tags":[]},{"title":"小马的2019年度总结","slug":"小马的2019年度总结","date":"2020-01-20T04:09:29.478Z","updated":"2020-05-26T10:05:41.907Z","comments":true,"path":"2020/01/20/小马的2019年度总结/","link":"","permalink":"https://brillianttt.gitee.io/2020/01/20/%E5%B0%8F%E9%A9%AC%E7%9A%842019%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","excerpt":"","text":"2019，注定是不平凡的一年，从年初还在班里埋头学习，到年末在大学广场里high歌， 这一年或者这几年的辛酸苦辣，仿佛都在今天 结束了。三年前，带着中考失利的辛酸来到了高中。从那年的暑假励志高考要弯道超车，要证明自己可以好好学习，也可以优秀，也不负张老师的希望。这三年，好像一直都没有融进8班或11班的大家庭，老实说，仿佛对大环境有着天然的排斥。现在看来，自己的想法是很愚蠢的，所有的路都是自己一步一步走过来的，结果自然也要自己接受。 高中三年，是痛苦并快乐着的，痛苦是因为开始适应环境，快乐是因为自己在慢慢成长。因为自己的凉薄和冷漠，也有年少无知的轻狂，在高二那年的夏天，经历了自己人生的一个低谷，两件事情，双重打击，很长一段时间都活在愧疚中。 快乐是因为自己的学习在不断的进步，印象很清楚，进入18中排名是248，高一第一次月考就考了32名，虽然自己在之后考试中都在1、2考场徘徊着，但那时我知道，自己很努力了，三四月做的事情，在八九月自有答案。没有见过凌晨四点的洛杉矶，但三年来天天见凌晨四点半的呼和浩特。在颓废和打鸡血的交织中，高中三年，终于在今年夏天落下了帷幕。大学嘛，时间如白驹过隙，一不小心就过了八分之一啦。凡此过往，皆为序章，辛辛苦苦 熬了三年，大学的生活，不正是当年梦寐以求的吗，希望自己像高中一样，记住自己的初心，好好努力，不负自己的芳华。 谢谢所有在我最痛苦最难受的时候给予我帮助的人，谢谢自己的家人，在高中三年给予了我最无微不至的照顾，谢谢小姐姐的暖心，也谢谢自己的好兄弟和好伙伴们，陪我一起度过了高中三年。所有快乐，所有争执，所有幸福，都化为生活的碎片，留存在记忆当中。","categories":[],"tags":[]}],"categories":[{"name":"博客开发","slug":"博客开发","permalink":"https://brillianttt.gitee.io/categories/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"数学","permalink":"https://brillianttt.gitee.io/categories/%E6%95%B0%E5%AD%A6/"},{"name":"算法","slug":"算法","permalink":"https://brillianttt.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/categories/markdown%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"QT","slug":"QT","permalink":"https://brillianttt.gitee.io/tags/QT/"},{"name":"学习","slug":"学习","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"BUG解决","slug":"BUG解决","permalink":"https://brillianttt.gitee.io/tags/BUG%E8%A7%A3%E5%86%B3/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://brillianttt.gitee.io/tags/OpenCV/"},{"name":"C/C++","slug":"C-C","permalink":"https://brillianttt.gitee.io/tags/C-C/"},{"name":"RSA","slug":"RSA","permalink":"https://brillianttt.gitee.io/tags/RSA/"},{"name":"仿射密码","slug":"仿射密码","permalink":"https://brillianttt.gitee.io/tags/%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81/"},{"name":"密码学","slug":"密码学","permalink":"https://brillianttt.gitee.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"照片","slug":"照片","permalink":"https://brillianttt.gitee.io/tags/%E7%85%A7%E7%89%87/"},{"name":"猫","slug":"猫","permalink":"https://brillianttt.gitee.io/tags/%E7%8C%AB/"},{"name":"Summer summary","slug":"Summer-summary","permalink":"https://brillianttt.gitee.io/tags/Summer-summary/"},{"name":"数学","slug":"数学","permalink":"https://brillianttt.gitee.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"暑假学习","slug":"暑假学习","permalink":"https://brillianttt.gitee.io/tags/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0/"},{"name":"0-1背包问题","slug":"0-1背包问题","permalink":"https://brillianttt.gitee.io/tags/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"学习总结","slug":"学习总结","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"bfs","slug":"bfs","permalink":"https://brillianttt.gitee.io/tags/bfs/"},{"name":"dfs","slug":"dfs","permalink":"https://brillianttt.gitee.io/tags/dfs/"},{"name":"链表","slug":"链表","permalink":"https://brillianttt.gitee.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"位运算","slug":"位运算","permalink":"https://brillianttt.gitee.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"笔记","slug":"笔记","permalink":"https://brillianttt.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"库函数的使用","slug":"库函数的使用","permalink":"https://brillianttt.gitee.io/tags/%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"name":"code::blocks","slug":"code-blocks","permalink":"https://brillianttt.gitee.io/tags/code-blocks/"},{"name":"STL","slug":"STL","permalink":"https://brillianttt.gitee.io/tags/STL/"},{"name":"动态规划","slug":"动态规划","permalink":"https://brillianttt.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"排序","slug":"排序","permalink":"https://brillianttt.gitee.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/tags/markdown%E8%AF%AD%E6%B3%95/"},{"name":"链接","slug":"链接","permalink":"https://brillianttt.gitee.io/tags/%E9%93%BE%E6%8E%A5/"},{"name":"测试","slug":"测试","permalink":"https://brillianttt.gitee.io/tags/%E6%B5%8B%E8%AF%95/"}]}