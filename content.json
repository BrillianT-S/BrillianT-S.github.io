{"meta":{"title":"马小跳的秘密基地","subtitle":"能受天磨真好汉 不遭人嫉是庸才","description":"博客,移动开发,blog","author":"马小跳","url":"https://brillianttt.gitee.io","root":"/"},"pages":[{"title":"tags","date":"2020-01-20T06:06:52.000Z","updated":"2020-01-20T06:10:10.726Z","comments":true,"path":"tags/index.html","permalink":"https://brillianttt.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-04-04T02:42:50.000Z","updated":"2020-04-04T02:42:26.313Z","comments":true,"path":"categories/index.html","permalink":"https://brillianttt.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-01-22T05:07:11.000Z","updated":"2020-01-22T05:08:27.240Z","comments":true,"path":"about/index.html","permalink":"https://brillianttt.gitee.io/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-01-22T05:10:19.000Z","updated":"2020-01-22T05:11:00.789Z","comments":true,"path":"contact/index.html","permalink":"https://brillianttt.gitee.io/contact/index.html","excerpt":"","text":""}],"posts":[{"title":"code::blocks设置调试和主题背景","slug":"codeblocks设置调试和主题背景 ","date":"2020-06-02T00:48:11.732Z","updated":"2020-06-02T01:27:21.974Z","comments":true,"path":"2020/06/02/codeblocks设置调试和主题背景 /","link":"","permalink":"https://brillianttt.gitee.io/2020/06/02/codeblocks%E8%AE%BE%E7%BD%AE%E8%B0%83%E8%AF%95%E5%92%8C%E4%B8%BB%E9%A2%98%E8%83%8C%E6%99%AF%20/","excerpt":"","text":"设置调试安装好Code::Block后完成编译和运行后却无法调试，弹出Error:You need to specify a debugger program in the debuggers’s settings.无法编译根据提示信息我们需要指定一个debugger program，根据提示我们可以知道指定的菜单栏settings。我们可以看到默认状态下路径是空的，那么我们就需要设置一个路径。 找到code::block的默认安装路径并进入CodeBlocks\\MinGW\\gdb32\\bin选择gdb32.exe。单击OK即可开始进行编译。 设置主题背景首先进入codeblocks官网找到color theme的代码。 紧接着在C盘中找到CodeBlocks/default.conf，注意default.conf文件不再你的安装文件夹下，而是在系统盘下，以win10系统为例，路径为：user/你的用户名/AppData/Roaming/CodeBlocks。 在进行下一步前，要确保codeblocks已经关闭。 下一步是通过记事本打开default.conf文件，把default.conf文件中的代码全部替换为第一步中在codeblocks官网上找到的代码，保存并关闭。注意在替default.conf文件代码时最好做好备份以免出错。 下一步就是感受快乐了！！！ 下下一步，如果想要改变其他风格可以在Settings/Editor/Syntax Highlighting/colour theme中选择想要的风格，也可以自定义各种颜色，还可以在margins and caret–&gt;caret的color中设置光标颜色。","categories":[],"tags":[{"name":"code::blocks","slug":"code-blocks","permalink":"https://brillianttt.gitee.io/tags/code-blocks/"},{"name":"笔记","slug":"笔记","permalink":"https://brillianttt.gitee.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"C++STL学习笔记","slug":"C++STL容器的学习","date":"2020-05-13T13:41:57.792Z","updated":"2020-05-29T09:19:26.023Z","comments":true,"path":"2020/05/13/C++STL容器的学习/","link":"","permalink":"https://brillianttt.gitee.io/2020/05/13/C++STL%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"最近开始学习c++的stl容器，下面记录一些学习的笔记。 STL（Standard Template Library）,中文名为标准模板库，其中封装了许多容器，而容器可以理解为能实现很多功能的东西。在写代码时可以快速调用他们，省去了自己书写完整的时间。 vector的常见用法vector本身可以作为数组使用，在元素不确定的场合可以很好的节省空间 vector的定义123456789101112131415#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; name; vector&lt;double&gt; name; vector&lt;char&gt; name; //如果类型名为vector，就为以下定义方式👇(可以理解为二维数组) vector&lt;vector&lt;int&gt;&gt; name; //vector数组的定义： vector&lt;typename&gt; Arrayname[arraySize]; //例如这样定义（这样其中的每一个都是一个vector容器）： vector nb[666]；&#125; vector的访问vector有两种访问方式：通过下标或者迭代器。下标访问即为以前学过的知识，迭代器访问为c++中新的概念，可以理解为类似指针的东西，可以如下定义： 123vector&lt;typename&gt;::iterator it;//这样就可以通过*it来访问vector里的元素//在循环中使用可以如下定义：for(vector&lt;typename&gt;::iterator it=name.begin();it!=name.end();it++)&#123;&#125; 但是这样写比较繁琐，我们可以使用auto关键字简化代码： 123aut o i=name.begin();//在循环中使用可以如下定义：for(auto it=name.begin();it!=name.end();i++)&#123;&#125; vector常用函数123456789101112vector&lt;int&gt; name;name.push_back(i)//push_back(i)在name的末尾添加元素i，常和循环连用以输入输出数据name.begin()//取name的首元素地址，和迭代器连用auto i=name.begin(),使得i指向这个地址name.end()//取name的尾地址，用法同上name.pop_back()//删除vector的尾元素name.size()//获得vector中元素的个数，返回unsigned类型，可以用%d输出name.clear()//清空vector中的所有元素name.insert(it，x)//用来向vector的任意迭代器it处插入一个元素x，例如：name.insert(name.begin()+2,-1);name.erase(it)//删除迭代器it处的元素name.erase(name.begin()+3)//注意删除的是name[4]name.erase(first,last)//删除[first,last)内的所有元素name.erase(name.first(),name.end())//效果同name.clear() set的常见用法set翻译为集合，是一个内部自动有序并且不含有重复元素的容器，在需要重复的时候，可以快捷的使用set实现自动排序（升序排列）并且去重。 set的定义12set&lt;typename&gt; name;//单独定义一个setset&lt;typename&gt; Arrayname[arraySize];//set数组的定义，Arrayname[0]~Arrayname[arraySize-1]中每一个都是一个set容器 set内元素的访问set只能同迭代器访问： 12set&lt;typename&gt;::iterator it;auto it=name.(); 由于除了vector和string之外的stl容器都不支持*(it+i)的访问方式，因此只能使用枚举法： 1234567891011121314#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main()&#123; set&lt;int&gt; nb; for(int i=10;i&gt;2;i--) &#123; nb.insert(i); &#125; for(auto i=nb.begin();i!=nb.end();i++)&#123; printf(\"%d \",*i); &#125; &#125;//输出 3 4 5 6 7 8 9 10（实现了自动从小到大排序） set常用函数 12345name.insert(x)//将x插入set容器中，并自动实现递增排序和去重name.find(value)//返回set中对应值为value的迭代器，如printf(\"%d\",*(name.find(2)));name.erase()//用法同vector中的函数一样，一般还可与name.find()连用，实现“找到并删除”name.size()//用来获得set内元素个数name.clear()//清空set内所有元素 string的常见用法 string对字符串常用的功能进行了封装，使得操作更方便。在使用string时需要添加string头文件即#include string的定义 定义string的方式和基本数据类型相同，可以直接定义 12string str;string str=\"abc\"; string内容的访问通过下标访问 1234string str=\"abcd\";for(int i=0;i&lt;str.length();i++)&#123; printf(\"%c\",str[i]);&#125;//输出结果为abcd 若要输入和输出整个字符串可用cin和cout还有c_str() 1234string str;cin&gt;&gt;str;cout&lt;&lt;str&lt;&lt;endl;printf(\"%s\",str.c_str());//将string型转化为字符数组输出 通过迭代器访问1234567string::iterator it;string str=\"abcd\";for(auto it=str.begin();it!=str.end();it++)&#123; printf(\"%c\",*it); printf(\"%c\",*(str.begin()+3));&#125; string常用函数拼接： 12string str1=\"abc\",str2=\"xyz\",str3;str3=str1+str2;//直接将str1和2拼接到str3上 比较： 1if(str1&gt;str2) printf(\"balabala\");//按照字典序比较 长度： 1printf(\"%d %d\",str.length(),str.size()); 插入元素： 1234567891011str.insert(3,str2);//str2插入str[3]位置str.insert(str.begin(+1),str2.begin(),str2.end());//name.insert(x,y,z)x为待插入位置，y、z分别为要插入字符串的首尾迭代器str.erase(it)//删除单个元素，it为需要删除的元素迭代器str.erase(first,last)；//first为需要删除的区间的起始迭代器，last为区间末尾迭代器的下一个地址，即为删除[first,last)str.erase(pos,length);//pos为开始删除的起始位置，length为删除字符个数str.clear();//清空string中的数据str.substr(pos,len)//返回从pos位开始，长度为len的子串str.find(str2)//当str2是str的子串时，返回其在str中第一次出现的位置(即str2第一个字符出现的位置)，若str2不是str的子串时返回string::nopsstring::npos//是一个常数，由于是unsigned_int类型，也可认为时ugsigned_int的最大值str.replace(pos,len,str2)//把str从pos位开始，长度为len的子串替换为str2str.replace(it1，it2，str2)//把str的迭代器[it1，it2)范围的子串替换为str2 map的常见用法map翻译为映射，是常用的stl容器之一。map可以将任何基本类型（包括stl容器）映射到任何类型（也包括stl容器）；在使用map的时候还要添加map头文件。在需要建立字符或字符串与整数之间映射的题目，使用map可以减少代码量；判断大整数或者其它类型的数据是否存在的题目，可以把map当bool使用。 map的定义123map&lt;typename1,typename2&gt;mp;//1、2分别代表映射前和映射后的类型，如果两种类型相同，就相当于普通的数组。map&lt;string,int&gt;mp;//若为字符串到整型的映射，必须使用string而不能用char。map&lt;set&lt;int&gt;,string&gt;mp;//将set容器映射到一个字符串 map容器内元素的访问通常有两种访问方式：通过下标和通过迭代器。 通过下标访问12345678910#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['c']=20; mp['c']=30; printf(\"%d\",mp['c']);&#125;//输出30 通过迭代器访问1map&lt;typename1,typename2&gt;::iterator it;//map迭代器的定义，同样可以用auto 因为map的每一个映射都有两个typename，所以访问方式略有不同，map可以使用it-&gt;first来访问第一个参数（键），it-&gt;second来访问第二个参数（值）。下面举个栗子。 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['m']=20; mp['b']=30; mp['y']=40; for(map&lt;char,int&gt;::iterator it=map.begin();it!=map.end();it++)//也可以写为auto it=begin() &#123; printf(\"%c %d\\n\",it-&gt;first,it-&gt;second); &#125;&#125;//输出如下： b 30 m 20 y 40 有没有发现map按“键”对它进行了从小到大的排序这是通过红黑树实现的（set也是），在建立映射的时候会自动实现从小到大的排序功能。（ps：我暂时也不知道红黑树是什么，等之后学到了回来补充。） map常用函数find()函数123456789101112#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['a']=1; mp['b']=2; mp['c']=3; auto i=mp.find('b');//find(key)返回键为key的映射的迭代器 printf(\"%c %d\",it-&gt;first,it-&gt;second);//输出b 2&#125; erase()erase()有两种用法：删除单个元素和删除一个区间内的所有元素 删除单个元素12345678910111213#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['a']=1; mp['b']=2; mp['c']=3; auto it=mp.find('b');//find(key)返回键为key的映射的迭代器 mp.erase(it)l//删除b 2 mp.erase(key)//key为想要删除的映射的键，如mp.erase('a');&#125; 删除多个元素（区间内）mp.erase(first,last)//first为需要删除的区间的起始迭代器，last为需要删除的区间的末尾迭代器的下一个地址，即为删除左闭右开的区间[first,last),举例如下： 123456789101112#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['a']=1; mp['b']=2; mp['c']=3; auto it=mp.find('b');//find(key)返回键为key的映射的迭代器 mp.erase(it，mp.end())；//删除it后的所有映射，即b 2和c 3&#125; 其他函数size()用来获得map中映射的对数。clear()用来情况map中的所有元素。 quese的常见用法quese翻译为队列，在STL中主要是实现先进先出的容器，就像放东西一样，所有物品放在一起，从下往上垒起来；而取东西的时候也一样，想要取下面东西的时候，需要把上面的先拿开，才能取到下面的东西。在实现广度优先搜索时，可以不宜不用自己动手实现一个队列，而是用queue作为代替，以提高程序的准确性。 queue的定义要使用queue，需要先添加头文件#include，并且在头文件下面加上 using namespace std才可以。定义写法和其他容器一样，typename可以说任意基本数据类型或容器。 1queue&lt;typename&gt;name; queue容器内元素的访问由于queue（队列）本就是一种先进先出的限制性数据结构，因此再stl中只能通过front（）来访问队首元素，或是通过back（）来访问队尾元素。举例如下： 12345678910111213#include&lt;stdio.h&gt;#include&lt;queue&gt;using namespace std;int main()&#123; queue&lt;int&gt; q; for(int i=1;i&lt;=5;i++) &#123; q.push(i);//push(i)用以将i压入队列，因此一次入队1 2 3 4 5 &#125; printf(\"%d %d\",q.front(),q.back());//输出1 5 return 0;&#125; queue常用函数12345678910111213#include&lt;stdio.h&gt;#include&lt;queue&gt;using namespace std;int main()&#123; queue&lt;int&gt; q; q.push()//将x压入队列 q.front()//获得队首元素 q.back()//获得队尾元素 q.pop()//令队首元素出队 q.empty()//检测queue是否为空，返回true则空，false则非空 q.size()//返回queue内元素的个数&#125; 特别注意，在使用front()和pop()函数前，必须用empty()判断队列是否为空，否则可能因为队空而出现错误。 priority_queue的常见用法priority_queue又称优先队列，其底层逻辑是用堆来实现的（我也不知道堆是啥，学了回来填坑）。在优先队列中，队首元素一定是当前队列中优先级最高的那个。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://brillianttt.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"STL","slug":"STL","permalink":"https://brillianttt.gitee.io/tags/STL/"}]},{"title":"博客的音乐功能设置","slug":"博客的音乐功能设置","date":"2020-04-05T13:12:43.670Z","updated":"2020-04-05T13:20:40.777Z","comments":true,"path":"2020/04/05/博客的音乐功能设置/","link":"","permalink":"https://brillianttt.gitee.io/2020/04/05/%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%9F%B3%E4%B9%90%E5%8A%9F%E8%83%BD%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"今天刚开始设置博客的音乐组件，留下一点小笔记备用😁首先，音乐的获取可以通过这两个方式：1、可以在网易云音乐上直接搜索喜欢的歌曲，找到外部链接2、自己创建网易云歌单，添加喜欢的歌曲，再找到自己歌单的外部链接之后再主题在文件夹下搜索music，找到music.ejs文件,在其中将”iframe”处替换成刚找到链接。最后将主题的yml文件中的#music部分做修改，更改http链接与音乐id就大功告成啦！(ps：在代码中修改各项参数可以更改音乐播放器的大小，将宽度和高度改为0或1可以隐藏音乐播放器，做到完完全全的“背景音乐”)","categories":[{"name":"博客开发","slug":"博客开发","permalink":"https://brillianttt.gitee.io/categories/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"动态规划之最长上升子序列","slug":"动态规划之最长上升子序列","date":"2020-04-05T11:30:22.000Z","updated":"2020-05-26T14:18:12.190Z","comments":true,"path":"2020/04/05/动态规划之最长上升子序列/","link":"","permalink":"https://brillianttt.gitee.io/2020/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"动态规划 动态规划指的是将一个繁杂的问题分解成子问题之后，通过求解子问题的最优解，从而求得整体最优解。 最长上升子序列问题如下：输入数据： 输入的第一行是序列的长度N(1&lt;=N&lt;=1000),第一行给出序列的N个整数，这些整数的取值范围在0-10000. 输出要求： 最长上升子序列的长度。 输入样例： 71 7 3 5 9 4 8 输出样例： 4 范例代码： 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int maxlen[100]; int s[100]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s[i]; maxlen[i] = 1; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (s[i] &gt; s[j]) &#123; maxlen[i] = max(maxlen[i], maxlen[j] + 1); &#125; &#125; &#125; cout &lt;&lt; *max_element(maxlen + 1, maxlen + n + 1);&#125; 讲解： 123456789int n; cin &gt;&gt; n; int maxlen[100]; int s[100]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s[i]; maxlen[i] = 1; &#125; 这一部分是输入数据，并且让存储 以当前下标为终点的子序列的个数 的maxlen数组都初始化为1. 12345678910for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (s[i] &gt; s[j]) &#123; maxlen[i] = max(maxlen[i], maxlen[j] + 1); &#125; &#125; &#125; 这一部分是正式求解&ensp;以当前下标为终点的最长上升子序列&ensp;的长度，并且分别存储在maxlen数组内。i每往后循环一次，j就要将i之前的数据都循环一遍。当s[i]&gt;s[j]时就要求maxlen[j]+1与maxlen[i]之间的最大值进行maxlen[i]的更新。注：之所以需要每次都求maxlen[i]和maxlen[j]+1的最大值，而不直接将maxlen[j]+1赋值给maxlen[i]，是因为maxlen[i]之前的更新可能已经使maxlen[i]&gt;maxlen[[j]+1，故 此时maxlen[i]应保持不变。 最后一部分为输出部分，调用max_element函数输出manlen数组内的最大值。 注：max_element函数返回值是一个指针&emsp;&emsp;max_element和max函数需要调用头文件algorithm","categories":[{"name":"算法","slug":"算法","permalink":"https://brillianttt.gitee.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://brillianttt.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"排序算法","slug":"排序算法","date":"2020-04-03T02:19:36.000Z","updated":"2020-05-26T14:25:24.811Z","comments":true,"path":"2020/04/03/排序算法/","link":"","permalink":"https://brillianttt.gitee.io/2020/04/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt; using namespace std; void merge(int a[], int s, int m, int e, int tmp[])&#123; int pb = 0; int p1 = s, p2 = m+1; while (p1&lt;=m&amp;&amp;p2&lt;=e) &#123; if (a[p1] &gt; a[p2]) tmp[pb++] = a[p2++]; else tmp[pb++] = a[p1++]; &#125; while (p1&lt;=m) &#123; tmp[pb++] = a[p1++]; &#125; while (p2&lt;=e) &#123; tmp[pb++] = a[p2++]; &#125; for (int j = 0; j &lt;= e-s; ++j) &#123; a[s+j] = tmp[j]; &#125;&#125;void mergesort(int a[], int s, int e, int tmp[])&#123; if (s &lt; e) &#123; int m = s + (e - s) / 2; mergesort(a, s, m, tmp); mergesort(a, m + 1, e, tmp); merge(a, s, m, e, tmp); &#125;&#125;int a[9] = &#123; 1,2,3,6,5,4,7,8,9 &#125;;int b[9];int main()&#123; mergesort(a, 0, 8, b); for (int i = 0; i &lt; 9; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; return 0;&#125; 快速排序123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt; using namespace std;void quicksort(int a[], int s, int e) &#123; if (s &gt;= e) return; int k = a[s]; int i = s, j = e; while (i!=j) &#123; while (j &gt; i&amp;&amp;a[j] &gt;= k)--j; swap(a[i], a[j]); while (i &lt; j&amp;&amp;a[i] &lt;= k)++i; swap(a[i], a[j]); &#125; quicksort(a, s, i - 1); quicksort(a, i + 1, e);&#125;int main() &#123; int n; cin &gt;&gt; n; int a[100]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; quicksort(a, 0, n-1); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://brillianttt.gitee.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://brillianttt.gitee.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"markdown语法的使用教程","slug":"markdown语法的使用教程","date":"2020-03-28T02:22:46.000Z","updated":"2020-05-26T14:18:39.267Z","comments":true,"path":"2020/03/28/markdown语法的使用教程/","link":"","permalink":"https://brillianttt.gitee.io/2020/03/28/markdown%E8%AF%AD%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"这是一个关于markdown语法的链接这是关于markdown插入链接的语法的链接","categories":[{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/categories/markdown%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/tags/markdown%E8%AF%AD%E6%B3%95/"}]},{"title":"markdown插入代码语言类型","slug":"markdown插入代码语言类型","date":"2020-03-27T03:20:21.000Z","updated":"2020-05-15T14:26:38.410Z","comments":true,"path":"2020/03/27/markdown插入代码语言类型/","link":"","permalink":"https://brillianttt.gitee.io/2020/03/27/markdown%E6%8F%92%E5%85%A5%E4%BB%A3%E7%A0%81%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"markdown插入代码语言类型 在使用markdown进行写文章时有时需要插入代码块，但是对于新手来说并不太清楚各种语言是怎样标记的，本文总结出来，如下：","categories":[{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/categories/markdown%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/tags/markdown%E8%AF%AD%E6%B3%95/"}]},{"title":"0号测试","slug":"今晚做一丢丢更新","date":"2020-03-26T13:50:33.000Z","updated":"2020-05-15T14:46:59.978Z","comments":true,"path":"2020/03/26/今晚做一丢丢更新/","link":"","permalink":"https://brillianttt.gitee.io/2020/03/26/%E4%BB%8A%E6%99%9A%E5%81%9A%E4%B8%80%E4%B8%A2%E4%B8%A2%E6%9B%B4%E6%96%B0/","excerpt":"","text":"可能会更改一下界面，以后经常更新设置，也经常记录学习的经历和经验。 123456#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;\"hello world\";&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://brillianttt.gitee.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"过生日","slug":"过生日","date":"2020-01-21T02:17:24.692Z","updated":"2020-01-21T02:25:31.946Z","comments":true,"path":"2020/01/21/过生日/","link":"","permalink":"https://brillianttt.gitee.io/2020/01/21/%E8%BF%87%E7%94%9F%E6%97%A5/","excerpt":"","text":"今天小马过十九岁生日了！今天似乎确凿是在世的6986天","categories":[],"tags":[]},{"title":"小马的2019年度总结","slug":"小马的2019年度总结","date":"2020-01-20T04:09:29.478Z","updated":"2020-05-26T10:05:41.907Z","comments":true,"path":"2020/01/20/小马的2019年度总结/","link":"","permalink":"https://brillianttt.gitee.io/2020/01/20/%E5%B0%8F%E9%A9%AC%E7%9A%842019%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","excerpt":"","text":"2019，注定是不平凡的一年，从年初还在班里埋头学习，到年末在大学广场里high歌， 这一年或者这几年的辛酸苦辣，仿佛都在今天 结束了。三年前，带着中考失利的辛酸来到了高中。从那年的暑假励志高考要弯道超车，要证明自己可以好好学习，也可以优秀，也不负张老师的希望。这三年，好像一直都没有融进8班或11班的大家庭，老实说，仿佛对大环境有着天然的排斥。现在看来，自己的想法是很愚蠢的，所有的路都是自己一步一步走过来的，结果自然也要自己接受。 高中三年，是痛苦并快乐着的，痛苦是因为开始适应环境，快乐是因为自己在慢慢成长。因为自己的凉薄和冷漠，也有年少无知的轻狂，在高二那年的夏天，经历了自己人生的一个低谷，两件事情，双重打击，很长一段时间都活在愧疚中。 快乐是因为自己的学习在不断的进步，印象很清楚，进入18中排名是248，高一第一次月考就考了32名，虽然自己在之后考试中都在1、2考场徘徊着，但那时我知道，自己很努力了，三四月做的事情，在八九月自有答案。没有见过凌晨四点的洛杉矶，但三年来天天见凌晨四点半的呼和浩特。在颓废和打鸡血的交织中，高中三年，终于在今年夏天落下了帷幕。大学嘛，时间如白驹过隙，一不小心就过了八分之一啦。凡此过往，皆为序章，辛辛苦苦 熬了三年，大学的生活，不正是当年梦寐以求的吗，希望自己像高中一样，记住自己的初心，好好努力，不负自己的芳华。 谢谢所有在我最痛苦最难受的时候给予我帮助的人，谢谢自己的家人，在高中三年给予了我最无微不至的照顾，谢谢小姐姐的暖心，也谢谢自己的好兄弟和好伙伴们，陪我一起度过了高中三年。所有快乐，所有争执，所有幸福，都化为生活的碎片，留存在记忆当中。","categories":[],"tags":[]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"博客开发","slug":"博客开发","permalink":"https://brillianttt.gitee.io/categories/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91/"},{"name":"算法","slug":"算法","permalink":"https://brillianttt.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/categories/markdown%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"code::blocks","slug":"code-blocks","permalink":"https://brillianttt.gitee.io/tags/code-blocks/"},{"name":"笔记","slug":"笔记","permalink":"https://brillianttt.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"STL","slug":"STL","permalink":"https://brillianttt.gitee.io/tags/STL/"},{"name":"学习","slug":"学习","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"动态规划","slug":"动态规划","permalink":"https://brillianttt.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"排序","slug":"排序","permalink":"https://brillianttt.gitee.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/tags/markdown%E8%AF%AD%E6%B3%95/"},{"name":"测试","slug":"测试","permalink":"https://brillianttt.gitee.io/tags/%E6%B5%8B%E8%AF%95/"}]}