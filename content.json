{"meta":{"title":"马小跳的秘密基地","subtitle":"能受天磨真好汉 不遭人嫉是庸才","description":"博客,移动开发,blog","author":"马小跳","url":"https://brillianttt.gitee.io","root":"/"},"pages":[{"title":"about","date":"2020-01-22T05:07:11.000Z","updated":"2020-01-22T05:08:27.240Z","comments":true,"path":"about/index.html","permalink":"https://brillianttt.gitee.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-04-04T02:42:50.000Z","updated":"2020-04-04T02:42:26.313Z","comments":true,"path":"categories/index.html","permalink":"https://brillianttt.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-01-22T05:10:19.000Z","updated":"2020-01-22T05:11:00.789Z","comments":true,"path":"contact/index.html","permalink":"https://brillianttt.gitee.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-20T06:06:52.000Z","updated":"2020-01-20T06:10:10.726Z","comments":true,"path":"tags/index.html","permalink":"https://brillianttt.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java学习","slug":"Java学习","date":"2021-04-10T15:15:20.000Z","updated":"2021-04-10T15:15:33.972Z","comments":true,"path":"2021/04/10/Java学习/","link":"","permalink":"https://brillianttt.gitee.io/2021/04/10/Java%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041package com.company;import java.util.Scanner;import java.util. *;public class Main &#123; public static class a&#123; //定义一个类模拟c语言中的结构体，在上一行行中不加static会报错，但不知道原因 private double nianxi; private double jieyu; public a()&#123; this.nianxi=0; this.jieyu=0; &#125; &#125; public static void main(String[] args) &#123; // write your code here a[] x; x=new a[20]; for(int i=0;i&lt;20;i++)&#123; //x[i]=new a(); x[i]=new a(); x[i].jieyu=0; x[i].nianxi=0; &#125; double money=10000,rate=0.065/12,sum,lixi; for (int i=1;i&lt;=10;i++)&#123;//外层循环十次，表示经过十年 for (int j=1;j&lt;=12;j++)&#123;//内层循环12次，表示经过一年时间 x[i].nianxi+=money*rate;//年利息 money+=money*rate; //System.out.println(money+\"\\n\"); &#125; x[i].jieyu+=money;//每年年末的结余加到x这个对象数组中 //System.out.println(x[i].jieyu+\"\\n\"); &#125; for(int i=1;i&lt;=10;i++)&#123; System.out.println(\"第\"+i+\"年的利息为\"+x[i].nianxi+\",\"+\"结余为\"+x[i].jieyu+\"\\n\"); &#125; &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"学习深度学习","slug":"学习深度学习","date":"2021-04-10T15:15:20.000Z","updated":"2021-04-13T16:52:43.154Z","comments":true,"path":"2021/04/10/学习深度学习/","link":"","permalink":"https://brillianttt.gitee.io/2021/04/10/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"知网关于深度学习的论文整理《基于深度学习的汉字识别方法研究综述》传统汉字识别方法 图像预处理：在图像分析中 ，获取的图像质量的高低会极大地影响识别的精度。预处理一般包括了灰度化、直方图均衡化 、倾斜检测与校正 、行与字切分等操作方法。 文本版面分析：通常对版面处理分为版面分析、版面理解和版面重构。主要从印刷版面的结构来分析 ，根据连通域大小或像素点分布等特征 ，将属性标记出来。然后是版面理解，根据版面分析时记载的连通域位置信息，确定连通域归属的序列 ，最后进行版面重构复原 。 字符切割：将汉字信息进行逐行切割 ，再对逐行信息进行逐字切割。 归一化处理：更加准确地进行后续字符识别。 特征提取：得到每个字符的特征描述。 字符的单字识别：依据每一个字符的特点进行预分类 ，产生候选字符集 ，再从候选字符集鉴别出待定字符。 纠错处理：通过上下文关系来对识别的结果进行纠错处理。 输出识别结果。 基于深度学习的汉字识别方法目前基于深度学习的文字识别主要有两种方案 ，即文字检测加汉字识别的方法 ，分两步依次进行。而另一种则是直接训练一个端到端的模型同时完成文字检测和文字识别。 经典目标检测算法在介绍汉字识别算法之前,首先引入几种在目标检测领域应用非常广泛的经典模型,目前主流的文字识别算法大多基于这些优化改进而来。FCNN network是由美国加州大学伯克利分校的Long 等人于2015年8月在CVPR上提出的一种图像分割的算法,主要结构如图所示： 该算法首次将端到端的卷积网络推广到语义分割的任务中 ，提出了完全卷积网络的概念，可以接受任意尺寸的输入图像，用反卷积层来上采样最后卷积层的feature map，可以恢复原图像的大小并完成对每个像素的预测 ，同时保留原图像的空间信息。 文字检测识别算法文字识别端到端的场景汉字识别研究前景与应用​ 如何提高汉字的识别率仍是目前的研究热点，现有的汉字识别还只对背景简单的印刷体文字取得较好的效果,比如名片识别、证件识别等。但对于一些复杂的场景,如自然场景图片中光照、文字的大小、样式使得汉字识别处理问题极具挑战性,现有的技术还远远没有达到令人满意的程度。​ 当前汉字识别技术的应用领域很广泛”,特别是在无人车、智慧医疗、自动化办公、金融欺诈检测、恐怖主义威胁级别检测等领域发挥着举足轻重的作用。例如用OCR进行文稿的识别录入,虽然国内外市场中已有很多这样的产品,但这类技术依然不算成熟,有表格、图形的文档常常需要手工干预。对图形、文本等混排的复杂版面进行自动切分的汉字识别系统也是目前研究的重点之一,特别是应用在对出版刊物的识别上,方便人们快速进行信息录入。还有对卡证文字的识别,如对身份证、银行卡、名片等识别,分别应用于用户注册、银行开户、交通出行等多种场景中。​ 汉字识别系统还可广泛应用于政府、税务、医疗、金融等各行业的各种表格数据的输入和处理,这些领域常常需要统计大量的人员数据信息,有些还是手写完成的。自动文字识别,信息录入将极大地提高工作效率。 名词解释卷积神经网络卷积神经网络（Convolutional Neural Networks, CNN）是一类包含卷积计算且具有深度结构的前馈神经网络（Feedforward Neural Networks），是深度学习（deep learning）的代表算法之一 。卷积神经网络具有表征学习（representation learning）能力，能够按其阶层结构对输入信息进行平移不变分类（shift-invariant classification），因此也被称为“平移不变人工神经网络（Shift-Invariant Artificial Neural Networks, SIANN）” 语义分割神经网络中“端到端”思想​ 深度学习的一个重要思想就是“端到端”的学习方式，属表示学习的一种。这是深度学习区别于其他机器学习算法的最重要的一个方面。其他机器学习算法，如特征选择算法、分类器算法、集成学习算法等，均假设样本特征是给定的，并在此基础上设计具体的机器学习算法，在深度学习时代之前，样本表示基本都使用人工特征，人工特征的优劣往往在很大程度上决定了最终的任务精度​ 端到端的学习方式就是在整个学习流程中并不进行人为的子问题划分，而是完全交给深度学习模型直接学得从原始输入到期望输出的映射。相比分治策略，“端到端”的学习方式具有协同增效的优势，有更大可能获得全局最优解。​ 对于深度模型，其输入数据是未经任何人为加工的原始样本形式，后续则是堆叠在输入层上的众多操作层。这些操作层整体可被看做一个复杂的函数Fcnn，最终损失函数由数据损失和模型参数的正则化损失共同组成，深度模型的训练则在最终损失驱动下对模型进行参数更新，并将误差反向传播至网络各层。模型的训练过程可以简单抽象为从原始数据向最终目标的直接“拟合”，而中间的这些部件正起到了将原始数据映射为特征(即特征学习)，随后再映射为样本标记(即目标任务，如分类)的作用。下面是组成Fcnn的各个基本部件。","categories":[{"name":"学习","slug":"学习","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习 - 深度学习","slug":"学习-深度学习","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"高考招生考试报自动识别与格式化软件","slug":"高考招生考试报自动识别与格式化软件","date":"2021-04-09T08:29:55.000Z","updated":"2021-04-10T15:15:32.443Z","comments":true,"path":"2021/04/09/高考招生考试报自动识别与格式化软件/","link":"","permalink":"https://brillianttt.gitee.io/2021/04/09/%E9%AB%98%E8%80%83%E6%8B%9B%E7%94%9F%E8%80%83%E8%AF%95%E6%8A%A5%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"界面样式初步计划应有一下内容： 左上角地软件名称与软件界面的主体部分标识软件名称 待识别文件夹路径的选择按钮、待导出文件夹路径的选择按钮 （目前待处理的图片与已经提出去文字的图片效果的展示框——可视化界面） （已导出招生学校的各类信息输出——可视化界面）","categories":[{"name":"项目","slug":"项目","permalink":"https://brillianttt.gitee.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://brillianttt.gitee.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"写给学弟学妹的碎碎念","slug":"写给学弟学妹们的一封信","date":"2021-03-19T14:18:50.000Z","updated":"2021-03-20T11:11:50.747Z","comments":true,"path":"2021/03/19/写给学弟学妹们的一封信/","link":"","permalink":"https://brillianttt.gitee.io/2021/03/19/%E5%86%99%E7%BB%99%E5%AD%A6%E5%BC%9F%E5%AD%A6%E5%A6%B9%E4%BB%AC%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/","excerpt":"","text":"亲爱的学弟学妹们你们好： ​ 我叫马博宇，是宋老师带的上一届高中班级里的一名学生。十分荣幸能被宋老师邀请，和大家分享我在大学的生活。 ​ 先进行一个简短的自我介绍，我在四川的西南科技大学上学，大二计算机专业，高考理科538分，这个是当时学校里的展板展示的成绩： 简短介绍完毕，下面给大家分享一下美滋滋的大学生活😁 大学生的日常日常交往​ 去外地上学的好处是可以去逛学校所在城市的各种景点和商业街。虽然我所在的城市是绵阳，但是离成都很近，在节假日的时候经常可以来一场说走就走的旅行，去成都或者重庆耍耍。另一方面，在外地上学还可以认识许许多多不同地方的朋友。虽然我在四川上学，但是周围的同学们有相当一部分都是外地的同学，就比如我的舍友，有湖南长沙的，辽宁沈阳的、还有一个是四川达州的同学。五湖四海的朋友聚在一起，每天都有聊不完的话题，虽然我在大学还没怎么出去玩过，但是在他们的描述下，我总是忍不住想在下一个五一假期中，去他们家乡玩一玩。 ​ 在大学里，除了日常和同学的交往，耍个朋友（四川方言，内蒙话译为找个对象）也是很常见的啦，我。。。历经五年单身，终于也有幸在前几天脱单了。在大学里每天不会像高中一样，情侣们见到老师要躲着走，拉手手也要悄咪咪的，因为在大学中，恋爱应该也算是一门“必修课”，在自爱的同时学会去爱别人，和自己的那个ta共同走过大学四年生活是一件非常美好的事情💓 日常生活​ 在大学中，不会再有老师和家长督促我们的学习（真的，但是不学就会挂科，挂科就得重修），8课程也不会像高中一样设置的十分紧密（还是看学习的专业），在没课的时候可以睡到日上三竿（也是看学习的专业）。 ​ 大学里最常见的场景是什么呢，早晨八点上课，七点四十才起床，十分钟洗漱，剩下的十分钟先奔向食堂买早饭，再冲向教室准备上课。中午下课了大家一窝蜂的冲向食堂或者校外干饭，这个应该是每一个大学都会出现的经典场面了。 ​ 除此之外，每个大学中会有各种各样的社团和部门，也可以担任班委，我之前加入了我们学校的志愿服务团队，并且担任了班级的学习委员。平时，同学们在日常的学习之余可以经常参加社团和部门开展的/各种活动。就拿我自己做过的一些活动举几个栗子： 学校的青年志愿者协会和绵阳市志愿者联合开展的大型活动科博会志愿者： 还有幸近距离见到了李兰娟、董明珠、曹德旺、鲁健等一众大佬： 学校的冬树刷白活动： 四川省高水平足球赛志愿者： 绵阳科技馆讲解活动： “科技进青义”支教活动： 还有学院组织的篮球班赛： 日常学习​ 大学的学习不同于初高中，从学习内容来看，高中三年，只需学习九门课程，到了高二高三时候，就只剩下六门了；而大学四年需要学习共近百门基础课、公共课和专业课。从学习深度来看，高中虽然只有六门主要课程，但在高中时期需要对这六门课程的所有基础知识做到融汇贯通，这样才能达到高考考查的基本要求。从学习动力上看，高中时候大家会受到全方位的鼓舞，来自父母、老师、朋友、学长学姐甚至是许多陌生人的鼓励，而自己不仅为了来自亲朋好友的殷切期望，更为了自己高考考一个好成绩去上个好大学而不懈努力。在大学里就很少会有其他人的“唠叨”了，除了“挂科警告”之外可能很少会有其他事情逼着自己学习，所以在大学中的学习，更多的还是依靠自己的坚持不懈，靠目标驱动，为实现什么样的人生目标而去不懈努力。 ​ 在我大学一年多的时间里，通过认真的学习，考过了英语四六级，专业排名年级前20%，在去年六月通过了转专业面试，从电子信息工程专业转到了现在的计算机专业，学习我十分感兴趣的编程。目前在计算机学院的机器视觉实验室学习图像处理和文字识别方面的知识。 好的大学“好”在了哪里​ 这个问题在另一个视频中，你们的张帅学长对这个问题进行了很具体的描述，我在他的基础上举一个更加现实的栗子~ ​ 就拿我的学校西南科大和内大来作比较，我们学校是一所”双非“院校，内大是”211“。我和张帅两个人高考差了27分，同样是计算机专业，体现在学校的选择上的差距是十分明显的。对于大家最关心的”保研“名额，我所在的学院保研名额数量是全校较高的，每一百个同学，保研名额大概有3-5个，而内大其他专业的保研率为5%左右，像计算机专业这类热门专业，保研率在40%左右，内大基地班则能达到50%以上。在经费上，实验室拨的经费较少，大部分实验室的收入来源都是在外面的公司和企业接项目，同学们来做，而211学校对实验室的支持更大，会给予大量的经费用作实验室的发展。在奖学金上，除去国家和学校本身设置的几种奖学金，211学校会比普通双非一本得到更多的社会支持，会有更多的来自社会企业对优秀学生发展的支持，其中就包含了奖学金这一项。在大学中，学习好拿奖学金拿到手软不是一件开玩笑的事情。 ​ 上面说到的是几个具体的例子，实际上，211或985学校比其他本科优秀的地方远不止这些，更优秀的老师和同学、更好的学习和科研氛围、更加宽广的就业前景、还有更大的平台……这些普通学校所没有的或缺乏的东西，带给学生的好处和光环会让学生一生受用。 写在最后​ 宋老师让我们录视频的目的是激励大家摆脱现在的习气，以更加精神饱满的劲头，去面对还有一年多就要到来的高考。我没有很好的方式给大家鼓励，就给大家看一个我当时在高考成绩出来以后发的一个知乎吧，希望在一年多以后的高考，大家也能对自己的亲朋好友骄傲的说：我没有辜负我的高中三年，我用自己的努力和汗水，换来了我终身为之骄傲的好成绩！ 送给大家一句我很喜欢的话：乾坤未定，你我都是黑马。 这句话一直激励我在高三繁重的学业中前进，最终取得了很好的成绩，现在送给你们，也祝愿学弟学妹们能找到自己的发力点，在高中的最后一年里，听老师的话，做最充足的准备，去迎接高考😉 写在最后的最后​ 我的qq:2363255644大家如果有学习上的困扰，或者希望能再打打鸡血，可以在忙碌的一周中抽出周末空闲的时候找我聊天，我很愿意为大家提供力所能及的帮助。 ​ 再给大家分享一点日常照片（请不要care直男拍照~） ​ 毕业典礼时候拍的！！！真心感谢宋老师、魏老师还有其他各科老师在高中时候为我提供了无数的帮助，一遍又一遍的为我答疑解惑，真心感谢您们💓 再来张和魏老师拍的！ 再来长和张老师拍的😋(张老师不仅是良师益友，还是我的顶头上司，我高中是物理课代表hhhhh) 还有最好的朋友！最棒最优秀最努力最上进的张帅长大学士！！！ 再分享一张我们毕业以后一起玩耍的皂片 都是非常优秀非常上进的小伙伴呀~ ​ 谢谢大家看完~ 祝福你们！ ​ 你们的小学长 ​ 2021.3.19","categories":[{"name":"随笔","slug":"随笔","permalink":"https://brillianttt.gitee.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://brillianttt.gitee.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"QT的学习","slug":"QT的学习","date":"2021-03-09T03:22:40.000Z","updated":"2021-03-13T09:13:17.138Z","comments":true,"path":"2021/03/09/QT的学习/","link":"","permalink":"https://brillianttt.gitee.io/2021/03/09/QT%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"第零个QT程序下载安装配置好qt后，打开qt Creator，点击左上角的文件-&gt;新建文件或项目-&gt;QT Widgets Application，然后设置好文件名称，名称中不可以有中文出现，创建路径中也不可以出现中文，然后点击下一步，选择qmake，再下一步设置细节： 在Base class中可以选择QMainWindow，QWidget和QDialog三个类，默认创建窗口类；其中QWidget是另外两个类的基类，QMainWindow可以使用设计、debug等功能，QDialog是以对话框的形式展现出来界面。 下面的Generate form创建界面可以勾选，选上以后可以通过拖拽一些工具便捷的设计界面。 再次点击下一步，勾选Select all kits，并再次点击下一步。 在这一步中会出现一个”添加版本控制系统“，这个一般用在开发一些大型软件时用到，可以选用vss、svn、git等版本控制系统。 点击完成，结束创建。 于是我们得到了最开始的项目形态： 下面是main.cpp代码的具体介绍 1234567891011121314#include \"widget.h\"#include &lt;QApplication&gt;//包含一个应用程序类的头文件//main程序入口 argc命令行变量的数量 argv命令行变量的数组int main(int argc, char *argv[])&#123; //a为应用程序对象，在qt中，应用程序对象有且只有一个 QApplication a(argc, argv); //窗口对象 myWidget父类-&gt;QWidget Widget w; //窗口对象，默认不会显示，必须调用show方法显示窗口 w.show(); //让程序对象进入消息循环，如同c程序中的system(\"pause\")使得窗口不会一闪而过一样，代码阻塞到当前行 return a.exec();&#125; 对qt文件的认识一些常用快捷键12345678910111213//命名规范：//类名首字母大写，单词和单词之间首字母大写//函数名、变量名称首字母小写//快捷键：//注释： ctrl+///运行： ctrl+r//编译： ctrl+b//查找： ctrl+f//整行移动： ctrl+shift+↑或者↓//帮助文档: F1或者单独打开帮助文档：D:\\AppProgram\\qt\\qt5.12.5\\5.12.5\\mingw73_64\\bin assistant.exe//自动对齐： ctrl+i//同名的.h和.cpp切换： F4 对.pro文件的认识.pro文件为项目的工程文件，pro是project的缩写，下面是.pro文件的基本代码及注释： 123456789101112131415161718192021222324252627282930313233QT += core gui //qt包含的模块 gui模块是qt的基本模块之一，后文有图会大致介绍greaterThan(QT_MAJOR_VERSION, 4): QT += widgets//大于4版本以上 包含widget模块CONFIG += c++11//在qt中的注释是以#开头的，而不是//# The following define makes your compiler emit warnings if you use# any Qt feature that has been marked deprecated (the exact warnings# depend on your compiler). Please consult the documentation of the# deprecated API in order to know how to port your code away from it.DEFINES += QT_DEPRECATED_WARNINGS# You can also make your code fail to compile if it uses deprecated APIs.# In order to do so, uncomment the following line.# You can also select to disable deprecated APIs only up to a certain version of Qt.#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 # disables all the APIs deprecated before Qt 6.0.0SOURCES += \\ main.cpp \\ //源文件 widget.cppHEADERS += \\ //头文件 widget.hFORMS += \\ widget.uiTARGET = 01_firstPROJET //生成的.exe文件的名称,修改名称直接可以在这里修改 下面有单独运行.exe文件的方法TEMPLATE = app //模板 应用程序模板 全称为Application# Default rules for deployment.qnx: target.path = /tmp/$$&#123;TARGET&#125;/binelse: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin!isEmpty(target.path): INSTALLS += target qt的主要模块 最近主要学习widgets、core和gui模块。 单独运行.exe文件的方法在编译运行后，在qt界面选择工程文件，右键选择在Explorer中显示，打开项目的文件夹位置，然后回退找到build-untitled7-Desktop_Qt_5_12_5_MinGW_64_bit-Release这个文件（这里是以release版本编译的，debug版本暂时没有试过），然后点击选择release文件找到.exe文件，双击打开。 ​ 然后！就会发现大概率打不开（第一次用这个方法的时候），继而通过搜索引擎解决各种问题，其中有移动libstdc++-6.dll文件、移动libgcc_s_seh-1.dll文件以及配置系统变量等方法，但在我的电脑上都无法成功解决问题，最后找到了这种方法，简简单单解决。 .h文件123456789101112131415161718192021#ifndef WIDGET_H //包含头文件#define WIDGET_H#include &lt;QWidget&gt; //包含一个头文件QWidget窗口类QT_BEGIN_NAMESPACEnamespace Ui &#123; class Widget; &#125;QT_END_NAMESPACEclass Widget : public QWidget //从QWidget中继承&#123; Q_OBJECT //Q_OBJECT宏，允许类中使用信号和槽的机制public: Widget(QWidget *parent = nullptr);//构造函数，默认值为0 ~Widget();//析构函数private: Ui::Widget *ui;&#125;;#endif // WIDGET_H .cpp文件widget.cpp文件： 1234567891011121314#include \"widget.h\"#include \"ui_widget.h\"Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget)&#123; ui-&gt;setupUi(this);&#125;Widget::~Widget()&#123; delete ui;&#125; 第一个QT程序添加一个按钮用到的API123456789101112131415161718192021222324252627282930313233#include \"widget.h\"#include \"ui_widget.h\"#include \"qdebug.h\"#include &lt;QPushButton&gt; //按钮控件的头文件Widget::Widget(QWidget *parent) : QWidget(parent)&#123; // qDebug()&lt;&lt;\"a\"; QPushButton * btn=new QPushButton;//新建一个按钮对象 btn-&gt;show();//show函数一般是作为顶层方式弹出窗口控件，如果这样调用会出来两个框框 //所以需要让btn对象依赖在Widget中 btn-&gt;setParent(this); //显示文本 btn-&gt;setText(\"第一个按钮\"); QPushButton *btn2=new QPushButton(\"第二个按钮\",this);// btn2-&gt;setParent(this);// btn2-&gt;setText(\"第二个按钮\"); //移动窗口 btn2-&gt;move(100,100); //重置窗口大小 resize(800,600); //设置窗口标题 setWindowTitle(\"第一个窗口\"); //设置窗口固定大小 setFixedSize(1600,600);//函数原型为void setFixedSize(int w, int h);第一个参数为宽，第二个为高 setFixedWidth(1000); setFixedHeight(600);&#125;Widget::~Widget()&#123;&#125; 对象树当创建的对象再堆区的时候，如果指定的父亲是QObject派剩下来的类或者QObject子类派剩下来的类，可以不用管理释放的操作，对象将会被放入到对象树中。这在一定程度上简化了内存的回收机制。 举个栗子，在头文件部分新添加一个c++ class文件new一个按钮时，设定父类为qwidget（qpushbuton是它的子类），btn-&gt;setParent(this)把btn设置到对象树中。在QObject释放时，它会释放掉对象树中所有的资源。所以即使申请的时堆上的资源，也无需我们自己手动释放。 QT中的坐标系以左上角为原点(0,0)，X向左增加，Y向下增加。 对于嵌套窗口，其坐标是相对于父窗口来说的。","categories":[],"tags":[{"name":"QT","slug":"QT","permalink":"https://brillianttt.gitee.io/tags/QT/"}]},{"title":"QT+opencv+vs从安装到实现一个小软件","slug":"QT+opencv+vs从安装到实现一个小软件","date":"2020-12-15T13:51:26.000Z","updated":"2020-12-18T12:15:08.633Z","comments":true,"path":"2020/12/15/QT+opencv+vs从安装到实现一个小软件/","link":"","permalink":"https://brillianttt.gitee.io/2020/12/15/QT+opencv+vs%E4%BB%8E%E5%AE%89%E8%A3%85%E5%88%B0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B0%8F%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"QT下载与安装除了官网可以下载，还可以在国内镜像源下载qt，比如清华大学镜像源也可以下载。 版本我选择的是5.12，在镜像源里选择qt/archive/qt/5.12/5.12.0/qt-opensource-windows-x86-5.12.0.exe,之后下载即可。 下载安装完qt后我们需要再在vs上下载一个插件,路径为:扩展-&gt;管理扩展-&gt;联机-&gt;右侧搜索qt,之后下载qt visual studio tools;如果下载时进度条一直没有前进,则可在搜索到qt后点击右侧的详细信息进入官网下载插件。 之后教程见这里。安装后试运行可能会出一个bug：无法打开 源 文件 “ui_QtGuiApplicationx.h”，这个错误的解决见这里和这里。 opencv环境配置在下载好opencv后，并配置完系统的环境变量后，每新建一个工程都需要重新配置一遍opencv的环境，虽然有些麻烦，但熟悉流程后配环境还是很简单的事情。这是我最开始配置环境时参考的博客。 第一步在新建了一个qt gui application以后,打开解决方案资源管理器,按住Alt+Enter打开属性页 第二步找到vc++部分的包含目录和库目录 其中，包含目录添加opencv文件中的如下三个目录（根据自己opencv的安装路径添加） E:\\OpenCV\\opencv\\build\\include ​ E:\\OpenCV\\opencv\\build\\include\\opencv ​ E:\\OpenCV\\opencv\\build\\include\\opencv2 之后填写库目录，如E:\\OpenCV\\opencv\\build\\x64\\vc14\\lib（同样按照自己的路径进行填写） 下面再再属性页中找到链接器中的输入部分，对附加依赖项进行填写，这部分的内容要查看上面库目录路径中的文件进行参考，如我的是opencv_world450d.lib,文件名称如果加d则为debug版本使用的，入如果是release版本则要选择不加d的文件。 第三步任意写一段代码测试一下是否能运行成功。 qt+opencv在新建完qt项目、配置完opecncv的环境之后，我们开始做一个简单的小软件出来！ 新建文件首先，打开解决方案资源管理器，双击打开.ui文件，进入设计师界面。 然后依次找到push button、scroll area和label，拖拽进入工作区，位置任意定义。 在右侧对象查看器中修改对应部分对象的名称 接下来要写对应的代码。 头文件编辑首先要写.h文件， 代码如下，如果按格式on_控件名_clicked命名函数，QT会默认完成函数和按钮动作的链接，如果不这样命名的话就必须得去设置信号槽函数。 12345678910111213141516171819202122232425262728293031#pragma once#include &lt;QtWidgets/QMainWindow&gt;#include\"ui_QtGuiApplication1.h\"#include&lt;QGraphicsScene&gt; #include&lt;QGraphicsView&gt; //graphicsview类#include&lt;opencv2\\imgproc\\imgproc.hpp&gt;#include &lt;opencv2\\core\\core.hpp&gt;#include &lt;opencv2\\highgui\\highgui.hpp&gt; //opencv申明#include &lt;qfiledialog.h&gt; //getopenfilename 类申明#include &lt;qlabel.h&gt; //label类using namespace cv;class QtGuiApplication1 : public QMainWindow&#123; Q_OBJECTpublic: QtGuiApplication1(QWidget *parent = Q_NULLPTR); ~QtGuiApplication1(); private slots: void on_Progress_clicked(); void on_OpenFig_clicked(); private: Ui::QtGuiApplication1Class ui; Mat image;//mat类声明 QLabel* label; QLabel* label_2;&#125;; 上面的函数名称要对照自己的代码进行修改。 之后编辑信息槽，这一步的目的是使得按钮的动作和函数连接起来。（长按拖动到两个按钮上) 在配置连接部分选择clicked(),进行编辑，添加槽on_OpenFig_clicked()和on_Progress_clicked()。 完成连接后结果如上图，保存后关闭ui即可。 cpp文件编辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include \"QtGuiApplication1.h\"#include &lt;opencv2/imgproc/types_c.h&gt;#include&lt;opencv2\\imgproc\\imgproc.hpp&gt;#include &lt;opencv2\\core\\core.hpp&gt;using namespace cv;using namespace std;QtGuiApplication1::QtGuiApplication1(QWidget *parent) : QMainWindow(parent)&#123; ui.setupUi(this); &#125;QtGuiApplication1::~QtGuiApplication1()&#123; &#125;void QtGuiApplication1::on_OpenFig_clicked()&#123; QString filename; filename = QFileDialog::getOpenFileName(this, tr(\"Sele\"), \"\", tr(\"Images (*.png *.bmp *.jpg *.tif *.GIF )\")); if (filename.isEmpty()) &#123; return; &#125; else &#123; string str = filename.toStdString(); // 将filename转变为string类型； image = imread(str); //image=imread(fileName.toLatin1().data); cvtColor(image, image,CV_BGR2RGB);// CV_BGR2RGB cv::resize(image, image, Size(300, 200)); QImage img = QImage((const unsigned char*)(image.data), image.cols, image.rows,image.step, QImage::Format_RGB888); label = new QLabel(); label-&gt;setPixmap(QPixmap::fromImage(img)); label-&gt;resize(QSize(img.width(), img.height())); ui.scrollArea-&gt;setWidget(label); &#125;&#125;void QtGuiApplication1::on_Progress_clicked()&#123; Mat image1; flip(image, image1,3);//反转函数 0 上下反转；整数，水平发转；负数，水平垂直均反转 QImage img1 = QImage((const unsigned char*)(image1.data), image1.cols, image1.rows, image1.step,QImage::Format_RGB888); label_2 = new QLabel(); label_2-&gt;setPixmap(QPixmap::fromImage(img1)); label_2-&gt;resize(QSize(img1.width(), img1.height())); ui.scrollArea_2-&gt;setWidget(label_2);&#125; 大功告成✌，运行结果示例： 常见问题在刚完成.cpp文件的书写时，常会报错这个错：E0135 class “Ui::QtGuiApplication1Class” 没有成员 “xxx”，这是因为。。。（好像是因为反应比较慢），我们需要先编译一次（ctrl+f5也行），然后在解决方案资源管理器-&gt;右键点击自己的项目-&gt;重新扫描解决方案，这个错就被消除了。","categories":[],"tags":[{"name":"QT","slug":"QT","permalink":"https://brillianttt.gitee.io/tags/QT/"}]},{"title":"博客的音乐功能设置","slug":"博客的音乐功能设置","date":"2020-12-11T12:09:27.504Z","updated":"2020-12-17T03:28:04.312Z","comments":true,"path":"2020/12/11/博客的音乐功能设置/","link":"","permalink":"https://brillianttt.gitee.io/2020/12/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%9F%B3%E4%B9%90%E5%8A%9F%E8%83%BD%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"今天刚开始设置博客的音乐组件，留下一点小笔记备用😁首先，音乐的获取可以通过这两个方式：1、可以在网易云音乐上直接搜索喜欢的歌曲，找到外部链接2、自己创建网易云歌单，添加喜欢的歌曲，再找到自己歌单的外部链接之后再主题在文件夹下搜索music，找到music.ejs文件,在其中将”iframe”处替换成刚找到链接。最后将主题的yml文件中的#music部分做修改，更改http链接与音乐id就大功告成啦！(ps：在代码中修改各项参数可以更改音乐播放器的大小，将宽度和高度改为0或1可以隐藏音乐播放器，做到完完全全的“背景音乐”)","categories":[{"name":"博客开发","slug":"博客开发","permalink":"https://brillianttt.gitee.io/categories/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"敲代码时遇到的常见bug及解决方法","slug":"敲代码时遇到的常见bug及解决方法","date":"2020-11-22T09:21:19.000Z","updated":"2020-11-26T13:41:27.102Z","comments":true,"path":"2020/11/22/敲代码时遇到的常见bug及解决方法/","link":"","permalink":"https://brillianttt.gitee.io/2020/11/22/%E6%95%B2%E4%BB%A3%E7%A0%81%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%B8%B8%E8%A7%81bug%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"Android Studio类错误ndk配置清戳这里 配置NDK遇到的错误在下载ndk成功后如果没有配置环境，会报如下错误： 1Caused by: org.gradle.api.InvalidUserDataException: NDK not configured 这里是解决办法","categories":[],"tags":[{"name":"BUG解决","slug":"BUG解决","permalink":"https://brillianttt.gitee.io/tags/BUG%E8%A7%A3%E5%86%B3/"}]},{"title":"OpenCV学习中的参考博客","slug":"OpenCV学习中的参考博客","date":"2020-11-19T13:07:16.000Z","updated":"2020-11-26T13:41:27.673Z","comments":true,"path":"2020/11/19/OpenCV学习中的参考博客/","link":"","permalink":"https://brillianttt.gitee.io/2020/11/19/OpenCV%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"下面是一些个人认为讲的很好的一些博客，对自己在OpenCV学习上有很大的帮助 图片边缘填充","categories":[],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://brillianttt.gitee.io/tags/OpenCV/"}]},{"title":"图像处理作业","slug":"图像处理作业","date":"2020-11-06T15:00:43.000Z","updated":"2020-11-08T11:46:07.462Z","comments":true,"path":"2020/11/06/图像处理作业/","link":"","permalink":"https://brillianttt.gitee.io/2020/11/06/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"第一次作业内容如图：在刚留这个作业时学长给了一些解题的思路，快到作业截止提交的时间才做出来。。。 言归正传，这道题的思路比较简单，就是把图片先进行灰度化和二值化的处理，然后再将二值图中的黑色部分找到，将原图中的蓝色部分变为黑色，最后裁剪就可以了，但中间有一些小坑，在最开始做的时候出现并困扰了我挺长时间，之前得到的图片是这个样子的：这是因为在处理时没有将图片进行二值化处理，而图片本身像素不够高，很多地方的颜色都有细微的差别，因而在直接暴力将背景中的蓝色修改为黑色是不可行的，会出现“其岸势犬牙差互”的情况。 经过学长提醒，我后来的思路是这样子的： 1、对图片进行灰度化、二值化处理，并将处理后的图片保存到另一个变量part中。 2、对二值图part进行遍历，找到图片🐕的四个边缘值（最上、下、左、右）的坐标，然后用rect这个函数对二值图和原图进行裁剪。 3、对二值图再次进行遍历，在二值图的某像素点为黑色时，将原图上的对应像素点也变为黑色 经过这几个步骤，即可得到想要答案。 源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include&lt;iostream&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include \"opencv2/imgproc/imgproc.hpp\" #include &lt;opencv2/core/core.hpp&gt; using namespace std;using namespace cv; int main()&#123; Mat img,part1,part,src=imread(\"D:/code/dog.png\"); cvtColor(src,part1, COLOR_BGR2GRAY);//灰度化 threshold(part1, part, 175, 255, THRESH_BINARY);//二值化 imshow(\"二值图\",part); imwrite(\"D:/code/doggle.png\", part); part = imread(\"D:/code/doggle.png\"); int i, j, x1 = part.rows/2, x2 = part.rows / 2, y1 = part.cols / 2, y2=part.cols / 2;//给四个极值赋初值，其中.row和.cols分别返回图片的宽和长 int cPointB,cPointb;//currentPoint; //cout &lt;&lt; part.rows &lt;&lt; ' ' &lt;&lt; part.cols &lt;&lt; endl;调试用 for (i = 0; i &lt; part.rows; i++)//遍历图片找极值 for (j = 0; j &lt; part.cols; j++) &#123; cPointb = part.at&lt;Vec3b&gt;(i,j)[0]; if (0!=cPointb )//也可以把rgb三个颜色都判断下是否为零（全为0即为黑色），不过没有意义 &#123; if (i &lt; x1)x1 = i; else if (i &gt; x2)x2 = i; if (j &lt; y1)y1 = j; else if (j &gt; y2)y2 = j; &#125; &#125; cout &lt;&lt; x1 &lt;&lt; ' ' &lt;&lt; y1 &lt;&lt; ' ' &lt;&lt; x2 &lt;&lt; ' ' &lt;&lt; y2 &lt;&lt; endl; Rect m_select; m_select = Rect(y1, x1 ,y2 - y1,x2 - x1);//进行裁剪,注意此处x、y的坐标是相反的！ Mat roi = part(m_select); imshow(\"ans\", roi); imwrite(\"D:/code/dogcaijian.png\", roi); src=src(m_select);//对原图进行裁剪 cout &lt;&lt; src.rows &lt;&lt; ' ' &lt;&lt; src.cols &lt;&lt; endl; for(i=0;i&lt; src.rows;i++) for(j=0;j&lt; src.cols;j++) &#123; if(roi.at&lt;Vec3b&gt;(i,j)[0]==0) &#123; //cout &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt; ' ' &lt;&lt; \"j=\" &lt;&lt; j &lt;&lt; endl; src.at&lt;Vec3b&gt;(i,j)[0]=0;//&lt;Vec3b&gt;(i,j)[0]为蓝色值 src.at&lt;Vec3b&gt;(i,j)[1]=0;//&lt;Vec3b&gt;(i,j)[1]为绿色值 src.at&lt;Vec3b&gt;(i,j)[2]=0;//&lt;Vec3b&gt;(i,j)[2]为红色值 //对R、G、B三个值都赋值为0，得到黑色像素点 &#125; &#125; imshow(\"doggle\",src); waitKey(0); return 0;&#125; 最终结果： 附一个颜色表，在最后遍历的时候可以换成不同的颜色玩~ 第二次作业内容如图：分析：本题需要注意除了要把苹果部分抠出来，还需要将苹果缩小，放到背景图中的“上层”。 思路可以是这样的： 1、先对苹果的logo进行灰度化和二值化的处理。 2、然后将图二裁剪到和图一一样大，将图一再次缩小，放到背景图片中，将其余部分变黑。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include&lt;iostream&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include \"opencv2/imgproc/imgproc.hpp\" #include &lt;opencv2/core/core.hpp&gt; using namespace std;using namespace cv; //opencv 的命名空间int main()&#123; Mat pingguo, beijing,temp,pg; temp=imread(\"D:\\\\code\\\\opencv\\\\resources\\\\apple.jpg\"); beijing = imread(\"D:\\\\code\\\\opencv\\\\resources\\\\background.jpg\"); Rect r = Rect(0, 0, temp.rows, temp.cols); putText(temp, \"Apple\", Point(temp.rows/2-80, temp.cols-30),FONT_HERSHEY_SIMPLEX, 2, Scalar(0, 0, 0), 5, LINE_AA, false); cvtColor(temp,pg, COLOR_BGR2GRAY);//灰度化 //imshow(\"灰度图\", pg); threshold(pg,pg ,100, 255, THRESH_BINARY);//二值化 //imshow(\"二值图\", pg); vector&lt;int&gt; a; a.push_back(IMWRITE_JPEG_QUALITY); //选择jpeg a.push_back(255); //在这个填入你要的图片质量（255为无损保存，一定要进行255，否则图像失真） imwrite(\"D:\\\\code\\\\opencv\\\\resources\\\\x.jpg\", pg, a); //imwrite(\"D:\\\\code\\\\opencv\\\\resources\\\\x.jpg\", pg); pingguo = imread(\"D:\\\\code\\\\opencv\\\\resources\\\\x.jpg\");//,IMREAD_UNCHANGED); pingguo = imread(\"d:\\\\code\\\\opencv\\\\resources\\\\x.jpg\"); //imshow(\"apple\",pingguo); beijing = beijing(r); //imshow(\"background\", beijing); imwrite(\"d:\\\\code\\\\opencv\\\\resources\\\\caijian.jpg\", beijing); for(int i=0;i&lt;pingguo.rows ;i++) for(int j=0;j&lt; pingguo.cols;j++) &#123; if ((int)pingguo.at&lt;Vec3b&gt;(i, j)[0] &gt;= 240 &amp;&amp; (int)pingguo.at&lt;Vec3b&gt;(i, j)[0] &lt;= 255 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i, j)[1] &gt;= 240 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i, j)[1] &lt;= 255 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i, j)[2] &gt;= 240 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i, j)[2] &lt;= 255) &#123; //cout &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt; ' ' &lt;&lt; \"j=\" &lt;&lt; j &lt;&lt; endl; beijing.at&lt;Vec3b&gt;(i,j)[0]=0; beijing.at&lt;Vec3b&gt;(i,j)[1]=0; beijing.at&lt;Vec3b&gt;(i,j)[2]=0; &#125; &#125; imshow(\"beijing\", beijing); waitKey(0); return 0;&#125; 但是这种方法在实现的过程中出现了许多问题： 1、没有将苹果logo缩小。 2、苹果的处理不精细，在嵌套的for循环中本应该有判断语句中0（蓝色值）为255，而这个代码中判断如果大于240即可，这是因为在图片的二值化处理过程中，经过二值化处理的图片本应该是单通道输入和输出的，但是输入后再读取这个图片的时候是三通道读取，就会出现问题。在上面的给出的代码是经过了处理，保存的是单通道图片，但是我在遍历图片的rgb三个值时还能发现除了0和255外其他的值（如1、2、3、254、253）百度了下这是会经常出现的失真问题，我就将这部分代码由直接判断是否为255（白色）变为了判断一个范围值。 困难总比办法多，但是不慌，还有机会，现在有第二种思路： 1、还是先按照苹果logo图片的大小截取一部分背景，以此作为最终背景。 2、将“apple”插入苹果图，然后进行图片的灰度化和二值化，再利用resize()函数将图片缩小为原来的0.5倍并保存。 3、制作苹果图的掩膜。 4、与背景图进行与运算，得出最终图片。 先放一个铁憨憨的代码（还是没用上掩膜操作）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include&lt;iostream&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include \"opencv2/imgproc/imgproc.hpp\" #include &lt;opencv2/core/core.hpp&gt; using namespace std;using namespace cv;int main()&#123; Mat pingguo, beijing,temp,pg,mask,xpg; temp=imread(\"D:\\\\code\\\\opencv\\\\resources\\\\apple.jpg\"); beijing = imread(\"D:\\\\code\\\\opencv\\\\resources\\\\background.jpg\"); Rect r = Rect(200, 200, temp.rows, temp.cols); putText(temp, \"Apple\", Point(temp.rows/2-80, temp.cols-30),FONT_HERSHEY_SIMPLEX, 2, Scalar(0, 0, 0), 5, LINE_AA, false);//将字母插入，后续补充 cvtColor(temp,pg, COLOR_BGR2GRAY);//灰度化 //imshow(\"灰度图\", pg); threshold(pg,pg ,100, 255, THRESH_BINARY);//二值化 //imshow(\"二值图\", pg); vector&lt;int&gt; a;//开始无失真保存 a.push_back(IMWRITE_JPEG_QUALITY); //选择jpeg a.push_back(255); //在这个填入需要的图片质量（255为无损保存，一定要进行255，否则图像失真） resize(pg, pingguo, Size(), 0.5, 0.5);//缩放为原来的0.5倍，并存储在pingguo里 imwrite(\"D:\\\\code\\\\opencv\\\\resources\\\\x.jpg\", pingguo, a); //imwrite(\"D:\\\\code\\\\opencv\\\\resources\\\\x.jpg\", pg); imshow(\"temp\", pingguo); pingguo = imread(\"d:\\\\code\\\\opencv\\\\resources\\\\x.jpg\"); //imshow(\"apple\",pingguo); beijing = beijing(r); //imshow(\"background\", beijing); imwrite(\"d:\\\\code\\\\opencv\\\\resources\\\\caijian.jpg\", beijing); for(int i= 0;i&lt; beijing.rows ;i++) for(int j= 0;j&lt; beijing.cols;j++) &#123; if (!(i - pingguo.rows / 2 &gt;= 0 &amp;&amp; j - pingguo.cols / 2 &gt;= 0 &amp;&amp; i - pingguo.rows / 2 &lt; pingguo.rows &amp;&amp; j - pingguo.cols / 2 &lt; pingguo.cols &amp;&amp; (int)pingguo.at&lt;Vec3b&gt;(i - pingguo.rows / 2, j - pingguo.cols / 2)[0] &gt;= 0 &amp;&amp; (int)pingguo.at&lt;Vec3b&gt;(i - pingguo.rows / 2, j - pingguo.cols / 2)[0] &lt;= 5 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i - pingguo.rows / 2, j - pingguo.cols/2)[1] &gt;= 0 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i - pingguo.rows / 2, j - pingguo.cols/2)[1] &lt;= 10 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i - pingguo.rows / 2, j - pingguo.cols/2)[2] &gt;= 0 &amp;&amp; pingguo.at&lt;Vec3b&gt;(i - pingguo.rows / 2, j - pingguo.cols/2)[2] &lt;= 10)) &#123;//这个判断条件是通过推导得出的，可能与题目需要的做题方法不同 beijing.at&lt;Vec3b&gt;(i,j)[0]=0; beijing.at&lt;Vec3b&gt;(i, j)[1]=0; beijing.at&lt;Vec3b&gt;(i, j)[2]=0; &#125; &#125; imwrite(\"D:\\\\code\\\\opencv\\\\resources\\\\ans2.jpg\",beijing); imshow(\"beijing\", beijing); waitKey(0); return 0;&#125; 中间用到的部分函数介绍： 12345678910111213resize(pg, pingguo, Size(), 0.5, 0.5);//五个参数分别为要做缩放的图片，缩放后的图片，size函数，长的缩放倍数，宽的缩放倍数putText(temp, \"Apple\", Point(temp.rows/2-80, temp.cols-30),FONT_HERSHEY_SIMPLEX, 2, Scalar(0, 0, 0), 5, LINE_AA, false);函数原型为： void putText( Mat&amp; img, const string&amp; text, Point org, int fontFace,double fontScale， Scalar color, int thickness=1, int lineType=8 );参数1：， Mat&amp; img，待写字的图片，我们写在img图上参数2：，const string&amp; text，待写入的字参数3：， Point org， 第一个字符左下角坐标参数4：，int fontFace，字体类型，FONT_HERSHEY_SIMPLEX ，FONT_HERSHEY_PLAIN ， FONT_HERSHEY_DUPLEX 等等等。参数5：，double fontScale，字体大小参数6：，Scalar color，字体颜色，颜色用Scalar（）表示参数7：， int thickness，字体粗细参数8：， int lineType，线型 CV_8UC1的介绍：见链接 最终效果：","categories":[],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://brillianttt.gitee.io/tags/OpenCV/"}]},{"title":"c语言基础之文件操作","slug":"c语言基础之文件操作","date":"2020-10-15T16:33:21.000Z","updated":"2020-10-15T16:36:52.151Z","comments":true,"path":"2020/10/16/c语言基础之文件操作/","link":"","permalink":"https://brillianttt.gitee.io/2020/10/16/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"","text":"关于文件处理，暂时先借鉴这位博主的博客。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://brillianttt.gitee.io/tags/C-C/"}]},{"title":"OpenCV学习","slug":"OpenCV的学习","date":"2020-10-13T13:15:49.000Z","updated":"2021-03-09T15:20:04.979Z","comments":true,"path":"2020/10/13/OpenCV的学习/","link":"","permalink":"https://brillianttt.gitee.io/2020/10/13/OpenCV%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"今天突然发奋学习之学习OpenCV 安装教程见这里或者这里,文章中没有提到，配置完环境变量以后还需要重启vs2019~ 图像读取与显示12345678910111213141516171819202122232425#include&lt;opencv2/opencv.hpp&gt;#include&lt;iostream&gt;using namespace cv;using namespace std;int main(int argc, char** argv)&#123; //Mat img = imread(\"D:/25.jpg\",0);//imrean()功能为载入一张图片；第二个参数为灰度，为0时为灰色,为1时为原图 Mat src = imread(\"D:/15.jpg\",IMREAD_GRAYSCALE);//注意这里的路径和直接ctrl+v过来的路径不同，是用“/”而不是“\\” 其次，IMREAD_GRAYSCALE是使图片变为灰色 //Mat src = imread(\"D:/25.jpg\"); if (src.empty()) &#123; printf(\"could not load image...\\n\"); return -1; //return 0：一般用在主函数结束时，按照程序开发的一般惯例，表示成功完成本函数。 //return -1：:表示返回一个代数值，一般用在子函数结尾。按照程序开发的一般惯例，表示该函数失败； &#125;//判断是否能找到图片，如果找不到则输出balabala namedWindow(\"输入窗口\",WINDOW_FREERATIO);//引号内内容为提取出的图片右上角的名称，如果没有添加该语句则名称默认为图片大小，WINDOW_FREERATIO函数可以使得图像自由变化大小 imshow(\"输入窗口\", src);//imshow()功能为把刚才的图片显示出来 imwrite(\"hhhh.jpg\", src);//输出一张图片到工程目录下，第一个参数为图片名称 waitKey(0);//等待按键时间:0ms，等待后退出 destroyAllWindows();//结束程序，并释放之前分配的与窗口有关的所有内存空间 return 0;&#125; 其中有 cv.IMREAD_COLOR： 加载彩色图像。任何图像的透明度都会被忽视。它是默认标志。 cv.IMREAD_GRAYSCALE：以灰度模式加载图像 cv.IMREAD_UNCHANGED：加载图像，包括alpha通道 使用MatplotlibMatplotlib是Python的绘图库，可为你提供多种绘图方法。你将在接下来的文章中看到它们。在这里，你将学习如何使用Matplotlib显示图像。你可以使用Matplotlib缩放图像，保存图像等。 1234567import numpy as npimport cv2 as cvfrom matplotlib import pyplot as pltimg = cv.imread('messi5.jpg',0)plt.imshow(img, cmap = 'gray', interpolation = 'bicubic')plt.xticks([]), plt.yticks([]) # 隐藏 x 轴和 y 轴上的刻度值plt.show() 读取和保存视频文件读取要捕获视频，你需要创建一个 VideoCapture 对象。它的参数可以是设备索引或视频文件的名称。设备索引就是指定哪个摄像头的数字。正常情况下，一个摄像头会被连接(就像我的情况一样)。所以我简单地传0(或-1)。你可以通过传递1来选择第二个相机，以此类推。在此之后，你可以逐帧捕获。但是在最后，不要忘记释放俘虏。 12345678910111213141516171819202122import numpy as npimport cv2 as cvcap = cv.VideoCapture(0)#如果要读取文件，只需将0变为文件的路径if not cap.isOpened(): print(\"Cannot open camera\") exit()while True: # 逐帧捕获 ret, frame = cap.read() # 如果正确读取帧，ret为True if not ret: print(\"Can't receive frame (stream end?). Exiting ...\") break # 我们在框架上的操作到这里 gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) # 显示结果帧e cv.imshow('frame', gray) if cv.waitKey(1) == ord('q'): break# 完成所有操作后，释放捕获器cap.release()cv.destroyAllWindows() 保存所以我们捕捉一个视频，一帧一帧地处理，我们想要保存这个视频。对于图像，它非常简单，只需使用 cv.imwrite()。这里还需要做一些工作。这次我们创建一个 VideoWriter 对象。我们应该指定输出文件名(例如: output.avi)。然后我们应该指定 FourCC 代码(详见下一段)。然后传递帧率的数量和帧大小。最后一个是颜色标志。如果为True ，编码器期望颜色帧，否则它与灰度帧一起工作。FourCC：http://en.wikipedia.org/wiki/FourCC 是用于指定视频编解码器的4字节代码。可用代码列表可在fourcc.org中:http://www.fourcc.org/codecs.php 找到。它取决于平台。遵循编解码器对我来说效果很好 123456789101112131415161718192021import numpy as npimport cv2 as cvcap = cv.VideoCapture(0)# 定义编解码器并创建VideoWriter对象fourcc = cv.VideoWriter_fourcc(*'XVID')out = cv.VideoWriter('output.avi', fourcc, 20.0, (640, 480))while cap.isOpened(): ret, frame = cap.read() if not ret: print(\"Can't receive frame (stream end?). Exiting ...\") break frame = cv.flip(frame, 0) # 写翻转的框架 out.write(frame) cv.imshow('frame', frame) if cv.waitKey(1) == ord('q'): break# 完成工作后释放所有内容cap.release()out.release()cv.destroyAllWindows() opencv的绘图功能在上述所有功能中，您将看到一些常见的参数，如下所示： img：您要绘制形状的图像 color：形状的颜色。对于BGR，将其作为元组传递，例如：(255,0,0)对于蓝色。对于灰度，只需传递标量值即可。厚度：线或圆等的粗细。如果对闭合图形（如圆）传递 -1 ，它将填充形状。默认厚度= 1 lineType：线的类型，是否为8连接线，抗锯齿线等。默认情况下，为8连接线。 cv.LINE_AA给出了抗锯齿的线条，看起来非常适合曲线。 1234567先创建黑色的图像：img &#x3D; np.zeros((512,512,3), np.uint8)绘制直线：cv.line(img,(0,0),(511,511),(255,0,0),5)绘制矩形：cv.rectangle(img,(384,0),(510,128),(0,255,0),3) 分别给出了矩形的左上角和右下角坐标画圆：cv.circle(img,(447,63), 63, (0,0,255), -1)，需要中心坐标和半径 ##向图片中添加文本：要将文本放入图像中，需要指定以下内容。 - 您要写入的文字数据 - 您要放置它的位置坐标（即数据开始的左下角）。 - 字体类型（检查cv.putText文档以获取受支持的字体） - 字体比例（指定字体大小） - 常规的内容，例如颜色，厚度，线条类型等。为了获得更好的外观，建议使用lineType = cv.LINE_AA。 12font = cv.FONT_HERSHEY_SIMPLEXcv.putText(img,'OpenCV',(10,500), font, 4,(255,255,255),2,cv.LINE_AA) 图像拼接123456789101112131415161718192021222324252627#include&lt;opencv2\\opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace cv;using namespace std;int main() &#123; Mat image = imread(\"D:/25.jpg\"); Mat logo = imread(\"D:/16.jpg\"); Mat imageROI = image(Rect(image.cols - logo.cols, image.rows - logo.rows, logo.cols, logo.rows)); //Mat imageROI = image(Range(350,350+logo.rows),Range(800,800+logo.rows)); //效果同上 //将logo加到原图上 addWeighted(imageROI, 1.0, logo, 1, 0., imageROI); //使用掩模,效果同上 /* Mat mask = imread(\"C:\\\\Users\\\\Nelsoner\\\\Desktop\\\\Camera Roll\\\\001.jpg\"); logo.copyTo(imageROI, mask);*/ namedWindow(\"hah\"); imshow(\"hah\", image); imwrite(\"hhh.jpg\", image); waitKey(0); destroyAllWindows; return 0;&#125; ROI关于ROI(region of interest——感兴趣区域)的定义，可以看这里 addWeighted第一个参数：InputArray src1，表示需要加权的第一个数组，常常填一个Mat 第二个参数：double alpha，表示第一个数组的权重 第三个参数：InputArray src2，表示第二个数组，需要和第一个数组拥有相同的尺寸和通道数 第四个参数：double beta，第二个数组的权重值，值为1-alpha 第五个参数：double gamma，一个加到权重总和上的标量值。 第六个参数：OutputArray dst，输出的数组，和输入的两个数组拥有相同的尺寸和通道数 dst = src1[I] * alpha + src2[I] * beta + gamma 第七个参数：int dtype，输出阵列的可选深度，有默认值-1。当两个输入数组具有相同深度时，这个参数设置为-1（默认值），即等同于src1.depth()。 下边是一个使用addWeighted()函数实现线性混合操作的例子： 123456789101112131415161718192021222324252627282930313233 #include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;iostream&gt; using namespace cv;using namespace std; void main()&#123; //【0】定义一些局部变量 double alphaValue = 0.5; double betaValue; Mat srcImage1, srcImage2, dstImage; // 【1】读取图像 ( 两幅图片需为同样的类型和尺寸 ) srcImage1 = imread(\"mogu.jpg\"); srcImage2 = imread(\"rain.jpg\"); if (!srcImage1.data) cout &lt;&lt; \"读取srcImage1错误！ \\n\" &lt;&lt; endl; imshow(\"1图原始图\", srcImage1); if (!srcImage2.data) cout &lt;&lt; \"读取srcImage2错误！ \\n\" &lt;&lt; endl; imshow(\"2图原始图\", srcImage2); // 【2】进行图像混合加权操作 betaValue = (1.0 - alphaValue); addWeighted(srcImage1, alphaValue, srcImage2, betaValue, 0.0, dstImage); // 【3】显示效果图 imshow(\"&lt;3&gt;线性混合示例窗口【效果图】\", dstImage); waitKey();&#125; Canny边缘识别函数123456789101112131415161718192021222324#include&lt;opencv2\\highgui\\highgui.hpp&gt;#include&lt;opencv2\\imgproc\\imgproc.hpp&gt;using namespace cv;using namespace std;int main() &#123; //载入原图 Mat srcImage = imread(\"D:/17.jpg\"); //显示原图 imshow(\"【原图】Canny边缘检测\", srcImage); Mat dstImage, edge, grayImage; //【1】创建于src同类型和大小的矩阵dst dstImage.create(srcImage.size(), srcImage.type()); //【2】将原图像转换成灰度图像 cvtColor(srcImage, grayImage, COLOR_BGR2GRAY); //【3】先使用3*3内核来降噪 blur(grayImage, edge, Size(3, 3)); //【4】运行Canny算子 Canny(edge, edge, 3, 9, 3); //显示效果图 imshow(\"【效果图】Canny边缘检测\", edge); waitKey(0); return 0;&#125; 图像的二值化见链接。 颜色反转、图片边缘扩展、这里 将视频文件逐帧保存123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;iostream&gt;using namespace std;using namespace cv;int main()&#123; //打开视频文件：其实就是建立一个VideoCapture结构 VideoCapture capture(0);//()中为0时调用电脑摄像头，为视频文件地址时调用文件 //检测是否正常打开:成功打开时，isOpened返回ture if (!capture.isOpened()) cout &lt;&lt; \"fail toopen!\" &lt;&lt; endl; //获取整个帧数 long totalFrameNumber = capture.get(CAP_PROP_FRAME_COUNT); cout &lt;&lt; \"整个视频共\" &lt;&lt; totalFrameNumber &lt;&lt; \"帧\" &lt;&lt; endl; //设置开始帧() long frameToStart = 1; capture.set(CAP_PROP_POS_FRAMES, frameToStart); cout &lt;&lt; \"从第\" &lt;&lt; frameToStart &lt;&lt; \"帧开始读\" &lt;&lt; endl; //设置结束帧 int frameToStop = 10000; if (frameToStop &lt; frameToStart) &#123; cout &lt;&lt; \"结束帧小于开始帧，程序错误，即将退出！\" &lt;&lt; endl; return -1; &#125; else &#123; cout &lt;&lt; \"结束帧为：第\" &lt;&lt; frameToStop &lt;&lt; \"帧\" &lt;&lt; endl; &#125; //获取帧率 double rate = capture.get(CAP_PROP_FPS); cout &lt;&lt; \"帧率为:\" &lt;&lt; rate &lt;&lt; endl; //定义一个用来控制读取视频循环结束的变量 bool stop = false; //承载每一帧的图像 Mat frame; //显示每一帧的窗口 //namedWindow( \"Extractedframe\" ); //两帧间的间隔时间: //int delay = 1000/rate; double delay = 1000 / rate; //利用while循环读取帧 //currentFrame是在循环体中控制读取到指定的帧后循环结束的变量 long currentFrame = frameToStart; while (!stop) &#123; //读取下一帧 if (!capture.read(frame)) &#123; cout &lt;&lt; \"读取视频失败\" &lt;&lt; endl; return -1; &#125; //cout &lt;&lt; \"正在读取第\" &lt;&lt; currentFrame &lt;&lt; \"帧\" &lt;&lt; endl; //imshow( \"Extractedframe\", frame ); //此处为跳帧操作 if (currentFrame % 5 == 0) //此处为帧数间隔，修改这里就可以了 &#123; cout &lt;&lt; \"正在写第\" &lt;&lt; currentFrame &lt;&lt; \"帧\" &lt;&lt; endl; stringstream str; str &lt;&lt; \"d:/temp/\" &lt;&lt; currentFrame &lt;&lt; \".png\"; /*图片存储位置*/ cout &lt;&lt; str.str() &lt;&lt; endl; imwrite(str.str(), frame); &#125; //waitKey(intdelay=0)当delay≤ 0时会永远等待；当delay&gt;0时会等待delay毫秒 //当时间结束前没有按键按下时，返回值为-1；否则返回按键 int c = waitKey(delay); //按下ESC或者到达指定的结束帧后退出读取视频 if ((char)c == 27 || currentFrame &gt; frameToStop) &#123; stop = true; &#125; //按下按键后会停留在当前帧，等待下一次按键 if (c &gt;= 0) &#123; waitKey(0); &#125; currentFrame++; &#125; //关闭视频文件 capture.release(); waitKey(0); return 0;&#125; 创建掩膜时一些参数的说明关于Scalar的说明 首先单词scalar的意思是标量，但是我们经常可以看到Scalar是包含多个值的，很像是一个向量，这是怎么回事呢？很是让人感觉困惑。先收起我们的困惑，首先来看看，Scalar的定义： 1234typedef struct Scalar&#123; double val[4];&#125;Scalar; Scalar最多可以存储四个值，没有提供的值默认是0。 Scalar常用的使用场景如下： 1Mat M(7,7,CV_32FC2,Scalar(1,3)); 上面的代码表示：创建一个2通道，且每个通道的值都为（1,3），深度为32，7行7列的图像矩阵。CV_32F表示每个元素的值的类型为32位浮点数，C2表示通道数为2，Scalar（1,3）表示对矩阵每个元素都赋值为（1,3），第一个通道中的值都是1，第二个通道中的值都是3. 举两个例子： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;stdio.h&gt;using namespace std;using namespace cv;void scalar_demo1()&#123; Mat M(4,4,CV_32FC2,Scalar(1,3)); cout&lt;&lt;M&lt;&lt;endl;&#125;void scalar_demo2()&#123; Mat M(4,4,CV_32FC3,Scalar(1,2,3)); cout&lt;&lt;M&lt;&lt;endl;&#125;void scalar_demo3()&#123; Mat M(4,4,CV_32FC4,Scalar(1,2,3)); cout&lt;&lt;M&lt;&lt;endl;&#125;int main(void)&#123; //resize_img(); //convert_color_space(); scalar_demo1(); cout&lt;&lt;\"**********************************\"&lt;&lt;endl; scalar_demo2(); cout&lt;&lt;\"**********************************\"&lt;&lt;endl; scalar_demo3(); return 0;&#125; 运行以上代码输出如下，可以发现最后一个矩阵是4通道的，但是我们在初始化的时候只给出了三个通道的值，所以第四个通道的值都默认为0。 123456789101112131415161718192021222324#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;stdio.h&gt;using namespace std;using namespace cv; void scalar_demo4()&#123; Mat blue_m(256,256,CV_8UC3,Scalar(255,0,0)); Mat green_m(256,256,CV_8UC3,Scalar(0,255,0)); Mat red_m(256,256,CV_8UC3,Scalar(0,0,255)); imshow(\"Blue\",blue_m); waitKey(0); imshow(\"Green\",green_m); waitKey(0); imshow(\"Red\",red_m); waitKey(0); &#125;int main(void)&#123; scalar_demo4(); return 0;&#125; 相信读到这你已经明白Scalar是用来干什么的了，它将各个通道的值构成一个整体，赋给具有相同通道数的矩阵元素。至于它开头提到的它为什么叫做标量，就不必再纠结了。","categories":[],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://brillianttt.gitee.io/tags/OpenCV/"}]},{"title":"c++常用函数","slug":"c++常用函数","date":"2020-09-03T08:34:55.000Z","updated":"2020-10-15T16:36:54.559Z","comments":true,"path":"2020/09/03/c++常用函数/","link":"","permalink":"https://brillianttt.gitee.io/2020/09/03/c++%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","excerpt":"","text":"C++: max_element函数和min_element函数1234567891011#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[]=&#123;4,2,3,8,5&#125;; int len=sizeof(a)/sizeof(int); cout&lt;&lt;*max_element(a,a+len)&lt;&lt;endl; //输出集合最大元素 cout&lt;&lt;*min_element(a,a+len)&lt;&lt;endl;//输出集合最小元素 return 0;&#125; 输出： 1282 min_element 返回最小的元素的位置中序列 [first, last)。同理 max_element。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://brillianttt.gitee.io/tags/C-C/"}]},{"title":"常见加密算法","slug":"RSA加密","date":"2020-09-01T00:40:54.000Z","updated":"2020-10-15T16:41:47.670Z","comments":true,"path":"2020/09/01/RSA加密/","link":"","permalink":"https://brillianttt.gitee.io/2020/09/01/RSA%E5%8A%A0%E5%AF%86/","excerpt":"","text":"RSA加密一个链接：RSA加密 仿射密码发一个菜鸡写的源代码，第一次自己写正经的二百行程序~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;cstring&gt;#define mt memsetusing namespace std;char message[50],ciphertext[50],jiemimiwen[50];int lenthofmessage,key,x,y,z;int inverseGCD(int a,int n)//扩展欧几里得定理求逆元&#123; int p=a,q=n; int x=0,y=1; int z=q/p; while(p!=1&amp;&amp;q!=1) &#123; int t=p; p=q%p; q=t; t=y; y=x-y*z; x=t; z=q/p; &#125; y%=n; if(y&lt;0)y+=n; return y;&#125;int gcd(int a, int b) &#123;//辗转相除法的递归实现 (b==0)?a:gcd(b,a%b);&#125;void encrypt(char message[])//加密算法&#123; int a=2,b;//a=2使下面判断gcd(a,26)顺利进行 if(y==0) &#123; cout&lt;&lt;\"请输入要加密的明文：\\n\"; getchar(); gets(message); &#125; lenthofmessage=strlen(message); if(y==1) &#123; cout&lt;&lt;\"明文为:\"&lt;&lt;message&lt;&lt;endl; &#125; cout&lt;&lt;\"请选择是否使用随机密钥（输入1为是，0为否）：\"&lt;&lt;endl; cin&gt;&gt;z; if(z==1) &#123; srand((unsigned)time(NULL)); while(gcd(a,26)!=1) a = rand()%26+1;//用库函数生成1~26的随机数，a、b为密钥 b =rand()%26+1; &#125; else &#123; cout&lt;&lt;\"请输入两个加密密钥a、b（中间有一个空格）:\"&lt;&lt;endl; cin&gt;&gt;a&gt;&gt;b; while(gcd(a,26)!=1) &#123; cout&lt;&lt;\"输入的第一个参数无法求出解密密钥，请重新输入！\\n\"; cin&gt;&gt;a&gt;&gt;b; &#125; &#125; cout&lt;&lt;\"仿射密码的两个参数分别为：\"&lt;&lt;\"a=\"&lt;&lt;a&lt;&lt;' '&lt;&lt;\"b=\"&lt;&lt;b&lt;&lt;endl; int i=0; while (i&lt;lenthofmessage) &#123; if (message[i]&gt;='A'&amp;&amp;message[i]&lt;='Z') ciphertext[i]='A'+(a*(message[i]-'A')+b+26*a)%26; else if (message[i]&gt;='a'&amp;&amp;message[i]&lt;='z') ciphertext[i]='a'+(a*(message[i]-'a')+b+26*a)%26; else if (message[i]==' ') ciphertext[i]=' '; else ciphertext[i]=message[i]; i++; &#125; cout&lt;&lt;\"加密得到的密文为：\"; puts(ciphertext); cout&lt;&lt;endl&lt;&lt;endl; FILE *fpWrite=fopen(\"ciphertext.txt\",\"w\");//文件处理三连，w为从文件头开始写文件，不存在文件则创建一个新文件 fprintf(fpWrite,\"%s\",ciphertext); fclose(fpWrite);&#125;void decrypt(char message[])&#123; cout&lt;&lt;\"y=\"&lt;&lt;y&lt;&lt;endl; int a,b,i; if(y==0) &#123; cout&lt;&lt;\"请输入要解密的文本:\\n\"; getchar(); gets(message); &#125; lenthofmessage=strlen(message); cout&lt;&lt;\"请输入两个解密密钥a、b（中间有一个空格）:\"&lt;&lt;endl; cin&gt;&gt;a&gt;&gt;b; while(gcd(a,26)!=1) &#123; cout&lt;&lt;\"输入的第一个参数无法求出解密密钥，请重新输入！\\n\"; cin&gt;&gt;a&gt;&gt;b; &#125; int ani=inverseGCD(a,26);//求逆元 cout&lt;&lt;\"逆元为：\"&lt;&lt;ani&lt;&lt;endl; i=0; while (i&lt;lenthofmessage) &#123; if (message[i]&gt;='A'&amp;&amp;message[i]&lt;='Z') jiemimiwen[i]='A'+ani*(message[i]-'A'-b+26)%26; else if (message[i]&gt;='a'&amp;&amp;message[i]&lt;='z') jiemimiwen[i]='a'+ani*(message[i]-'a'-b+26)%26; else if (message[i]==' ') jiemimiwen[i]=' '; else jiemimiwen[i]=message[i]; i++; &#125; jiemimiwen[i]='\\0'; cout&lt;&lt;\"解密得到的明文为：\"; cout&lt;&lt;jiemimiwen&lt;&lt;endl&lt;&lt;endl; &#125;int main() &#123; cout&lt;&lt;\"=========== Hill 密码 ===========\\n\"; cout&lt;&lt;\"= =\\n\"; cout&lt;&lt;\"= =\\n\"; cout&lt;&lt;\"= =\\n\"; cout&lt;&lt;\"= =\\n\"; cout&lt;&lt;\"= =\\n\"; cout&lt;&lt;\"= 信安1904 马博宇 =\\n\"; cout&lt;&lt;\"=================================\\n\"; while(1) &#123; mt(message,0,sizeof(message)); mt(ciphertext,0,sizeof(ciphertext)); mt(jiemimiwen,0,sizeof(jiemimiwen)); cout&lt;&lt;\"请选择需要：1、加密 2、解密（输入1为加密，2为解密,-1为退出程序）：\"&lt;&lt;endl; cin&gt;&gt;x; if(x==1) &#123; cout&lt;&lt;\"请选择是否从文件输入（输入1为是，0为否,-1为退出程序）：\"&lt;&lt;endl; cin&gt;&gt;y; if(y==1) &#123; FILE *file1; file1=fopen(\"plaintext.txt\",\"r\"); fgets(message,50,file1); &#125; else if(y==-1) return 0; encrypt(message); &#125; else if(x==2) &#123; cout&lt;&lt;\"请选择是否从文件输入（输入1为是，0为否,-1为退出程序）：\"&lt;&lt;endl; cin&gt;&gt;y; if(y==1) &#123; FILE *file1; file1=fopen(\"ciphertext.txt\",\"r\"); fgets(message,50,file1); &#125; else if(y==-1) return 0; else decrypt(message); &#125; else if(x==-1) return 0; &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://brillianttt.gitee.io/tags/RSA/"},{"name":"仿射密码","slug":"仿射密码","permalink":"https://brillianttt.gitee.io/tags/%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81/"},{"name":"密码学","slug":"密码学","permalink":"https://brillianttt.gitee.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"出去玩拍的一些皂片","slug":"出去玩拍的一些皂片","date":"2020-08-24T10:47:15.000Z","updated":"2020-08-24T10:47:18.090Z","comments":true,"path":"2020/08/24/出去玩拍的一些皂片/","link":"","permalink":"https://brillianttt.gitee.io/2020/08/24/%E5%87%BA%E5%8E%BB%E7%8E%A9%E6%8B%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9A%82%E7%89%87/","excerpt":"","text":"唱K 打球 逛动物园 学习驾驶技能 烧烤！猜猜这个是啥哈哈哈哈哈哈看我找到了什么哈哈哈 打工当然还是要打工的 以及穿这个真的是像六十岁的老大爷风格吗哈哈哈😂","categories":[],"tags":[{"name":"照片","slug":"照片","permalink":"https://brillianttt.gitee.io/tags/%E7%85%A7%E7%89%87/"}]},{"title":"云吸猫系列","slug":"云吸猫系列","date":"2020-08-23T12:10:28.000Z","updated":"2020-08-23T15:48:45.391Z","comments":true,"path":"2020/08/23/云吸猫系列/","link":"","permalink":"https://brillianttt.gitee.io/2020/08/23/%E4%BA%91%E5%90%B8%E7%8C%AB%E7%B3%BB%E5%88%97/","excerpt":"","text":"这个假期都没怎么发辛巴的照片，这里一次发个够好了😎（因为懒得用p图软件把图都拼到一起了所以就一并发了哈哈哈哈哈哈哈） 日常占我的床：最近抓拍的 注意右侧脸颊哈哈哈他太胖了他的眼屎我真的一拍完就给他处理了！是谁的猪猪男孩呀~迄今为止自认为最有气质的几张没想到吧哈哈哈哈哈哈哈哈哈哈哈哈接下来是嫌弃三连哈哈哈哈哈哈哈哈哈再然后是一些很妖娆的姿势👀再来些可可爱爱的😄最后再来一些随拍hiahiahia这个其实是在打呵欠哈哈哈哈，正好被我抓拍到了这仨是视频中截的图，有没有点像哥斯拉哈哈哈 写在最后： 辛巴其实是我养的第三只猫，之前领养的两只猫猫因为特殊原因实在养不了了，最后托付给了能善待他们的新主人。真心对这两只可爱猫猫的主人说一声对不起，我没有将他们一直养下去，他们都是非常非常非常可爱的猫，身体健康，也十分活泼，希望他们能一直快乐的生活。 最后的最后！说了一个假期要来偷猫的人！一个来偷的都没有哼！我都准备好和你们斗智斗勇了哈哈哈","categories":[],"tags":[{"name":"猫","slug":"猫","permalink":"https://brillianttt.gitee.io/tags/%E7%8C%AB/"},{"name":"照片","slug":"照片","permalink":"https://brillianttt.gitee.io/tags/%E7%85%A7%E7%89%87/"}]},{"title":"一份小总结","slug":"一份小总结","date":"2020-08-23T11:44:12.000Z","updated":"2020-08-23T16:08:03.448Z","comments":true,"path":"2020/08/23/一份小总结/","link":"","permalink":"https://brillianttt.gitee.io/2020/08/23/%E4%B8%80%E4%BB%BD%E5%B0%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"这些照片因为我非常特别very poor的技术。。。很多图片内存比较大发上来手机显示不了或者显示速度过慢，要是方便的话可以拿电脑访问，电脑能看所有图片！ 云吸猫系列传送门一号 出去玩拍的一些皂片传送门二号","categories":[],"tags":[{"name":"Summer summary","slug":"Summer-summary","permalink":"https://brillianttt.gitee.io/tags/Summer-summary/"}]},{"title":"简单数学知识","slug":"简单数学知识","date":"2020-07-15T11:30:22.000Z","updated":"2020-10-12T12:50:36.749Z","comments":true,"path":"2020/07/15/简单数学知识/","link":"","permalink":"https://brillianttt.gitee.io/2020/07/15/%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/","excerpt":"","text":"模运算取模运算的三个公式： (a+b)%m=((a%m) + (b%m))%m (a+b)%m=((a%m) + (b%m))%m (a*b)%m=((a%m) * (b%m))%m 快速幂如2^11可以转换为2^1 * 2^2 * 2^8 而指数11转换为二进制为1011，11可表示为2^0+2^1+2^3 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll fast_pow(ll a,ll n)&#123; ll base=a;//是个变量 ll res=1;//答案 while(n&gt;0) &#123; if(n&amp;1) res*=base; base=base*base; n&gt;&gt;=1;//向右移动一位 &#125; return res;&#125;int main()&#123; cout&lt;&lt;fast_pow(2,11)&lt;&lt;endl; &#125; 如果计算大数的幂次的话，可以求它的余数 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;typedef long long ll;ll fast_pow(ll a,ll n,ll M)&#123; ll base=a;//是个变量 ll res=1;//答案 while(n&gt;0) &#123; if(n&amp;1) res=res*base%M; base=base*base%M; n&gt;&gt;=1;//向右移动一位 &#125; return res;&#125;int main()&#123; int M=10; cout&lt;&lt;fast_pow(2,11,M)&lt;&lt;endl; &#125; 埃筛，线性筛(欧拉筛)首先是埃拉托斯特尼筛法： 这是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint prime[20000];int len;int main() &#123; int n; cin&gt;&gt;n; int book[20000]; memset(book,0,sizeof(book)); for(int i=2;i&lt;=n;i++) &#123; if(!book[i]) &#123; prime[len++] = i; for(int j=2*i;j&lt;=n;j+=i) &#123;//每次把这个数的倍数标记 book[j] = 1; &#125; &#125; &#125; /*for(int i=0;i&lt;len;i++) &#123; cout&lt;&lt;prime[i]&lt;&lt;endl; &#125;*/&#125; 埃筛其实还是有一些重复：许多数被重复标记，比如：10既被2标记过，又被5标记过。 接下来是线性筛：线性筛的优化主要在于每个数只被筛过一次 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint prime[20000];int len;int main() &#123; int n; cin&gt;&gt;n; int book[20000]; memset(book,0,sizeof(book)); for(int i=2;i&lt;=n;i++) &#123; if(!book[i]) &#123; prime[len++] = i; &#125; for(int j=0;j&lt;len;j++) &#123; if(i*prime[j]&gt;n) break; book[i*prime[j]] = 1; if(i%prime[j]==0)//使每个合数只被它的最小质因数标记 break; &#125; &#125; /*for(int i=0;i&lt;len;i++) &#123; cout&lt;&lt;prime[i]&lt;&lt;endl; &#125;*/&#125; 附上一个链接,这位大大写的很详细。 唯一分解定理每个大于1的自然数均可写为质数的积，而且这些素因子按大小排列之后，写法仅有一种方式。 当题目有大数相除，求余数且精度要求高时，就要运用唯一分解定律 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;const int maxn=10000+5;int e[maxn]; //用e[]保存每一位素数的系数vector&lt;int&gt; primes;void GetPrime()&#123; int n[10000]=&#123;0&#125;; for(int i=2;i&lt;=sqrt(10000+0.5);i++) if(!n[i]) for(int j=i*i;j&lt;=10000;j+=i) n[j]=1; for(int i=2;i&lt;=10000;i++) if(!n[i]) primes.push_back(i);&#125;void add_int(int n,int d)&#123; for(int i=0;i&lt;primes.size()&amp;&amp;n!=1;i++) while(n%primes[i]==0) &#123; n/=primes[i]; e[i]+=d; &#125;&#125;int main() &#123; GetPrime(); //求出素数 int n, p; cin &gt;&gt; n; add_int(n, 1); //乘以n; p = 0; for (int i = 0; i &lt; primes.size(); i++) if (e[i]) &#123; if (p) cout &lt;&lt; '*'; cout &lt;&lt; primes[i] &lt;&lt; '^' &lt;&lt; e[i]; if (!p) p = 1; &#125; cout &lt;&lt; endl; cin &gt;&gt; n; add_int(n, -1); //除以n; p = 0; for (int i = 0; i &lt; primes.size(); i++) if (e[i]) &#123; if (p) cout &lt;&lt; '+'; cout &lt;&lt; primes[i] &lt;&lt; '^' &lt;&lt; e[i]; if (!p) p = 1; &#125; return 0;&#125;/*运行效果：10002^3*5^352^3+5^2*/ 扩展欧几里得算法扩展欧几里得算法用于求取二元一次方程的整数解。（如：ax+by=cax+by=c，x,yx,y为未知数） 在学习扩展欧几里得算法前要先知道欧几里得算法，也就是辗转相除法 辗转相除法：定义：两个数a,ba,b的最大公因数gcd(a,b) = gcd(b,a \\bmod b)，a &gt; bgcd(a,b)=gcd(b,amodb)，a&gt;b例如：99和1212的最大公因数为33，gcd(12,9)=gcd(9,3)=gcd(3,0)=3gcd(12,9)=gcd(9,3)=gcd(3,0)=3。 1234567int gcd(int a, int b) &#123; //return (b == 0)? a : gcd(b, a % b); if (b == 0) return a; else return gcd(b, a % b);&#125; 扩展欧几里得定理:附上关键代码： 123456789101112int Exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; int d = Exgcd(b, a % b, x, y); int t = x;//以下三行是经过数学推导出的结果 x = y; y = t - (a / b) * y; return d;&#125; 再附上一个例题和讲解的链接。 素数定理素数定理（prime number theorem）是素数分布理论的中心定理，是关于素数个数问题的一个命题： 设x≥1，以π(x)表示不超过x的素数的个数，当x→∞时，π(x)Li(x)或π(x)x/ln(x)。（Li(x)为对数积分） 根据推导即有π(x)~x/ln(x)，利用素数定理，可以解决一些看起来很难的c语言题目，比如说这个。先补充一下c语言对数函数的使用： 123456789#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; printf(\"%f\\n\",log(10)); //以e为底的对数函数 printf(\"%f\\n\",log10(100)); //以10为底的对数函数 printf(\"%f\\n\",log(8)/log(2)); //计算log2^8,运用换底公式 printf(\"%f\\n\",exp(1)); //计算自然常数e return 0;&#125; 要计算素数个数的位数，我们还需要一个计算数字位数的公式：n=lg(x)+1，结合素数定理的结论和位数公式就可推导得出答案。 然后附上题解： 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main() &#123; int n; while(cin&gt;&gt;n) &#123; if(n==1||n==2) &#123; cout&lt;&lt;n&lt;&lt;endl; &#125; else &#123; int m=double(n-log10(n)-log10(log(10)));//经过数学推导得出 cout&lt;&lt;m+1&lt;&lt;endl; &#125; &#125; return 0;&#125; 再举一个栗子有了上一题的思路，这一题可以很快想到利用lg(x)+1的方法去计算，而n!=123···n，带回到lg(x)+1中也可以求解。 但是吧。。。凡是都有例外，这个题就不行，因为用对数函数去求还不是最快的方法，还可以运用斯特林公式求解，具体如下： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define e 2.718281828459045#define pi 3.141592653589793239using namespace std;int main ()&#123; int n; while ( cin&gt;&gt;n;) &#123; ciun&gt;&gt;n; double t = log10(sqrt(2*pi*n)) + n * log10(n/e); printf (\"%d\\n\",(int)t + 1); &#125;return 0;&#125; 斯特林公式：log(n!) = log10(sqrt(2pin)) + n*log10(n/e)","categories":[{"name":"数学","slug":"数学","permalink":"https://brillianttt.gitee.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://brillianttt.gitee.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"0-1背包问题","slug":"0-1背包问题","date":"2020-07-09T14:30:33.000Z","updated":"2020-07-13T01:16:35.842Z","comments":true,"path":"2020/07/09/0-1背包问题/","link":"","permalink":"https://brillianttt.gitee.io/2020/07/09/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"首先两个概念： 背包问题：有某些物品，每个物品有一个重量w[i],价值v[i]，现在有一个容量为t的背包，问这个背包能存放的物品的价值和最大时多少？ 01背包问题：有n个物品，每一个物品有一个重量w[i]，价值v[i],现在有一个容量为t的背包，问这个背包的能存放的物品的价值和最大是多少？ dp实现dp[i][j],前i个物品，容量为j的背包，所能存放的物品的最大价值是多少。 举个栗子： i 1 2 3 4 5 w 2 3 2 4 1 v 3 2 4 6 3 栗子的解释👇 其中i表示物品，j表示背包容量 dp[0][j]=0，因为当没有物品时，无论有多的容量，也没有价值 j&gt;=w[i]: dp[i][j]=max(dp[i][j],dp[i-1][j-w[i]]+v[i]) 背包容量：j-w[i]-&gt;j-w[i]+w[i]-&gt;j 背包价值：dp[i-1][j-w[i]]+v[i] dp[i][j] 0 1 2 3 4 5 6 7 8 i=0 0 0 0 0 0 0 0 0 0 i=1,w=2,v=3 0 0 3 3 3 3 3 3 3 i=2,w=3,v=2 0 0 3 3 3 3+2=5 3 3 3 i=3,w=2,v=4 0 0 4 4 3+4=7 7 7 9 9 i=4,w=4,v=6 0 0 4 4 7 7 4+6=10 10 7+6=13 i=5,w=1,v=3 0 3 3 7 7 7+3=10 10 13 13 例1：采药问题这是题目链接 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e3+5;int main()&#123; int t,m; cin&gt;&gt;t&gt;&gt;m; int w[maxn],v[maxn]; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; int dp[105][1005]=&#123;0&#125;; for(int i=1;i&lt;=m;i++) for(int j=0;j&lt;=t;j++) &#123; dp[i][j]=dp[i-1][j]; if(j&gt;=w[i]) &#123; dp[i][j]=max(dp[i][j],dp[i-1][j-w[i]]+v[i]);//状态转移方程 &#125; &#125; cout&lt;&lt;dp[m][t]; return 0;&#125; 将上面的代码做一个滚动优化： 根据状态转移方程，当前状态只和其前一个状态有关，所以只需使用dp[2][x]。 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e3+5;int main()&#123; int t,m; cin&gt;&gt;t&gt;&gt;m; int w[maxn],v[maxn]; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; int dp[2][1005]=&#123;0&#125;;//占用空间减小了 for(int i=1;i&lt;=m;i++) &#123; int p=i&amp;1;//如果i是奇数p=1，否则p=0 for(int j=0;j&lt;=t;j++) &#123; dp[p][j]=dp[!p][j]; if(j&gt;=w[i]) &#123; dp[p][j]=max(dp[p][j],dp[!p][j-w[i]]+v[i]);//状态转移方程 &#125; &#125; &#125; cout&lt;&lt;dp[m&amp;1][t]; return 0;&#125; 用一维dp再优化下： 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e3+5;int main()&#123; int t,m; cin&gt;&gt;t&gt;&gt;m; int w[maxn],v[maxn]; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; int dp[1005]=&#123;0&#125;;//换成了一维数组 for(int i=1;i&lt;=m;i++) &#123; for(int j=t;j&gt;=0;j+--)//这里的j&gt;=0可以换成j&gt;=w[i],下面的if语句就也可以去掉了 &#123; dp[j]=dp[j]//这句其实没用，就是对照下二维dp的dp[i][j]=dp[i-1][j] if(j&gt;=w[i]) &#123; dp[j]=max(dp[j],dp[j-w[i]]+v[i]); &#125; &#125; &#125; cout&lt;&lt;dp[t]; return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"暑假学习","slug":"暑假学习","permalink":"https://brillianttt.gitee.io/tags/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0/"},{"name":"0-1背包问题","slug":"0-1背包问题","permalink":"https://brillianttt.gitee.io/tags/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"}]},{"title":"阶段小结","slug":"阶段小结","date":"2020-07-07T13:26:27.000Z","updated":"2020-07-07T14:01:56.729Z","comments":true,"path":"2020/07/07/阶段小结/","link":"","permalink":"https://brillianttt.gitee.io/2020/07/07/%E9%98%B6%E6%AE%B5%E5%B0%8F%E7%BB%93/","excerpt":"","text":"明天是高考第二天，也是我加入的acm实验室的第一天暑期集训，想在今天做一个最近的小总结，也希望不留下遗憾，过好这个暑假。这个博客是在今年寒假开始的时候好朋友帮助我搭建的，现在只能在界面以及主题方面做一些细微的修改，主要用来记录学习笔 记，偶尔也分享一些生活小事，就当这里是我的“秘密基地”吧！ 今天实验室的老师在开会时也对我们学习方面的事情做了一些较严厉的批评，也是给我们这群刚考完试的准大二学生敲响了警钟，留给自己努力的时间不多了，马上要来到的暑假培训、补大一没有学的课程、准备12月的六级考试、学习html、考驾照、减掉这个学期和寒假多出来的20斤五花肉、重新巩固（or预习）高数的知识balabala，这些任务很重要，并且都是必须要做的事情，将这些事情都展开了说是希望自己能好好努力，不再浪费这段时间，能踏踏实实的过完这个暑假，在今年九月开学的时候，做个像样的大学生。 最近这段时间收获还是不小的，上一周安排的很紧凑：每天上午学车，下午模拟或者考试，晚上继续复习或者写代码，再加上每天来回30km的遥远路途，也算是被小小的摧残了下~ 结果还是比较不错的，数学、物理、线代的成绩也还算ok，科二补考也过了（虽然第一把没系安全带直接挂了，but问题不大）。 写到这里好像也没有什么其他想说的了，简单感慨下继续努力叭，希望自己能不浪费这个暑假，好好去努力！！ 哦对了！！如果有明天还高考的小伙伴恰好今晚也看到了这个blog，想对你们再说一句加油！理综选择可得认真嗷，六分一个，不能随随便便就扔了嗷。加油加油，晚安早睡😴","categories":[],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"bfs例题","slug":"bfs例题","date":"2020-06-07T03:45:50.462Z","updated":"2020-06-09T15:51:20.561Z","comments":true,"path":"2020/06/07/bfs例题/","link":"","permalink":"https://brillianttt.gitee.io/2020/06/07/bfs%E4%BE%8B%E9%A2%98/","excerpt":"","text":"走迷宫题意：从入口走到出口输入：地图、起始位置、出口位置输出：最少走几步代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;using namespace std;struct note&#123; int x,y;//横、纵坐标 //int f;//父亲在队列中的编号，本题不需要 int s;//步数&#125;;int a[51][51],book[51][51];//用来记录地图和标记地图上的点是否走过int main()&#123; note que[2501];//地图大小不超过50*50，所以扩展大小不超过2500 int next[4][2]=&#123;&#123;0,1&#125;, &#123;1,0&#125;, &#123;0,-1&#125;, &#123;-1,0&#125; &#125;;//方位 int head,tail;队列的头部和尾部 int i,j,k,n,m,startx,starty,p,q,tx,ty,flag; cin&gt;&gt;n&gt;&gt;m;//输入地图大小 for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) cin&gt;&gt;a[i][j];//输入地图 cin&gt;&gt;startx&gt;&gt;starty&gt;&gt;p&gt;&gt;q;//输入起始坐标和终点坐标 //队列初始化 head=1; tail=1; //向队列插入迷宫入口坐标 que[tail].x=startx; que[tail].y=starty; //que[tail].f=0; que[tail].s=0;//在起点时步数为零 tail++;//尾部增加一个扩展 book[startx][starty]=1;//标记现在所处位置已经走过 flag=0;//用来标记是否到达目标点，0表示暂时还没到，1表示已经到达 //当队列不为空的时候循环 while(head&lt;tail) &#123; //枚举四个方向 for(k=0;k&lt;4;k++) &#123; tx=que[head].x+next[k][0]; ty=que[head].y+next[k][1]; if(tx&lt;1||tx&gt;n||ty&lt;1||ty&gt;m)//判断是否越界 &#123; continue; &#125; if(a[tx][ty]==0&amp;&amp;book[tx][ty]==0) &#123; book[tx][ty]=1;//标记已经走过 que[tail].x=tx;//更新现在所处位置 que[tail].y=ty; //que[tail].f=head; que[tail].s=que[head].s+1;//步数加一 tail++; &#125; //如果到了目标点，停止扩展，任务结束，退出循环 if(tx==p&amp;&amp;ty==q) &#123; flag=1; break; &#125; &#125; if(flag==1) break; head++;//不能去掉，当一个点扩展结束后，head++才能对后面的点再扩展 &#125; cout&lt;&lt;que[tail-1].s; return 0;&#125; 又一个走迷宫这里是题目链接。直接上代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;using namespace std;struct note//模拟队列&#123; int x,y; int step=0;//步数&#125;que[10005];char maze[101][101];//迷宫bool vis[101][101];//判断是否走过int main()&#123; int next[4][2]=&#123;0,1,1,0,0,-1,-1,0&#125;;//模拟往四个方向走 int head=1,tail=1,tx,ty,n,m,flag=0; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) &#123; cin&gt;&gt;maze[i][j];//输入地图 if(maze[i][j]=='B')//记录下起点坐标 &#123; que[head].x=i; que[head].y=j; tail++; vis[i][j]=1; &#125; &#125; while(head&lt;tail)//遍历地图 &#123; for(int k=0;k&lt;4;k++) &#123; tx=que[head].x+next[k][0]; ty=que[head].y+next[k][1]; if(tx&gt;=0&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;m&amp;&amp;vis[tx][ty]==0&amp;&amp;maze[tx][ty]=='.')//如果不越界且可以走 &#123; que[tail].x=tx;//将此时的坐标加入队列 que[tail].y=ty; que[tail].step=que[head].step+1;//在当前根节点的步数基础上多走一步 tail++; vis[tx][ty]=1;//标记已经走过 &#125; if(maze[tx][ty]=='C')//如果找到终点 &#123; que[tail].step=que[head].step+1;//步数一 flag=1;//标记找到终点 break;//溜了 &#125; &#125; if(flag==1) break;//继续溜 head++; &#125; cout&lt;&lt;que[tail].step;//输出当前步数 return 0;//溜走了 //注意在没到终点时每一次tail都要加一，找到了就不用加了，只在当前tail下step++即可，最后输出。&#125; 用队列写走迷宫这是一个例题. ac代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;char maze[105][105];int vis[105][105];typedef struct point//用结构体记录当前的点以及移动的步数&#123; int x; int y; int dis=0;&#125;p;queue&lt;point&gt;Q;p start,End,temp,tmp;int main()&#123; int n,m,i,j,ans=0,tx,ty,flag=0; int next[4][2]=&#123;&#123;0,1&#125;, &#123;1,0&#125;, &#123;0,-1&#125;, &#123;-1,0&#125; &#125;; scanf(\"%d %d\",&amp;n,&amp;m); for(i=0;i&lt;n;i++) &#123; scanf(\"%s\",maze[i]); &#125; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; if(maze[i][j]=='B') &#123; start.x=i; start.y=j; start.dis=0;//初始点步数为0 &#125; else if(maze[i][j]=='C') &#123; End.x=i; End.y=j; &#125; &#125; &#125; Q.push(start);//将起点压入队列 vis[start.x][start.y]=1;//标记已经走过 while(!Q.empty()) &#123; temp=Q.front();//获得队首元素 Q.pop();//将队首出队 for(int k=0;k&lt;4;k++) &#123; tx=temp.x+next[k][0]; ty=temp.y+next[k][1]; if(tx&gt;=0&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;m&amp;&amp;maze[tx][ty]=='.'&amp;&amp;!vis[tx][ty]) &#123; tmp.x=tx;tmp.y=ty;tmp.dis=temp.dis+1; Q.push(tmp);//将满足条件的点压入队列 vis[tx][ty]=1;//标记已经走过 &#125; if(tx==End.x&amp;&amp;ty==End.y) &#123; //因为在上一个if语句里没有判断是否走到终点的情况，所以此处若走到了终点， //则步数应该为上一个temp节点（也就是本轮while循环的head节点）的步数加一。 ans=temp.dis+1; flag=1; break; &#125; &#125; if(flag==1) break; &#125; printf(\"%d\",ans); return 0;&#125; 宝岛探险题意：给出一个n*m大小的地图，0表示海，1~9表示小岛，数字越大岛越重要，现在给出起点坐标，问所在岛屿有多大。(视起始坐标上下左右相邻的区域为同一个岛屿)输入：地图大小，起始坐标输出：岛屿大小代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;struct node&#123; int x,y;&#125;que[2501];bool book[51][51]=&#123;0&#125;;int maze[51][51];int main()&#123; int head,tail; int sum=0,n,m,startx,starty,tx,ty; int next[4][2]=&#123;0,1,1,0,0,-1,-1,0&#125;; cin&gt;&gt;n&gt;&gt;m&gt;&gt;startx&gt;&gt;starty; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;maze[i][j]; head=1; tail=1; que[tail].x=startx; que[tail].y=starty; tail++; book[startx][starty]=1; sum=1; while(head&lt;tail) &#123; for(int k=0;k&lt;4;k++) &#123; tx=que[head].x+next[k][0]; ty=que[head].y+next[k][1]; if(tx&lt;1||tx&gt;n||ty&lt;1||ty&gt;n) continue; if(maze[tx][ty]&gt;0&amp;&amp;book[tx][ty]==0) &#123; sum++; book[tx][ty]=1; que[tail].x=tx; que[tail].y=ty; tail++; &#125; &#125; head++; &#125; cout&lt;&lt;sum; return 0;&#125; 宝岛探险也可以用dfs做，理解起来也比较简单，具体实例在“dfs例题”中。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"https://brillianttt.gitee.io/tags/bfs/"}]},{"title":"dfs例题","slug":"dfs例题","date":"2020-06-05T03:34:51.000Z","updated":"2020-09-03T12:04:13.905Z","comments":true,"path":"2020/06/05/dfs例题/","link":"","permalink":"https://brillianttt.gitee.io/2020/06/05/dfs%E4%BE%8B%E9%A2%98/","excerpt":"","text":"输出全排列如何输出全排列呢，可以使用algirithm头文件下的next_permutation()函数偷懒，也可以使用今天我学的dfs实现，据说这种题型是dfs里最简单的一类，不禁让我怀疑自己的脑袋是不是一半水一半面哈哈哈。话不多说，看题！题意：给出一个数n，输出1~n的全排列（1&lt;=n&lt;=9).分析：不咋会分析，兄得们将就看，等我学会了再来补充。代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;int a[10],book[10],n;//因为c语言的全局变量在没有赋值以前默认为0，所以无需再赋初值void dfs(int step)//step表示现在站在第几个盒子里&#123; int i; if(step==n+1) &#123; //输出一种排列（1~n号盒子中的扑克牌编号） for(i=1;i&lt;=n;i++) cout&lt;&lt;a[i]; cout&lt;&lt;endl; return;//返回之前一步，即最近一次调用dfs函数的位置 &#125; //此时在第step个盒子前，按照1、2、3...n的顺序一一尝试 for(i=1;i&lt;=n;i++) &#123; //判断牌i是否在手上 if(book[i]==0)//book[i]等于0表示i号扑克牌在手上 &#123; //开始尝试使用扑克牌 a[step]=i;//将i号扑克牌放入第step个盒子中 book[i]=1;//将book[i]设为1，表示i号扑克牌已经不在手上 //第step个盒子已经放好了牌，接下来要走到下一个盒子面前 dfs(step+1);//进行递归调用，这里需要仔细思考 book[i]=0;//这一步也很重要，是将刚才尝试的牌收回，再进行下一次尝试 &#125; &#125; return;&#125;int main()&#123; cin&gt;&gt;n;//输入要注意n为1~9之间的整数 dfs(1);//开始站在第一个小盒子前 return 0;&#125; 输出组合排列与组合是常用的数学方法，其中组合就是从n个元素中抽出r个元素(不分顺序且r &lt; ＝ n)，我们可以简单地将n个元素理解为自然数1，2，…，n，从中任取r个数。现要求你不用递归的方法输出所有组合。例如n ＝ 5 ，r ＝ 3 ，所有组合为：1 2 31 2 41 2 51 3 41 3 51 4 52 3 42 3 52 4 53 4 5输入：一行两个自然数n、r ( 1 &lt; n &lt; 21，1 &lt; ＝ r &lt; ＝ n )输出：所有的组合，每一个组合占一行且其中的元素按由小到大的顺序排列，所有的组合也按字典顺序。代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;int n,r,a[25];bool vis[25];// 来记录各个数字是否被访问using namespace std;void dfs (int dep)//dep代表搜索的深度，即当前数组a添加了多少个数&#123; for (int i=a[dep-1]+1;i&lt;=n;++i)//从上一个添加的数+1开始搜索数字 &#123; if (!vis[i])//如果这个数字没被访问过 &#123; a[dep]=i;//将这个数字添加到a里面去 if (dep==r)//如果添加的数字达到r个，把他们输出 &#123; int j; for ( j=1;j&lt;r;++j) printf(\"%d \",a[j]); printf(\"%d\\n\",a[j]); &#125; else dfs(dep+1);//如果达不到r个继续添加 vis[i]=0;//回溯，清空当前状态，把vis[i]设为没有访问过。 &#125; &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;r); dfs(1);//写成dfs很巧妙 return 0;&#125;/* Time:12 ms Memory:1696 kb*/ 走迷宫输入：迷宫地图、起点坐标、出口坐标输出：最少走多少步 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;using namespace std;int p,q,m,n,minx=99999999;int book[51][51],a[51][51];void dfs(int x,int y,int step)&#123; int next[4][2]&#123; &#123;0,1&#125;,//向右 &#123;1,0&#125;,//向下 &#123;0,-1&#125;,//向左 &#123;-1,0&#125;//向上 &#125;;//用行列表示，而不是坐标 int tx,ty;//记录当前位置 if(x==p &amp;&amp; y==q) &#123; if(step&lt;minx) minx=step; return; &#125; //枚举四种走法 for(int i=0;i&lt;=3;i++) &#123; //模拟上下左右移动 tx=x+next[i][0]; ty=y+next[i][1]; //判断是否越界 if(tx&lt;1||tx&gt;n||ty&lt;1||ty&gt;m) continue; //判断该点是否为障碍物或者已经在路径中 if(a[tx][ty]==0&amp;&amp;book[tx][ty]==0) &#123; book[tx][ty]=1;//标记这个点已经走过 dfs(tx,ty,step+1);//开始尝试下一个点 book[tx][ty]=0;//尝试结束，取消这个点的标记 &#125; &#125; return;&#125;int main()&#123; int startx,starty; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; cin&gt;&gt;a[i][j];//输入迷宫 &#125; cin&gt;&gt;startx&gt;&gt;starty&gt;&gt;p&gt;&gt;q;//输入起点和终点坐标 //开始搜索 book[startx][starty]=1;//标记起点已经在路径中，防止后面重复走 dfs(startx,starty,0);//最开始步数为0 cout&lt;&lt;minx; return 0; /*例： 5 4 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 输出：7 */&#125; 宝岛探险类型一：题意：给出一个n*m大小的地图，0表示海，1~9表示小岛，数字越大岛越重要，现在给出起点坐标，问所在岛屿有多大。(视起始坐标上下左右相邻的区域为同一个岛屿)输入：地图大小，起始坐标输出：岛屿大小代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;using namespace std;int maze[51][51];bool vis[51][51];int n,m,sum;void dfs(int x,int y)&#123; //定义一个方向数组 int next[4][2]=&#123;0,1,1,0,0,-1,-1,0&#125;; int tx,ty; for(int k=0;k&lt;4;k++) &#123; tx=x+next[k][0]; ty=y+next[k][1]; if(tx&lt;0||tx&gt;=n||ty&lt;0||ty&gt;=m) continue; //判断是否是陆地 if(maze[tx][ty]&gt;0&amp;&amp;vis[tx][ty]==0) &#123; sum++; vis[tx][ty]=1;//标记已经走过 dfs(tx,ty);//开始尝试下一个点 &#125; &#125; return;&#125;int main()&#123; int startx,starty; cin&gt;&gt;n&gt;&gt;m&gt;&gt;startx&gt;&gt;starty; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;maze[i][j]; vis[startx][starty]=1;//标记起点已经走过 sum=1; //从起点开始遍历 dfs(startx,starty); //最后输出所在岛屿大小 cout&lt;&lt;sum; return 0; /* 样例输入： 10 10 6 8 1 2 1 0 0 0 0 0 2 3 1 0 1 0 1 1 1 0 1 1 1 0 1 0 1 1 1 1 0 1 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 1 1 1 0 0 1 1 1 0 1 1 1 1 0 0 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 0 0 0 0 0 1 1 1 1 0 1 2 0 0 0 0 0 0 0 0 1 0 样例输出：38 */ &#125; 在本题中，如果斜着连在一起也算同一个小岛，则在遍历部分的循环则有必要变成这样： 12345678for(int dx=-1;dx&lt;=1;dx++) for(int dy=-1;dy&lt;=1;dy++) &#123; tx=x+dx; ty=y+dy; if(balabala) dfs(tx,ty); &#125; 类型二：题意：地图同上，判断地图中有多少个独立的小岛。思路：对每一个大于零的点进行深度优先搜索，因为等于零的点是海洋，小于零的点已经被标记，我们可以从(0,0)开始，一直枚举到(n,m)，对每个点进行尝试。代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;using namespace std;int maze[51][51];bool vis[51][51];int n,m;void dfs(int x,int y,int color)&#123; //定义一个方向数组 int next[4][2]=&#123;0,1,1,0,0,-1,-1,0&#125;; int tx,ty; maze[x][y]=color; for(int k=0;k&lt;4;k++) &#123; tx=x+next[k][0]; ty=y+next[k][1]; if(tx&lt;0||tx&gt;=n||ty&lt;0||ty&gt;=m) continue; //判断是否是陆地 if(maze[tx][ty]&gt;0&amp;&amp;vis[tx][ty]==0) &#123; vis[tx][ty]=1;//标记已经走过 dfs(tx,ty,color);//开始尝试下一个点 &#125; &#125; return;&#125;int main()&#123; int num=0; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;maze[i][j]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(maze[i][j]&gt;0) &#123; num--;//小岛需要染的颜色的编号 //每发现一个小岛应该染以不同的颜色，因此每次要-1 vis[i][j]=1; dfs(i,j,num); &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=1;j&lt;m;j++) &#123; printf(\"%3d\",maze[i][j]);//输出小岛地图 &#125; cout&lt;&lt;endl; &#125; //最后输出所在岛屿的个数 cout&lt;&lt;-num; return 0; /* 样例输入： 10 10 1 2 1 0 0 0 0 0 2 3 1 0 1 0 1 1 1 0 1 1 1 0 1 0 1 1 1 1 0 1 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 1 1 1 0 0 1 1 1 0 1 1 1 1 0 0 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 0 0 0 0 0 1 1 1 1 0 1 2 0 0 0 0 0 0 0 0 1 0 样例输出： -1 -1 0 0 0 0 0 -2 -2 0 -1 0 -3 -3 -3 0 -2 -2 0 -1 0 -3 -3 -3 -3 0 -2 -1 0 0 0 -3 -3 -3 0 0 0 0 0 0 0 -3 -3 -3 0 -3 -3 -3 0 -3 -3 -3 -3 0 -3 -3 -3 -3 -3 -3 -3 -3 0 0 -3 -3 -3 -3 -3 -3 0 0 0 0 -3 -3 -3 -3 0 -4 -4 0 0 0 0 0 0 0 -4 0 4 */&#125; 最后附一个dfs的模板 12345678910111213141516171819202122232425void dfs()//参数用来表示状态 &#123; if(到达终点状态) &#123; ...//根据题意添加 return; &#125; if(越界或者是不合法状态) return; if(特殊状态)//剪枝 return ; for(扩展方式) &#123; if(扩展方式所达到状态合法) &#123; 修改操作;//根据题意来添加 标记； dfs（）； (还原标记)； //是否还原标记根据题意 //如果加上（还原标记）就是 回溯法 &#125; &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://brillianttt.gitee.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"https://brillianttt.gitee.io/tags/dfs/"}]},{"title":"链表的学习","slug":"链表的学习","date":"2020-06-04T14:19:06.000Z","updated":"2020-06-05T00:12:44.617Z","comments":true,"path":"2020/06/04/链表的学习/","link":"","permalink":"https://brillianttt.gitee.io/2020/06/04/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"果然专业课还是一点也不能水，上学期最后的指针没认真学，现在看书自学还得先补上学期的知识漏洞😑今天复习了指针的知识，还学习了一部分链表的内容，下面记录下今天的学习内容。 在存储一大波数的时候，我们通常使用的是数组，但有时候数组显得不够灵活，比如下面这个例子。有一串已经从小到大排好序的数 2 3 5 8 9 10 18 26 32。现需要往这串数中插入 6 使其得到的新序列仍符合从小到大排列。如我们使用数组来实现这一操作，则需要将8和8后面的数都依次往后挪一位，这样操作显然很耽误时间，如果使用链表则会快很多。 指针的复习先看以下语句： 12int a;int *p; 第一行我们很熟悉了，就是定义一个整型变量 a。第二行你会发现在 p 前面多了一个号，这就表示定义了一个整型指针变量 p。即定义一个指针，只需在变量前面加一个号就OK啦。接下来，指针有什么作用呢？答案是：存储一个地址。确切地说是存储一个内存空间的地址，比如说整型变量 a 的地址。严格地说这里的指针 p 也只能存储“一个存放整数的内存空间”的地址，因为在定义的时候我们已经限制了这一点（即定义的时候*p 的前面是 int）。当然你也可以定义一个只能用来存储“一个存放浮点数的内存空间”的地址，例如： 1double *p; 简单地说，指针就是用来存储地址的。你可能要问：不就是存储地址嘛，地址不都一样吗，为什么还要分不同类型的指针呢？不要着急，待会后面再解释。接下来需要解决的一个问题：整型指针 p 如何才能存储整型变量 a 的地址呢？很简单，如下： 1p=&amp;a; &amp;这个符号很熟悉吧，就是经常在 scanf 函数中用到的&amp;。&amp;叫取地址符。这样整型指针p就获得了（存储了）整型变量a的地址，我们可以形象地理解整型指针p指向了整型变量a。p指向了a之后，有什么用呢？用处就是我们可以用指针p来操作变量a了。比如我们可以通过操作指针p来输出变量a的值，如下： 12345678910#include &lt;stdio.h&gt; int main() &#123; int a=10; int *p; //定义个指针p p=&amp;a; //指针p获取变量a的地址 printf(\"%d\",*p); //输出指针p所指向的内存中的值 return 0; //输出10&#125; 这里 printf 语句里面p 中的号叫做间接运算符，作用是取得指针 p 所指向的内存中的值。在C语言中号有三个用途，分别是：乘号，用做乘法运算，例如 56。申明一个指针，在定义指针变量时使用，例如 int p;。间接运算符，取得指针所指向的内存中的值，例如 printf(“%d”,p);。 到目前为止，你可能还是觉得指针没啥子实际作用，好好的变量 a 想输出是的话直接printf(“%d”,a); 不完了，没事搞个什么指针啊，多此一举。嗯，到目前为止貌似是这样的O(∩_∩)O 哈哈~~不要着急，真枪实弹地来了。回想一下，我们想在程序中存储一个整数 10，除了使用 int a;这种方式在内存中申请一块区域来存储，还有另外一种动态存储方法: 1malloc(4) malloc 函数的作用就是从内存中申请分配指定字节大小的内存空间。上面这行代码就申请了 4 个字节。如果你不知道 int 类型是 4 个字节的，还可以使用 sizeof(int)获取 int 类型所占用的字节数，如下： 1malloc(sizeof(int)); 现在你已经成功地从内存中申请了 4 个字节的空间来准备存放一个整数，可是如何来对这个空间进行操作呢？这里我们就需要用一个指针来指向这个空间，即存储这个空间的首地址。 12int *p; p=(int *)malloc(sizeof(int)); 需要注意，malloc 函数的返回类型是 void * 类型。void * 表示未确定类型的指针。在 C 和 C++中，void * 类型可以强制转换为任何其他类型的指针。上面代码中我们将其强制转化为整型指针，以便告诉计算机这里的 4 个字节作为一个整体用来存放整数。还记得我们之前遗留了一个问题：指针就是用来存储内存地址的，为什么要分不同类型的指针呢？因为指针变量存储的是一个内存空间的首地址（第一个字节的地址），但是这个空间占用了多少个字节，用来存储什么类型的数，则是由指针的类型来标明的。这样系统才知道应该取多少个连续内存作为一个数据。OK，现在我们可以通过指针 p 对刚才申请的 4 个字节的空间进行操作了，例如我们向这个空间中存入整数 10，如下： 1*p=10; 完整代码如下，注意当在程序中使用 malloc 函数时需要用到 stdlib.h 头文件 1234567891011#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() &#123; int *p; //定义一个指针p p=(int *)malloc(sizeof(int)); //指针p获取动态分配的内存空间地址 *p=10; //向指针p所指向的内存空间中存入10 printf(\"%d\",*p); //输出指针p所指向的内存中的值 return 0; //输出10&#125; 链表基础的学习时间有限，直接上代码和注释： 使用链表进行读入123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //这里创建一个结构体用来表示链表的结点类型struct node &#123; int data; //吹村具体数值 struct node *next; //储存下一个节点的地址&#125;; int main() &#123; struct node *head,*p,*q,*t; int i,n,a; scanf(\"%d\",&amp;n); head = NULL;//头指针初始为空,头指针的作用是方便以后从头遍历整个链表 for(i=1;i&lt;=n;i++)//循环读入n个数 &#123; scanf(\"%d\",&amp;a); //动态申请一个空间，用来存放一个结点，并用临时指针p指向这个结点 p=(struct node *)malloc(sizeof(struct node)); p-&gt;data=a;//将数据存储到当前结点的data域中 p-&gt;next=NULL;//设置当前结点的后继指针指向空，也就是当前结点的下一个结点为空 if(head==NULL) head=p;//如果这是第一个创建的结点，则将头指针指向这个结点 else q-&gt;next=p;//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点 q=p;//指针q也指向当前结点 &#125; //输出链表中的所有数 t=head; while(t!=NULL) &#123; printf(\"%d \",t-&gt;data); t=t-&gt;next;//继续下一个结点 &#125; return 0; &#125; 上面的代码中我们发现了一个很奇怪的符号“-&gt;”。-&gt;叫做结构体指针运算符，也是用来访问结构体内部成员的。因为此处 p 是一个指针，所以不能使用.号访问内部成员，而要使用-&gt;。 链表实现数据的插入12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //这里创建一个结构体用来表示链表的结点类型struct node &#123; int data; struct node *next; &#125;; int main() &#123; struct node *head,*p,*q,*t; int i,n,a; scanf(\"%d\",&amp;n); head = NULL;//头指针初始为空 for(i=1;i&lt;=n;i++)//循环读入n个数 &#123; scanf(\"%d\",&amp;a); //动态申请一个空间，用来存放一个结点，并用临时指针p指向这个结点 p=(struct node *)malloc(sizeof(struct node)); p-&gt;data=a;//将数据存储到当前结点的data域中 p-&gt;next=NULL;//设置当前结点的后继指针指向空，也就是当前结点的下一个结点为空 if(head==NULL) head=p;//如果这是第一个创建的结点，则将头指针指向这个结点 else q-&gt;next=p;//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点 q=p;//指针q也指向当前结点 &#125; scanf(\"%d\",&amp;a);//读入待插入的数 t=head;//从链表头部开始遍历 while(t!=NULL)//当没有到达链表尾部的时候循环 &#123; if(t-&gt;next-&gt;data &gt; a)//如果当前结点下一个结点的值大于待插入数，将数插入到中间 &#123; p=(struct node *)malloc(sizeof(struct node));//动态申请一个空间， 用来存放新增结点 p-&gt;data=a; p-&gt;next=t-&gt;next;//新增结点的后继指针指向当前结点的后继指针所指向的结点 t-&gt;next=p;//当前结点的后继指针指向新增结点 break;//插入完毕退出循环 &#125; t=t-&gt;next;//继续下一个结点 &#125; //输出链表中的所有数 t=head; while(t!=NULL) &#123; printf(\"%d \",t-&gt;data); t=t-&gt;next;//继续下一个结点 &#125; return 0; &#125; 模拟链表链表中的每一个结点只有两个部分。我们可以用一个数组 data 来存储每序列中的每一个数。那每一个数右边的数是谁，这一点该怎么解决呢？上一节中是使用指针来解决的，所以只需再用一个数组right来存放序列中每一个数右边的数是谁就可以了：上图的两个数组中，第一个整型数组 data 是用来存放序列中具体数字的，另外一个整型数组right是用来存放当前序列中每一个元素右边的元素在数组data中位置的。例如right[1]的值为2，就表示当前序列中1号元素右边的元素存放在data[2]中；如果是 0，例如 right[9]的值为0，就表示当前序列中9号元素的右边没有元素。现在需要在8前面插入一个6，只需将6直接存放在数组data的末尾即data[10]=6。接下来只需要将right[3]改为10，表示新序列中3号元素右边的元素存放在data[10]中。再将right[10]改为4，表示新序列中10号元素右边的元素存放在data[4]中。这样我们通过right数组就可以从头到尾遍历整个序列了（序列的每个元素的值存放在对应的数组data中），如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt; int main() &#123; int data[101],right[101]; int i,n,t,len; //读入已有的数 scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++) scanf(\"%d\",&amp;data[i]); len=n; //初始化数组right for(i=1;i&lt;=n;i++) &#123; if(i!=n) right[i]=i+1; else right[i]=0; &#125; //直接在数组data的末尾增加一个数 len++; scanf(\"%d\",&amp;data[len]); //从链表的头部开始遍历 t=1; while(t!=0) &#123; if(data[right[t]]&gt;data[len])//如果当前结点下一个结点的值大于待插入数，将数插入到中间 &#123; right[len]=right[t];//新插入数的下一个结点标号等于当前结点的下一个结点编号 right[t]=len;//当前结点的下一个结点编号就是新插入数的编号 break;//插入完成跳出循环 &#125; t=right[t]; &#125; //输出链表中所有的数 t=1; while(t!=0) &#123; printf(\"%d \",data[t]); t=right[t]; &#125; return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://brillianttt.gitee.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"位运算的使用","slug":"位运算的使用","date":"2020-06-03T13:56:43.000Z","updated":"2020-06-09T14:32:30.729Z","comments":true,"path":"2020/06/03/位运算的使用/","link":"","permalink":"https://brillianttt.gitee.io/2020/06/03/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"这是一个关于位运算的链接。 这是一个关于位运算的例题。 这是👆题的题解。 补充： 1、i&lt;32是因为2^32-1的表示数为二进制的32个1，足可使用 2、x &lt;&lt; i 是指将x按照二进制左移i位，例如00000001，左移2位变成了00000100。移动后的数转化为十进制事实上是x*2^i。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://brillianttt.gitee.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"algorithm库的使用","slug":"algorithm库的使用","date":"2020-06-03T00:38:07.000Z","updated":"2020-09-03T08:48:04.786Z","comments":true,"path":"2020/06/03/algorithm库的使用/","link":"","permalink":"https://brillianttt.gitee.io/2020/06/03/algorithm%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"algorithm头文件下的常用函数max()、min()、abs()max(x,y)和min(x,y)分别返回x和y中的最大值和最小值。且参数必须是两个（可以是浮点数）。若想返回三个数x,y,z的最大值，可以使用max（x,max(y,z))的写法。abs(x)返回x的绝对值，此处x为整数，若使用浮点数的绝对值要用math库下的fabs()。 swap()swap()用来交换x和y的值 reverse()reverse(it,it2)可以将数组指针在[it,it2)之间的元素或容器的迭代器在[it,it2)范围内的元素进行反转，举例如下： 12345678910111213#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[10]=&#123;10,11,12,13,14,15&#125;; reverse(a,a+4); for(int i=0;i&lt;6;i++)&#123; printf(\"%d \",a[i]); &#125; return 0; //输出13 12 11 10 14 15&#125; 容器内举例如下： 1234567891011121314#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;int main()&#123; string str=\"hello world\"; reverse(str.begin(),str.end()); for(int i=0;i!=str.length;i++)&#123; printf(\"%c\",str[i]); &#125; return 0; //输出dlrow olleh&#125; next_permutation()next_permutation()给出一个序列在全排列中的下一个序列。例如，当n=3的时候，全排列为123 132 213 231 312 321.这样231的下一个序列就是312. 123456789101112#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[10]=&#123;1,2,3&#125;; do&#123; printf(\"%d%d%d\\n\",a[0],a[1],a[2]); &#125;while(next_permutation(a,a+3)); return 0; //输出123\\n132\\n213\\n231\\n312\\n321\\n&#125; 在上述代码中使用循环是因为next_permutation在已经到达全排列的最后一个时会返回false,这样会方便退出循环。 fill()fill()可以把数组或容器中的某一段区间赋为某个相同的值。和memset不同，这里的赋值可以是数组类型对应范围中的任意值。 1fill(a,a+5,233)//将a[0]~a[4]均赋值为233 sort()如何使用sort排序sort函数的使用必须加上#includeusing namespace std，使用方式如下： 1sort(首元素地址（必填），尾元素的下一个地址（必填），比较函数（非必填）)； 如果不写cmp函数，则默认对前面给出的区间进行递增排序。 实现比较函数cmp基本数据类型数组的排序若不写比较函数，则默认升序排序： 123456789101112#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std; int main()&#123; int a[5]=&#123;3, 1, 4, 2&#125;; sort(a,a + 4) ; for(int i=0;i&lt;4;i++)&#123; printf (\"%d\",a[i]); &#125;//输出1234return 0;&#125; 若想要从大到小排序，则需使用比较函数cmp来“告诉”sort何时要交换元素。 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std; int cmp(int a,int b)&#123; rerturn a&gt;b;//可以理解为当a&gt;b时把a放在b前面&#125;int main()&#123; int a[5]=&#123;3, 1, 4, 2&#125;; sort(a,a + 4，cmp) ; for(int i=0;i&lt;4;i++)&#123; printf (\"%d\",a[i]); &#125;//输出4321return 0;&#125; 结构体数组的排序12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;struct node&#123; int x,y;&#125; ssd[10];bool cmp (node a,node b) &#123; if (a.x!=b.x) return a.x&gt;b.x;//x不等时按x从大到小排序 else return a.y&lt;b.y; //x相等时按y从小到大排序&#125;int main()&#123; ssd[0].x=2; // (2, 2) ssd[0].y=2; ssd[1].x=1; // &#123;1, 3) ssd[1].y=3; ssd[2].x=3; // (3, 1) ssd[2].y=1; sort(ssd,ssd+3,cmp) ; //排序 for(int i=0;i&lt;3;i++) printf(\"%d %d\\n\",ssd[i].x,ssd[i].y); return 0; /*输出 3 1 2 2 1 3 */&#125; 容器的排序在stl标准容器中，只有vector、string、deque可以使用sort。因为像set、map这种容器使用红黑树实现的，元素本身有序，故不可使用sort排序。举例。。。就不举例了，大同小异。 lower_bound()和upper_bound()lower_bound()和upper_bound()需要用在一个有序数组或容器中。lower_bound(first,last,val)用来寻找在数组或容器的［first,last) 范围内第一个值大于等于val的元素的位置，如果是数组，则返回该位置的指针；如果是容器，则返回该位置的选代器。upper_bound(first,last,val) 用来寻找在数组或容器的［first,last) 范围内第一个值大于val的元素的位置，如果是数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器。显然，如果数组或容器中没有需要寻找的元素，则lower_bound()和upper_bound()均返回可以插入该元素的位置的指针或选代器（即假设存在该元素时，该元素应当在的位置）。举例如下： 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+10;const int INF=2*int(1e9)+10;#define LL long longint cmp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; int num[6]=&#123;1,2,4,7,15,34&#125;; sort(num,num+6); //按从小到大排序 int pos1=lower_bound(num,num+6,7)-num; //返回数组中第一个大于或等于被查数的值 int pos2=upper_bound(num,num+6,7)-num; //返回数组中第一个大于被查数的值 cout&lt;&lt;pos1&lt;&lt;\" \"&lt;&lt;num[pos1]&lt;&lt;endl; cout&lt;&lt;pos2&lt;&lt;\" \"&lt;&lt;num[pos2]&lt;&lt;endl; sort(num,num+6,cmp); //按从大到小排序 int pos3=lower_bound(num,num+6,7,greater&lt;int&gt;())-num; //返回数组中第一个小于或等于被查数的值 int pos4=upper_bound(num,num+6,7,greater&lt;int&gt;())-num; //返回数组中第一个小于被查数的值 cout&lt;&lt;pos3&lt;&lt;\" \"&lt;&lt;num[pos3]&lt;&lt;endl; cout&lt;&lt;pos4&lt;&lt;\" \"&lt;&lt;num[pos4]&lt;&lt;endl; return 0; &#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://brillianttt.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"库函数的使用","slug":"库函数的使用","permalink":"https://brillianttt.gitee.io/tags/%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/"}]},{"title":"code::blocks设置调试和主题背景","slug":"codeblocks设置调试和主题背景","date":"2020-06-02T00:48:11.732Z","updated":"2020-06-02T01:59:49.203Z","comments":true,"path":"2020/06/02/codeblocks设置调试和主题背景/","link":"","permalink":"https://brillianttt.gitee.io/2020/06/02/codeblocks%E8%AE%BE%E7%BD%AE%E8%B0%83%E8%AF%95%E5%92%8C%E4%B8%BB%E9%A2%98%E8%83%8C%E6%99%AF/","excerpt":"","text":"设置调试安装好Code::Block后完成编译和运行后却无法调试，弹出Error:You need to specify a debugger program in the debuggers’s settings.无法编译根据提示信息我们需要指定一个debugger program，根据提示我们可以知道指定的菜单栏settings。我们可以看到默认状态下路径是空的，那么我们就需要设置一个路径。 找到code::block的默认安装路径并进入CodeBlocks\\MinGW\\gdb32\\bin选择gdb32.exe。单击OK即可开始进行编译。 设置主题背景首先进入codeblocks官网找到color theme的代码。 紧接着在C盘中找到CodeBlocks/default.conf，注意default.conf文件不再你的安装文件夹下，而是在系统盘下，以win10系统为例，路径为：user/你的用户名/AppData/Roaming/CodeBlocks。 在进行下一步前，要确保codeblocks已经关闭。 下一步是通过记事本打开default.conf文件，把default.conf文件中的代码全部替换为第一步中在codeblocks官网上找到的代码，保存并关闭。注意在替default.conf文件代码时最好做好备份以免出错。 下一步就是感受快乐了！！！ 下下一步，如果想要改变其他风格可以在Settings/Editor/Syntax Highlighting/colour theme中选择想要的风格，也可以自定义各种颜色，还可以在margins and caret–&gt;caret的color中设置光标颜色。","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://brillianttt.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"code::blocks","slug":"code-blocks","permalink":"https://brillianttt.gitee.io/tags/code-blocks/"}]},{"title":"C++STL学习笔记","slug":"C++STL容器的学习","date":"2020-05-13T13:41:57.792Z","updated":"2020-10-15T16:36:55.456Z","comments":true,"path":"2020/05/13/C++STL容器的学习/","link":"","permalink":"https://brillianttt.gitee.io/2020/05/13/C++STL%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"最近开始学习c++的stl容器，下面记录一些学习的笔记。 STL（Standard Template Library）,中文名为标准模板库，其中封装了许多容器，而容器可以理解为能实现很多功能的东西。在写代码时可以快速调用他们，省去了自己书写完整的时间。 vector的常见用法vector本身可以作为数组使用，在元素不确定的场合可以很好的节省空间 vector的定义123456789101112131415#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; name; vector&lt;double&gt; name; vector&lt;char&gt; name; //如果类型名为vector，就为以下定义方式👇(可以理解为二维数组) vector&lt;vector&lt;int&gt;&gt; name; //vector数组的定义： vector&lt;typename&gt; Arrayname[arraySize]; //例如这样定义（这样其中的每一个都是一个vector容器）： vector nb[666]；&#125; vector二维数组的初始化初始化一个6*5的二维数组： 1234567891011121314#include&lt;iostream&gt;using namespace std;int main() &#123; vector&lt;vector&lt;int&gt; &gt;num = &#123; &#123;1,1,1,0,1,1&#125;,&#123;1,0,1,1,1,1&#125;,&#123;1,1,1,0,0,1&#125;,&#123;1,0,1,0,0,1&#125;,&#123;1,1,1,1,1,1&#125; &#125;; //二维数组初始化 //vector&lt;vector&lt;int&gt;&gt; vec(10, vector&lt;int&gt;(10)); vector&lt;vector&lt;int&gt; &gt;right(num.size(), vector&lt;int&gt;(num[0].size())); vector&lt;vector&lt;int&gt; &gt;down(num.size(), vector&lt;int&gt;(num[0].size())); construct(num, right, down); cout &lt;&lt; calculate(num, right, down) &lt;&lt; endl; return 0;&#125; 也可以这么写： 12std::vector &lt;int&gt; vec(10,90); //将10个一维动态数组初始为90std::vector&lt;std::vector&lt;int&gt; &gt; vec(row,vector&lt;int&gt;(col,0)); //初始化row * col二维动态数组，初始化值为0,其实就是每一行初始化为列数个0 vector的访问vector有两种访问方式：通过下标或者迭代器。下标访问即为以前学过的知识，迭代器访问为c++中新的概念，可以理解为类似指针的东西，可以如下定义： 123vector&lt;typename&gt;::iterator it;//这样就可以通过*it来访问vector里的元素//在循环中使用可以如下定义：for(vector&lt;typename&gt;::iterator it=name.begin();it!=name.end();it++)&#123;&#125; 但是这样写比较繁琐，我们可以使用auto关键字简化代码： 123auto i=name.begin();//在循环中使用可以如下定义：for(auto it=name.begin();it!=name.end();it++)&#123;&#125; vector常用函数1234567891011121314vector&lt;int&gt; name;name.push_back(i)//push_back(i)在name的末尾添加元素i，常和循环连用以输入输出数据name.begin()//取name的首元素地址，和迭代器连用auto i=name.begin(),使得i指向这个地址name.end()//取name的尾地址，用法同上name.pop_back()//删除vector的尾元素name.size()//获得vector中元素的个数，返回unsigned类型，可以用%d输出size_row = name.size(); //获取二维数组行数size_col = name[0].size(); //获取二维数组列数name.clear()//清空vector中的所有元素name.insert(it，x)//用来向vector的任意迭代器it处插入一个元素x，例如：name.insert(name.begin()+2,-1);name.erase(it)//删除迭代器it处的元素name.erase(name.begin()+3)//注意删除的是name[4]name.erase(first,last)//删除[first,last)内的所有元素name.erase(name.first(),name.end())//效果同name.clear() set的常见用法set翻译为集合，是一个内部自动有序并且不含有重复元素的容器，在需要重复的时候，可以快捷的使用set实现自动排序（升序排列）并且去重。 set的定义12set&lt;typename&gt; name;//单独定义一个setset&lt;typename&gt; Arrayname[arraySize];//set数组的定义，Arrayname[0]~Arrayname[arraySize-1]中每一个都是一个set容器 set内元素的访问set只能同迭代器访问： 12set&lt;typename&gt;::iterator it;auto it=name.(); 由于除了vector和string之外的stl容器都不支持*(it+i)的访问方式，因此只能使用枚举法： 1234567891011121314#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main()&#123; set&lt;int&gt; nb; for(int i=10;i&gt;2;i--) &#123; nb.insert(i); &#125; for(auto i=nb.begin();i!=nb.end();i++)&#123; printf(\"%d \",*i); &#125; &#125;//输出 3 4 5 6 7 8 9 10（实现了自动从小到大排序） set常用函数 123456789name.insert(x)//将x插入set容器中，并自动实现递增排序和去重name.find(value)//返回set中对应值为value的迭代器，如printf(\"%d\",*(name.find(2)));name.erase()//用法同vector中的函数一样，一般还可与name.find()连用，实现“找到并删除”name.size()//用来获得set内元素个数name.clear()//清空set内所有元素name.empty()//若集合为空，返回truename.count()//返回某个值元素的个数lower_bound()//lover_bound(val)返回值指向大于（或等于）val的第一个元素的迭代器）upper_bound()//返回大于某个值元素的迭代器 string的常见用法 string对字符串常用的功能进行了封装，使得操作更方便。在使用string时需要添加string头文件即#include string的定义 定义string的方式和基本数据类型相同，可以直接定义 12string str;string str=\"abc\"; string内容的访问通过下标访问 1234string str=\"abcd\";for(int i=0;i&lt;str.length();i++)&#123; printf(\"%c\",str[i]);&#125;//输出结果为abcd 若要输入和输出整个字符串可用cin和cout还有c_str() 1234string str;cin&gt;&gt;str;cout&lt;&lt;str&lt;&lt;endl;printf(\"%s\",str.c_str());//将string型转化为字符数组输出 通过迭代器访问1234567string::iterator it;string str=\"abcd\"; -for(auto it=str.begin();it!=str.end();it++)&#123; printf(\"%c\",*it); printf(\"%c\",*(str.begin()+3));&#125; string常用函数拼接： 123string str1=\"abc\",str2=\"xyz\",str3;str3=str1+str2;//直接将str1和2拼接到str3上str1+=str2；//将str2加到str1后面 比较： 1if(str1&gt;str2) printf(\"balabala\");//按照字典序比较 长度： 1printf(\"%d %d\",str.length(),str.size()); 插入元素： 12str.insert(3,str2);//str2插入str[3]位置str.insert(str.begin(+1),str2.begin(),str2.end());//name.insert(x,y,z)x为待插入位置，y、z分别为要插入字符串的首尾迭代器 其他函数： 12345678910str.erase(it)//删除单个元素，it为需要删除的元素迭代器str.erase(first,last)；//first为需要删除的区间的起始迭代器，last为区间末尾迭代器的下一个地址，即为删除[first,last)str.erase(pos,length);//pos为开始删除的起始位置，length为删除字符个数str.clear();//清空string中的数据str.substr(pos,len)//返回从pos位开始，长度为len的子串str.find(str2)//当str2是str的子串时，返回其在str中第一次出现的位置(即str2第一个字符出现的位置)，若str2不是str的子串时返回string::nopsstring::npos//是一个常数，由于是unsigned_int类型，也可认为时ugsigned_int的最大值str.replace(pos,len,str2)//把str从pos位开始，长度为len的子串替换为str2str.replace(it1，it2，str2)//把str的迭代器[it1，it2)范围的子串替换为str2reverse(str.begin(),str.end()-5);//反转指定区域的字符 map的常见用法map翻译为映射，是常用的stl容器之一。map可以将任何基本类型（包括stl容器）映射到任何类型（也包括stl容器）；在使用map的时候还要添加map头文件。在需要建立字符或字符串与整数之间映射的题目，使用map可以减少代码量；判断大整数或者其它类型的数据是否存在的题目，可以把map当bool使用。 map的定义123map&lt;typename1,typename2&gt;mp;//1、2分别代表映射前和映射后的类型，如果两种类型相同，就相当于普通的数组。map&lt;string,int&gt;mp;//若为字符串到整型的映射，必须使用string而不能用char。map&lt;set&lt;int&gt;,string&gt;mp;//将set容器映射到一个字符串 map容器内元素的访问通常有两种访问方式：通过下标和通过迭代器。 通过下标访问12345678910#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['c']=20; mp['c']=30; printf(\"%d\",mp['c']);&#125;//输出30 通过迭代器访问1map&lt;typename1,typename2&gt;::iterator it;//map迭代器的定义，同样可以用auto 因为map的每一个映射都有两个typename，所以访问方式略有不同，map可以使用it-&gt;first来访问第一个参数（键），it-&gt;second来访问第二个参数（值）。下面举个栗子。 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['m']=20; mp['b']=30; mp['y']=40; for(map&lt;char,int&gt;::iterator it=map.begin();it!=map.end();it++)//也可以写为auto it=begin() &#123; printf(\"%c %d\\n\",it-&gt;first,it-&gt;second); &#125;&#125;//输出如下： b 30 m 20 y 40 有没有发现map按“键”对它进行了从小到大的排序这是通过红黑树实现的（set也是），在建立映射的时候会自动实现从小到大的排序功能。（ps：我暂时也不知道红黑树是什么，等之后学到了回来补充。） map常用函数find()函数123456789101112#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['a']=1; mp['b']=2; mp['c']=3; auto i=mp.find('b');//find(key)返回键为key的映射的迭代器 printf(\"%c %d\",it-&gt;first,it-&gt;second);//输出b 2&#125; erase()erase()有两种用法：删除单个元素和删除一个区间内的所有元素 删除单个元素12345678910111213#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['a']=1; mp['b']=2; mp['c']=3; auto it=mp.find('b');//find(key)返回键为key的映射的迭代器 mp.erase(it)l//删除b 2 mp.erase(key)//key为想要删除的映射的键，如mp.erase('a');&#125; 删除多个元素（区间内）mp.erase(first,last)//first为需要删除的区间的起始迭代器，last为需要删除的区间的末尾迭代器的下一个地址，即为删除左闭右开的区间[first,last),举例如下： 123456789101112#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;mp; mp['a']=1; mp['b']=2; mp['c']=3; auto it=mp.find('b');//find(key)返回键为key的映射的迭代器 mp.erase(it，mp.end())；//删除it后的所有映射，即b 2和c 3&#125; 其他函数size()用来获得map中映射的对数。clear()用来情况map中的所有元素。 quese的常见用法quese翻译为队列，在STL中主要是实现先进先出的容器。在实现广度优先搜索时，可以不用自己动手实现一个队列，而是用queue作为代替，以提高程序的准确性。 queue的定义要使用queue，需要先添加头文件#include，并且在头文件下面加上 using namespace std才可以。定义写法和其他容器一样，typename可以说任意基本数据类型或容器。 1queue&lt;typename&gt;name; queue容器内元素的访问由于queue（队列）本就是一种先进先出的限制性数据结构，因此在stl中只能通过front（）来访问队首元素，或是通过back（）来访问队尾元素。举例如下： 12345678910111213#include&lt;stdio.h&gt;#include&lt;queue&gt;using namespace std;int main()&#123; queue&lt;int&gt; q; for(int i=1;i&lt;=5;i++) &#123; q.push(i);//push(i)用以将i压入队列，因此一次入队1 2 3 4 5 &#125; printf(\"%d %d\",q.front(),q.back());//输出1 5 return 0;&#125; queue常用函数12345678910111213#include&lt;stdio.h&gt;#include&lt;queue&gt;using namespace std;int main()&#123; queue&lt;int&gt; q; q.push()//将x压入队列 q.front()//获得队首元素 q.back()//获得队尾元素 q.pop()//令队首元素出队 q.empty()//检测queue是否为空，返回true则空，false则非空 q.size()//返回queue内元素的个数&#125; 特别注意，在使用front()和pop()函数前，必须用empty()判断队列是否为空，否则可能因为队空而出现错误。 priority_queue的常见用法priority_queue又称优先队列，其底层逻辑是用堆来实现的（我也不知道堆是啥，学了回来填坑）。在优先队列中，队首元素一定是当前队列中优先级最高的那个。在任何时候都可以往优先队列里加入(push)元素，而优先队列的的底层数据结构堆（heap）会随时调整，使得每次的队首元素都是优先级最大的。 priority_queue的定义要使用优先队列，应先添加头文件#include，定义写法和其他stl容器一致，typename可以是任意类型或容器。 1priority_queue&lt;typename&gt;name; priority_queue容器内元素的访问和队列不同，优先队列内没有front()和back()函数，而只能通过top()函数来访问队首元素（即堆顶元素），也就是优先级最高的元素。 priority_queue常用函数市离解析12345push()//push(x)将令x入队top()//top()可以获得队首元素pop()//令队首元素出队empty()//检测优先队列是否为空，返回true则为空，false则为非空size()//返回优先队列内元素的个数 priority_queue内元素优先级的设置基本数据类型的优先级设置基本数据类型即为int型、double型、char型等可以直接使用的数据类型，优先队列对他们的优先级设置一般是数字大的优先级搞，因此队首元素就是优先队列内元素最大的那个（char型则为字典序最大的）。对于基本数据类型来说，下面是两种优先队列的定义是等价的（以int型为例，注意最后两个&gt;之间有一个空格）： 12priority_queue&lt;int&gt; q;priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q; 在第二种定义时多了两个参数，其中vector填写的时来承载底层数据结构堆(heap)的容器,若为double或char型只需更改&lt;&gt;内的内容即可；less则是堆第一个参数的比较类，less表示数字大的优先级越大，而greater表示数字小的优先级越大。因此若想让优先队列将最小的元素放在队首只需进行如下定义： 1priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; 举一个栗子： 12345678910111213#include &lt;cstdio&gt;#include&lt;queue&gt;using namespace std;int main()&#123; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; q.push(3); q.push(4); q.push(1); printf(\"%d\",q.top());//输出1 return 0;&#125; 结构体优先级设置没看懂书上咋设置的 看懂了再回来填坑😂 stack的常见用法stack翻译为栈，是stl中实现的一个后进先出的容器。 stack的定义要使用 stack, 应先添加头文件＃include , 并在头文件下面加上“using namespace std; ”， 然后就可以使用了。 其定义的写法和其他STL容器相同，typename 可以任意基本数据类型或容器。 stack容器内元素的访问由于栈本身是一种后进先出的数据结构，在stl的stack中只能通过top()来访问栈顶元素，举例如下： 1234567891011121314#include &lt;cstdio&gt;#include&lt;stack&gt;using namespace std;int main()&#123; stack&lt;int&gt;st; for(int i=0;i&lt;5;i++) &#123; st.push(i); &#125; printf(\"%d\\n\",st.top());//输出4 return 0;&#125; stack常用函数12345push()//push(x)将x入栈top()//获得栈顶元素pop()//弹出栈顶元素empty()//检测stack内是否为空，返回true为空，返回false为非空size()//返回栈内元素个数 stack的常见用途用来模拟实现一些递归，防止程序对栈内存的限制而导致程序运行出错。一般来说，程序的栈内存空间很小，对有些题目来说，如果用普通的函敷来进行递归，一旦递归层数过深（不同机器不同，约几千至几万层）， 则会导致程序运行崩溃。如果用栈来模拟递归算法的实现，则可以避免这一方面的问题（不过这种应用出现较少）。 pair的常见用法pair是一个很实用的“小玩意”， 当想要将两个元素绑在一起作为一个合成元素、又不想要因此定义结构体时，使用 pair 可以很方便地作为一个代替品。也就是说，pair 实际上可以看作一个内部有两个元素的结构体，且这两个元素的类型是可以指定的，如下面的短代码所示： 1234struct pair&#123; typename1 first; typename2 second;&#125; pair的定义要使用 pair, 应先添加头文件＃include , 并在头文件下面加上＂using namespacestd; ”， 然后就可以使用了，注意：由于map的内部实现中涉及pair, 因此添加map头文件时会自动添加 utility 头文件，此时如果需要使用 pair, 就不需要额外再去添加 utility 头文件了。因此，记不住“utility” 拼写的读者可以愉懒地用 map头文件来代替 utility 头文件。pair 有两个参数，分别对应 first 和 second 的数据类型，它们可以是任意基本数据类型或容器。 1pair&lt;typename1,typename2&gt; name; 因此想要定义参数为string和int类型的pair，就可以使用如下写法： 1pair&lt;string,int&gt; p; 如果要顺便进行初始化，可以这样： 1pair&lt;string,int&gt; p(\"haha\",5); pair中元素的访问pair中只有两个元素，分别为first和second，只需按照正常结构体的方法去访问。 12345678910111213141516171819include &lt;iostream&gt;＃include &lt;utility&gt;＃include &lt;string&gt;using namespace std;int main () &#123; pair &lt;string,int&gt; p; p.first=\"haha\"; p.second=5; cout&lt;&lt;p.first &lt;&lt;\" \"&lt;&lt;p.second &lt;&lt;lendl; p=make_pair (\"xixi\", 55) ; cout&lt;&lt;p.first &lt;&lt;\" \"&lt;&lt;p.second &lt;&lt;endl; p=pair&lt;string,int&gt; (\"heihei\",555); cout&lt;&lt;p.first &lt;&lt;\" \"&lt;&lt;p.second &lt;&lt; endl; return 0; //输出： haha 5 // xixi 55 // heihei 555&#125; pair常用函数比较操作数两个pair类型数据可以直接使用==、!=、&lt;、&lt;=、&gt;、&gt;=比较大小，比较规则是先以first 的大小作为标准，只有当first 相等时才去判别second的大小。 12345678910111213141516include &lt;cstdio&gt; ＃include &lt;utility&gt; using namespace std; int main ()&#123; pair&lt;int,int&gt; p1(5,10): pair&lt;int, int&gt; p2(5, 15); pair&lt;int,int&gt; p3 (10, 5) : if(p1&lt;p3) printf(\"pl &lt;p3\\n\"); if(pl&lt;=p3) printf(\"pl&lt;=p3\\n\"); if(p1&lt;p2) printf(\"pl&lt;p2\\n\"); return 0; //输出: // p1&lt;p3 // p1&lt;=p3 // p1&lt;p2 pair的常见用途1、代替二元结构体及其构造函数，节省编码时间。2、作为map的键值对来进行插入，如这个例子 1234567891011121314151617#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;string,int&gt;mp; mp.insert(make_pair(\"haha\",10)); for(map&lt;string,int&gt;::iterator it=mp.begin();it!=mp.end();it++) &#123; cout&lt;&lt;it-&gt;first&lt;&lt;\" \"&lt;&lt;it-&gt;second&lt;&lt;endl; &#125; return 0; //输出： // haha 10 // heihei 5&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://brillianttt.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"STL","slug":"STL","permalink":"https://brillianttt.gitee.io/tags/STL/"},{"name":"C/C++","slug":"C-C","permalink":"https://brillianttt.gitee.io/tags/C-C/"}]},{"title":"动态规划之最长上升子序列","slug":"动态规划之最长上升子序列","date":"2020-04-05T11:30:22.000Z","updated":"2020-06-03T02:06:18.975Z","comments":true,"path":"2020/04/05/动态规划之最长上升子序列/","link":"","permalink":"https://brillianttt.gitee.io/2020/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"动态规划 动态规划指的是将一个繁杂的问题分解成子问题之后，通过求解子问题的最优解，从而求得整体最优解。 最长上升子序列问题如下：输入数据： 输入的第一行是序列的长度N(1&lt;=N&lt;=1000),第一行给出序列的N个整数，这些整数的取值范围在0-10000. 输出要求： 最长上升子序列的长度。 输入样例： 71 7 3 5 9 4 8 输出样例： 4 范例代码： 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int maxlen[100]; int s[100]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s[i]; maxlen[i] = 1; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (s[i] &gt; s[j]) &#123; maxlen[i] = max(maxlen[i], maxlen[j] + 1); &#125; &#125; &#125; cout &lt;&lt; *max_element(maxlen + 1, maxlen + n + 1);&#125; 讲解： 123456789int n; cin &gt;&gt; n; int maxlen[100]; int s[100]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s[i]; maxlen[i] = 1; &#125; 这一部分是输入数据，并且让存储 以当前下标为终点的子序列的个数 的maxlen数组都初始化为1. 12345678910for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (s[i] &gt; s[j]) &#123; maxlen[i] = max(maxlen[i], maxlen[j] + 1); &#125; &#125; &#125; 这一部分是正式求解&ensp;以当前下标为终点的最长上升子序列&ensp;的长度，并且分别存储在maxlen数组内。i每往后循环一次，j就要将i之前的数据都循环一遍。当s[i]&gt;s[j]时就要求maxlen[j]+1与maxlen[i]之间的最大值进行maxlen[i]的更新。注：之所以需要每次都求maxlen[i]和maxlen[j]+1的最大值，而不直接将maxlen[j]+1赋值给maxlen[i]，是因为maxlen[i]之前的更新可能已经使maxlen[i]&gt;maxlen[[j]+1，故 此时maxlen[i]应保持不变。 最后一部分为输出部分，调用max_element函数输出manlen数组内的最大值。 注：max_element函数返回值是一个指针&emsp;&emsp;max_element和max函数需要调用头文件algorithm","categories":[{"name":"算法","slug":"算法","permalink":"https://brillianttt.gitee.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://brillianttt.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"排序算法","slug":"排序算法","date":"2020-04-03T02:19:36.000Z","updated":"2020-06-04T01:44:14.640Z","comments":true,"path":"2020/04/03/排序算法/","link":"","permalink":"https://brillianttt.gitee.io/2020/04/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt; using namespace std; void merge(int a[], int s, int m, int e, int tmp[])&#123; int pb = 0; int p1 = s, p2 = m+1; while (p1&lt;=m&amp;&amp;p2&lt;=e) &#123; if (a[p1] &gt; a[p2]) tmp[pb++] = a[p2++]; else tmp[pb++] = a[p1++]; &#125; while (p1&lt;=m) &#123; tmp[pb++] = a[p1++]; &#125; while (p2&lt;=e) &#123; tmp[pb++] = a[p2++]; &#125; for (int j = 0; j &lt;= e-s; ++j) &#123; a[s+j] = tmp[j]; &#125;&#125;void mergesort(int a[], int s, int e, int tmp[])&#123; if (s &lt; e) &#123; int m = s + (e - s) / 2; mergesort(a, s, m, tmp); mergesort(a, m + 1, e, tmp); merge(a, s, m, e, tmp); &#125;&#125;int a[9] = &#123; 1,2,3,6,5,4,7,8,9 &#125;;int b[9];int main()&#123; mergesort(a, 0, 8, b); for (int i = 0; i &lt; 9; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; return 0;&#125; 快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt; int a[101],n;//定义全局变量，这两个变量需要在子函数中使用 void quicksort(int left,int right) &#123; int i,j,t,temp; if(left&gt;right) return; temp=a[left]; //temp中存的就是基准数 i=left; j=right; while(i!=j) &#123; //顺序很重要，要先从右往左找 while(a[j]&gt;=temp &amp;&amp; i&lt;j) j--; //再从左往右找 while(a[i]&lt;=temp &amp;&amp; i&lt;j) i++; //交换两个数在数组中的位置 if(i&lt;j)//当哨兵i和哨兵j没有相遇时 &#123; t=a[i]; a[i]=a[j]; a[j]=t; &#125; &#125; //最终将基准数归位 a[left]=a[i]; a[i]=temp; quicksort(left,i-1);//继续处理左边的，这里是一个递归的过程 quicksort(i+1,right);//继续处理右边的，这里是一个递归的过程 &#125; int main() &#123; int i,j,t; //读入数据 scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); quicksort(1,n); //快速排序调用 //输出排序后的结果 for(i=1;i&lt;=n;i++) printf(\"%d \",a[i]); getchar();getchar(); return 0; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://brillianttt.gitee.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://brillianttt.gitee.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"markdown语法的使用教程","slug":"markdown语法的使用教程","date":"2020-03-28T02:22:46.000Z","updated":"2020-06-03T14:03:28.650Z","comments":true,"path":"2020/03/28/markdown语法的使用教程/","link":"","permalink":"https://brillianttt.gitee.io/2020/03/28/markdown%E8%AF%AD%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"这是一个关于markdown语法的链接这是关于markdown插入链接的语法的链接","categories":[{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/categories/markdown%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/tags/markdown%E8%AF%AD%E6%B3%95/"},{"name":"链接","slug":"链接","permalink":"https://brillianttt.gitee.io/tags/%E9%93%BE%E6%8E%A5/"}]},{"title":"markdown插入代码语言类型","slug":"markdown插入代码语言类型","date":"2020-03-27T03:20:21.000Z","updated":"2020-06-03T14:03:27.581Z","comments":true,"path":"2020/03/27/markdown插入代码语言类型/","link":"","permalink":"https://brillianttt.gitee.io/2020/03/27/markdown%E6%8F%92%E5%85%A5%E4%BB%A3%E7%A0%81%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"markdown插入代码语言类型 在使用markdown进行写文章时有时需要插入代码块，但是对于新手来说并不太清楚各种语言是怎样标记的，本文总结出来，如下：","categories":[{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/categories/markdown%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/tags/markdown%E8%AF%AD%E6%B3%95/"}]},{"title":"0号测试","slug":"今晚做一丢丢更新","date":"2020-03-26T13:50:33.000Z","updated":"2020-05-15T14:46:59.978Z","comments":true,"path":"2020/03/26/今晚做一丢丢更新/","link":"","permalink":"https://brillianttt.gitee.io/2020/03/26/%E4%BB%8A%E6%99%9A%E5%81%9A%E4%B8%80%E4%B8%A2%E4%B8%A2%E6%9B%B4%E6%96%B0/","excerpt":"","text":"可能会更改一下界面，以后经常更新设置，也经常记录学习的经历和经验。 123456#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;\"hello world\";&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://brillianttt.gitee.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"过生日","slug":"过生日","date":"2020-01-21T02:17:24.692Z","updated":"2020-01-21T02:25:31.946Z","comments":true,"path":"2020/01/21/过生日/","link":"","permalink":"https://brillianttt.gitee.io/2020/01/21/%E8%BF%87%E7%94%9F%E6%97%A5/","excerpt":"","text":"今天小马过十九岁生日了！今天似乎确凿是在世的6986天","categories":[],"tags":[]},{"title":"小马的2019年度总结","slug":"小马的2019年度总结","date":"2020-01-20T04:09:29.478Z","updated":"2020-05-26T10:05:41.907Z","comments":true,"path":"2020/01/20/小马的2019年度总结/","link":"","permalink":"https://brillianttt.gitee.io/2020/01/20/%E5%B0%8F%E9%A9%AC%E7%9A%842019%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","excerpt":"","text":"2019，注定是不平凡的一年，从年初还在班里埋头学习，到年末在大学广场里high歌， 这一年或者这几年的辛酸苦辣，仿佛都在今天 结束了。三年前，带着中考失利的辛酸来到了高中。从那年的暑假励志高考要弯道超车，要证明自己可以好好学习，也可以优秀，也不负张老师的希望。这三年，好像一直都没有融进8班或11班的大家庭，老实说，仿佛对大环境有着天然的排斥。现在看来，自己的想法是很愚蠢的，所有的路都是自己一步一步走过来的，结果自然也要自己接受。 高中三年，是痛苦并快乐着的，痛苦是因为开始适应环境，快乐是因为自己在慢慢成长。因为自己的凉薄和冷漠，也有年少无知的轻狂，在高二那年的夏天，经历了自己人生的一个低谷，两件事情，双重打击，很长一段时间都活在愧疚中。 快乐是因为自己的学习在不断的进步，印象很清楚，进入18中排名是248，高一第一次月考就考了32名，虽然自己在之后考试中都在1、2考场徘徊着，但那时我知道，自己很努力了，三四月做的事情，在八九月自有答案。没有见过凌晨四点的洛杉矶，但三年来天天见凌晨四点半的呼和浩特。在颓废和打鸡血的交织中，高中三年，终于在今年夏天落下了帷幕。大学嘛，时间如白驹过隙，一不小心就过了八分之一啦。凡此过往，皆为序章，辛辛苦苦 熬了三年，大学的生活，不正是当年梦寐以求的吗，希望自己像高中一样，记住自己的初心，好好努力，不负自己的芳华。 谢谢所有在我最痛苦最难受的时候给予我帮助的人，谢谢自己的家人，在高中三年给予了我最无微不至的照顾，谢谢小姐姐的暖心，也谢谢自己的好兄弟和好伙伴们，陪我一起度过了高中三年。所有快乐，所有争执，所有幸福，都化为生活的碎片，留存在记忆当中。","categories":[],"tags":[]}],"categories":[{"name":"学习","slug":"学习","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"项目","slug":"项目","permalink":"https://brillianttt.gitee.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"随笔","slug":"随笔","permalink":"https://brillianttt.gitee.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"博客开发","slug":"博客开发","permalink":"https://brillianttt.gitee.io/categories/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://brillianttt.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"数学","permalink":"https://brillianttt.gitee.io/categories/%E6%95%B0%E5%AD%A6/"},{"name":"算法","slug":"算法","permalink":"https://brillianttt.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/categories/markdown%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"学习 - 深度学习","slug":"学习-深度学习","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"项目","slug":"项目","permalink":"https://brillianttt.gitee.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"随笔","slug":"随笔","permalink":"https://brillianttt.gitee.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"QT","slug":"QT","permalink":"https://brillianttt.gitee.io/tags/QT/"},{"name":"BUG解决","slug":"BUG解决","permalink":"https://brillianttt.gitee.io/tags/BUG%E8%A7%A3%E5%86%B3/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://brillianttt.gitee.io/tags/OpenCV/"},{"name":"C/C++","slug":"C-C","permalink":"https://brillianttt.gitee.io/tags/C-C/"},{"name":"RSA","slug":"RSA","permalink":"https://brillianttt.gitee.io/tags/RSA/"},{"name":"仿射密码","slug":"仿射密码","permalink":"https://brillianttt.gitee.io/tags/%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81/"},{"name":"密码学","slug":"密码学","permalink":"https://brillianttt.gitee.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"照片","slug":"照片","permalink":"https://brillianttt.gitee.io/tags/%E7%85%A7%E7%89%87/"},{"name":"猫","slug":"猫","permalink":"https://brillianttt.gitee.io/tags/%E7%8C%AB/"},{"name":"Summer summary","slug":"Summer-summary","permalink":"https://brillianttt.gitee.io/tags/Summer-summary/"},{"name":"数学","slug":"数学","permalink":"https://brillianttt.gitee.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"暑假学习","slug":"暑假学习","permalink":"https://brillianttt.gitee.io/tags/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0/"},{"name":"0-1背包问题","slug":"0-1背包问题","permalink":"https://brillianttt.gitee.io/tags/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"学习总结","slug":"学习总结","permalink":"https://brillianttt.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"bfs","slug":"bfs","permalink":"https://brillianttt.gitee.io/tags/bfs/"},{"name":"dfs","slug":"dfs","permalink":"https://brillianttt.gitee.io/tags/dfs/"},{"name":"链表","slug":"链表","permalink":"https://brillianttt.gitee.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"位运算","slug":"位运算","permalink":"https://brillianttt.gitee.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"笔记","slug":"笔记","permalink":"https://brillianttt.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"库函数的使用","slug":"库函数的使用","permalink":"https://brillianttt.gitee.io/tags/%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"name":"code::blocks","slug":"code-blocks","permalink":"https://brillianttt.gitee.io/tags/code-blocks/"},{"name":"STL","slug":"STL","permalink":"https://brillianttt.gitee.io/tags/STL/"},{"name":"动态规划","slug":"动态规划","permalink":"https://brillianttt.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"排序","slug":"排序","permalink":"https://brillianttt.gitee.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"markdown语法","slug":"markdown语法","permalink":"https://brillianttt.gitee.io/tags/markdown%E8%AF%AD%E6%B3%95/"},{"name":"链接","slug":"链接","permalink":"https://brillianttt.gitee.io/tags/%E9%93%BE%E6%8E%A5/"},{"name":"测试","slug":"测试","permalink":"https://brillianttt.gitee.io/tags/%E6%B5%8B%E8%AF%95/"}]}